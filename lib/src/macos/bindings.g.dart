// AUTO GENERATED FILE, DO NOT EDIT.
//
// Generated by `package:ffigen`.
// ignore_for_file: type=lint, unused_import
import 'dart:ffi' as ffi;
import 'package:objective_c/objective_c.dart' as objc;
import 'package:ffi/ffi.dart' as pkg_ffi;

@ffi.Native<ffi.Void Function(ffi.Pointer<ffi.Void>)>()
external void CFRelease(ffi.Pointer<ffi.Void> cf);

@ffi.Native<
  ffi.Pointer<__CFData> Function(ffi.Pointer<__CFAllocator>, ffi.Long)
>()
external ffi.Pointer<__CFData> CFDataCreateMutable(
  ffi.Pointer<__CFAllocator> allocator,
  int capacity,
);

@ffi.Native<ffi.Long Function(ffi.Pointer<__CFData>)>()
external int CFDataGetLength(ffi.Pointer<__CFData> theData);

@ffi.Native<ffi.Pointer<ffi.UnsignedChar> Function(ffi.Pointer<__CFData>)>()
external ffi.Pointer<ffi.UnsignedChar> CFDataGetBytePtr(
  ffi.Pointer<__CFData> theData,
);

@ffi.Native<
  ffi.Pointer<objc.CFString> Function(
    ffi.Pointer<__CFAllocator>,
    ffi.Pointer<ffi.Char>,
    ffi.UnsignedInt,
  )
>()
external ffi.Pointer<objc.CFString> CFStringCreateWithCString(
  ffi.Pointer<__CFAllocator> alloc,
  ffi.Pointer<ffi.Char> cStr,
  int encoding,
);

@ffi.Native<ffi.Pointer<objc.CFString>>()
external ffi.Pointer<objc.CFString> kUTTypeBMP;

@ffi.Native<ffi.Bool Function()>()
external bool CGPreflightScreenCaptureAccess();

@ffi.Native<ffi.Bool Function()>()
external bool CGRequestScreenCaptureAccess();

@ffi.Native<
  ffi.Pointer<CGImageDestination> Function(
    ffi.Pointer<__CFData>,
    ffi.Pointer<objc.CFString>,
    ffi.Size,
    ffi.Pointer<__CFDictionary>,
  )
>()
external ffi.Pointer<CGImageDestination> CGImageDestinationCreateWithData(
  ffi.Pointer<__CFData> data,
  ffi.Pointer<objc.CFString> type,
  int count,
  ffi.Pointer<__CFDictionary> options,
);

@ffi.Native<
  ffi.Void Function(
    ffi.Pointer<CGImageDestination>,
    ffi.Pointer<CGImage>,
    ffi.Pointer<__CFDictionary>,
  )
>()
external void CGImageDestinationAddImage(
  ffi.Pointer<CGImageDestination> idst,
  ffi.Pointer<CGImage> image,
  ffi.Pointer<__CFDictionary> properties,
);

@ffi.Native<ffi.Bool Function(ffi.Pointer<CGImageDestination>)>()
external bool CGImageDestinationFinalize(ffi.Pointer<CGImageDestination> idst);

@ffi.Native<
  ffi.Pointer<objc.ObjCBlockImpl> Function(ffi.Pointer<objc.ObjCBlockImpl>)
>(isLeaf: true)
external ffi.Pointer<objc.ObjCBlockImpl>
_NativeLibrary_wrapListenerBlock_pfv6jd(ffi.Pointer<objc.ObjCBlockImpl> block);

@ffi.Native<
  ffi.Pointer<objc.ObjCBlockImpl> Function(
    ffi.Pointer<objc.ObjCBlockImpl>,
    ffi.Pointer<objc.ObjCBlockImpl>,
    ffi.Pointer<objc.DOBJC_Context>,
  )
>(isLeaf: true)
external ffi.Pointer<objc.ObjCBlockImpl>
_NativeLibrary_wrapBlockingBlock_pfv6jd(
  ffi.Pointer<objc.ObjCBlockImpl> block,
  ffi.Pointer<objc.ObjCBlockImpl> listnerBlock,
  ffi.Pointer<objc.DOBJC_Context> context,
);

@ffi.Native<
  ffi.Bool Function(ffi.Pointer<objc.ObjCObjectImpl>, ffi.Pointer<ffi.Void>)
>()
external bool _NativeLibrary_protocolTrampoline_e3qsqz(
  ffi.Pointer<objc.ObjCObjectImpl> target,
  ffi.Pointer<ffi.Void> arg0,
);

@ffi.Native<
  ffi.Pointer<objc.ObjCBlockImpl> Function(ffi.Pointer<objc.ObjCBlockImpl>)
>(isLeaf: true)
external ffi.Pointer<objc.ObjCBlockImpl>
_NativeLibrary_wrapListenerBlock_18v1jvf(ffi.Pointer<objc.ObjCBlockImpl> block);

@ffi.Native<
  ffi.Pointer<objc.ObjCBlockImpl> Function(
    ffi.Pointer<objc.ObjCBlockImpl>,
    ffi.Pointer<objc.ObjCBlockImpl>,
    ffi.Pointer<objc.DOBJC_Context>,
  )
>(isLeaf: true)
external ffi.Pointer<objc.ObjCBlockImpl>
_NativeLibrary_wrapBlockingBlock_18v1jvf(
  ffi.Pointer<objc.ObjCBlockImpl> block,
  ffi.Pointer<objc.ObjCBlockImpl> listnerBlock,
  ffi.Pointer<objc.DOBJC_Context> context,
);

@ffi.Native<
  ffi.Void Function(
    ffi.Pointer<objc.ObjCObjectImpl>,
    ffi.Pointer<ffi.Void>,
    ffi.Pointer<objc.ObjCObjectImpl>,
  )
>()
external void _NativeLibrary_protocolTrampoline_18v1jvf(
  ffi.Pointer<objc.ObjCObjectImpl> target,
  ffi.Pointer<ffi.Void> arg0,
  ffi.Pointer<objc.ObjCObjectImpl> arg1,
);

@ffi.Native<
  instancetype Function(
    ffi.Pointer<objc.ObjCObjectImpl>,
    ffi.Pointer<ffi.Void>,
    ffi.Pointer<objc.ObjCObjectImpl>,
  )
>()
external instancetype _NativeLibrary_protocolTrampoline_xr62hr(
  ffi.Pointer<objc.ObjCObjectImpl> target,
  ffi.Pointer<ffi.Void> arg0,
  ffi.Pointer<objc.ObjCObjectImpl> arg1,
);

@ffi.Native<
  ffi.Pointer<objc.ObjCBlockImpl> Function(ffi.Pointer<objc.ObjCBlockImpl>)
>(isLeaf: true)
external ffi.Pointer<objc.ObjCBlockImpl>
_NativeLibrary_wrapListenerBlock_ro4zln(ffi.Pointer<objc.ObjCBlockImpl> block);

@ffi.Native<
  ffi.Pointer<objc.ObjCBlockImpl> Function(
    ffi.Pointer<objc.ObjCBlockImpl>,
    ffi.Pointer<objc.ObjCBlockImpl>,
    ffi.Pointer<objc.DOBJC_Context>,
  )
>(isLeaf: true)
external ffi.Pointer<objc.ObjCBlockImpl>
_NativeLibrary_wrapBlockingBlock_ro4zln(
  ffi.Pointer<objc.ObjCBlockImpl> block,
  ffi.Pointer<objc.ObjCBlockImpl> listnerBlock,
  ffi.Pointer<objc.DOBJC_Context> context,
);

@ffi.Native<
  ffi.Pointer<objc.ObjCBlockImpl> Function(ffi.Pointer<objc.ObjCBlockImpl>)
>(isLeaf: true)
external ffi.Pointer<objc.ObjCBlockImpl>
_NativeLibrary_wrapListenerBlock_19ugjh7(ffi.Pointer<objc.ObjCBlockImpl> block);

@ffi.Native<
  ffi.Pointer<objc.ObjCBlockImpl> Function(
    ffi.Pointer<objc.ObjCBlockImpl>,
    ffi.Pointer<objc.ObjCBlockImpl>,
    ffi.Pointer<objc.DOBJC_Context>,
  )
>(isLeaf: true)
external ffi.Pointer<objc.ObjCBlockImpl>
_NativeLibrary_wrapBlockingBlock_19ugjh7(
  ffi.Pointer<objc.ObjCBlockImpl> block,
  ffi.Pointer<objc.ObjCBlockImpl> listnerBlock,
  ffi.Pointer<objc.DOBJC_Context> context,
);

@ffi.Native<ffi.Pointer<objc.ObjCObjectImpl>>(symbol: 'UTTypeBMP')
external ffi.Pointer<objc.ObjCObjectImpl> _UTTypeBMP;

UTType get UTTypeBMP =>
    UTType.fromPointer(_UTTypeBMP, retain: true, release: true);

set UTTypeBMP(UTType value) {
  UTType.fromPointer(_UTTypeBMP, retain: false, release: true).ref.release();
  _UTTypeBMP = value.ref.retainAndReturnPointer();
}

final class __CFAllocator extends ffi.Opaque {}

final class __CFDictionary extends ffi.Opaque {}

final class __CFData extends ffi.Opaque {}

sealed class NSAlignmentOptions {
  static const NSAlignMinXInward = 1;
  static const NSAlignMinYInward = 2;
  static const NSAlignMaxXInward = 4;
  static const NSAlignMaxYInward = 8;
  static const NSAlignWidthInward = 16;
  static const NSAlignHeightInward = 32;
  static const NSAlignMinXOutward = 256;
  static const NSAlignMinYOutward = 512;
  static const NSAlignMaxXOutward = 1024;
  static const NSAlignMaxYOutward = 2048;
  static const NSAlignWidthOutward = 4096;
  static const NSAlignHeightOutward = 8192;
  static const NSAlignMinXNearest = 65536;
  static const NSAlignMinYNearest = 131072;
  static const NSAlignMaxXNearest = 262144;
  static const NSAlignMaxYNearest = 524288;
  static const NSAlignWidthNearest = 1048576;
  static const NSAlignHeightNearest = 2097152;
  static const NSAlignRectFlipped = -9223372036854775808;
  static const NSAlignAllEdgesInward = 15;
  static const NSAlignAllEdgesOutward = 3840;
  static const NSAlignAllEdgesNearest = 983040;
}

enum NSWindowDepth {
  NSWindowDepthTwentyfourBitRGB(520),
  NSWindowDepthSixtyfourBitRGB(528),
  NSWindowDepthOnehundredtwentyeightBitRGB(544);

  final int value;
  const NSWindowDepth(this.value);

  static NSWindowDepth fromValue(int value) => switch (value) {
    520 => NSWindowDepthTwentyfourBitRGB,
    528 => NSWindowDepthSixtyfourBitRGB,
    544 => NSWindowDepthOnehundredtwentyeightBitRGB,
    _ => throw ArgumentError('Unknown value for NSWindowDepth: $value'),
  };
}

enum NSDisplayGamut {
  NSDisplayGamutSRGB(1),
  NSDisplayGamutP3(2);

  final int value;
  const NSDisplayGamut(this.value);

  static NSDisplayGamut fromValue(int value) => switch (value) {
    1 => NSDisplayGamutSRGB,
    2 => NSDisplayGamutP3,
    _ => throw ArgumentError('Unknown value for NSDisplayGamut: $value'),
  };
}

final class CGColor extends ffi.Opaque {}

final class CGColorSpace extends ffi.Opaque {}

final class CGImage extends ffi.Opaque {}

final class CGImageDestination extends ffi.Opaque {}

enum NSColorSpaceModel {
  NSColorSpaceModelUnknown(-1),
  NSColorSpaceModelGray(0),
  NSColorSpaceModelRGB(1),
  NSColorSpaceModelCMYK(2),
  NSColorSpaceModelLAB(3),
  NSColorSpaceModelDeviceN(4),
  NSColorSpaceModelIndexed(5),
  NSColorSpaceModelPatterned(6);

  final int value;
  const NSColorSpaceModel(this.value);

  static NSColorSpaceModel fromValue(int value) => switch (value) {
    -1 => NSColorSpaceModelUnknown,
    0 => NSColorSpaceModelGray,
    1 => NSColorSpaceModelRGB,
    2 => NSColorSpaceModelCMYK,
    3 => NSColorSpaceModelLAB,
    4 => NSColorSpaceModelDeviceN,
    5 => NSColorSpaceModelIndexed,
    6 => NSColorSpaceModelPatterned,
    _ => throw ArgumentError('Unknown value for NSColorSpaceModel: $value'),
  };
}

/// WARNING: NSColorSpace is a stub. To generate bindings for this class, include
/// NSColorSpace in your config's objc-interfaces list.
///
/// NSColorSpace
extension type NSColorSpace._(objc.ObjCObject object$)
    implements objc.ObjCObject, objc.NSObject, objc.NSSecureCoding {
  /// Constructs a [NSColorSpace] that points to the same underlying object as [other].
  NSColorSpace.as(objc.ObjCObject other) : object$ = other {
    objc.checkOsVersionInternal('NSColorSpace', iOS: (true, null));
  }

  /// Constructs a [NSColorSpace] that wraps the given raw object pointer.
  NSColorSpace.fromPointer(
    ffi.Pointer<objc.ObjCObjectImpl> other, {
    bool retain = false,
    bool release = false,
  }) : object$ = objc.ObjCObject(other, retain: retain, release: release) {
    objc.checkOsVersionInternal('NSColorSpace', iOS: (true, null));
  }
}

late final _class_NSScreen = objc.getClass("NSScreen");
late final _sel_isKindOfClass_ = objc.registerName("isKindOfClass:");
final _objc_msgSend_19nvye5 = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Bool Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Pointer<objc.ObjCObjectImpl>,
        )
      >
    >()
    .asFunction<
      bool Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
        ffi.Pointer<objc.ObjCObjectImpl>,
      )
    >();
late final _sel_screens = objc.registerName("screens");
final _objc_msgSend_151sglz = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Pointer<objc.ObjCObjectImpl> Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
        )
      >
    >()
    .asFunction<
      ffi.Pointer<objc.ObjCObjectImpl> Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
      )
    >();
late final _sel_mainScreen = objc.registerName("mainScreen");
late final _sel_deepestScreen = objc.registerName("deepestScreen");
late final _sel_screensHaveSeparateSpaces = objc.registerName(
  "screensHaveSeparateSpaces",
);
final _objc_msgSend_91o635 = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Bool Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
        )
      >
    >()
    .asFunction<
      bool Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
      )
    >();
late final _sel_depth = objc.registerName("depth");
final _objc_msgSend_8sdj0f = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Int32 Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
        )
      >
    >()
    .asFunction<
      int Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
      )
    >();
late final _sel_frame = objc.registerName("frame");
final _objc_msgSend_bu1hbw = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        objc.CGRect Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
        )
      >
    >()
    .asFunction<
      objc.CGRect Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
      )
    >();
final _objc_msgSend_bu1hbwStret = objc.msgSendStretPointer
    .cast<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<objc.CGRect>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
        )
      >
    >()
    .asFunction<
      void Function(
        ffi.Pointer<objc.CGRect>,
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
      )
    >();
late final _sel_visibleFrame = objc.registerName("visibleFrame");
late final _sel_deviceDescription = objc.registerName("deviceDescription");
late final _sel_colorSpace = objc.registerName("colorSpace");
late final _sel_supportedWindowDepths = objc.registerName(
  "supportedWindowDepths",
);
final _objc_msgSend_1nb3zed = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Pointer<ffi.Int32> Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
        )
      >
    >()
    .asFunction<
      ffi.Pointer<ffi.Int32> Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
      )
    >();
late final _sel_canRepresentDisplayGamut_ = objc.registerName(
  "canRepresentDisplayGamut:",
);
final _objc_msgSend_728x5i = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Bool Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Long,
        )
      >
    >()
    .asFunction<
      bool Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
        int,
      )
    >();
late final _sel_convertRectToBacking_ = objc.registerName(
  "convertRectToBacking:",
);
final _objc_msgSend_1gn1s3d = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        objc.CGRect Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
          objc.CGRect,
        )
      >
    >()
    .asFunction<
      objc.CGRect Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
        objc.CGRect,
      )
    >();
final _objc_msgSend_1gn1s3dStret = objc.msgSendStretPointer
    .cast<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<objc.CGRect>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
          objc.CGRect,
        )
      >
    >()
    .asFunction<
      void Function(
        ffi.Pointer<objc.CGRect>,
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
        objc.CGRect,
      )
    >();
late final _sel_convertRectFromBacking_ = objc.registerName(
  "convertRectFromBacking:",
);
late final _sel_backingAlignedRect_options_ = objc.registerName(
  "backingAlignedRect:options:",
);
final _objc_msgSend_qmdcb3 = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        objc.CGRect Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
          objc.CGRect,
          ffi.LongLong,
        )
      >
    >()
    .asFunction<
      objc.CGRect Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
        objc.CGRect,
        int,
      )
    >();
final _objc_msgSend_qmdcb3Stret = objc.msgSendStretPointer
    .cast<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<objc.CGRect>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
          objc.CGRect,
          ffi.LongLong,
        )
      >
    >()
    .asFunction<
      void Function(
        ffi.Pointer<objc.CGRect>,
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
        objc.CGRect,
        int,
      )
    >();
late final _sel_backingScaleFactor = objc.registerName("backingScaleFactor");
final _objc_msgSend_1ukqyt8 = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Double Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
        )
      >
    >()
    .asFunction<
      double Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
      )
    >();
final _objc_msgSend_1ukqyt8Fpret = objc.msgSendFpretPointer
    .cast<
      ffi.NativeFunction<
        ffi.Double Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
        )
      >
    >()
    .asFunction<
      double Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
      )
    >();
late final _sel_localizedName = objc.registerName("localizedName");
late final _sel_safeAreaInsets = objc.registerName("safeAreaInsets");
final _objc_msgSend_sl0cgw = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        objc.NSEdgeInsets Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
        )
      >
    >()
    .asFunction<
      objc.NSEdgeInsets Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
      )
    >();
final _objc_msgSend_sl0cgwStret = objc.msgSendStretPointer
    .cast<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<objc.NSEdgeInsets>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
        )
      >
    >()
    .asFunction<
      void Function(
        ffi.Pointer<objc.NSEdgeInsets>,
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
      )
    >();
late final _sel_auxiliaryTopLeftArea = objc.registerName(
  "auxiliaryTopLeftArea",
);
late final _sel_auxiliaryTopRightArea = objc.registerName(
  "auxiliaryTopRightArea",
);
late final _sel_CGDirectDisplayID = objc.registerName("CGDirectDisplayID");
final _objc_msgSend_usggvf = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Uint32 Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
        )
      >
    >()
    .asFunction<
      int Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
      )
    >();
typedef instancetype = ffi.Pointer<objc.ObjCObjectImpl>;
typedef Dartinstancetype = objc.ObjCObject;
late final _sel_init = objc.registerName("init");
late final _sel_new = objc.registerName("new");
late final _sel_allocWithZone_ = objc.registerName("allocWithZone:");
final _objc_msgSend_1cwp428 = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Pointer<objc.ObjCObjectImpl> Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Pointer<objc.NSZone>,
        )
      >
    >()
    .asFunction<
      ffi.Pointer<objc.ObjCObjectImpl> Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
        ffi.Pointer<objc.NSZone>,
      )
    >();
late final _sel_alloc = objc.registerName("alloc");
late final _sel_maximumExtendedDynamicRangeColorComponentValue = objc
    .registerName("maximumExtendedDynamicRangeColorComponentValue");
late final _sel_maximumPotentialExtendedDynamicRangeColorComponentValue = objc
    .registerName("maximumPotentialExtendedDynamicRangeColorComponentValue");
late final _sel_maximumReferenceExtendedDynamicRangeColorComponentValue = objc
    .registerName("maximumReferenceExtendedDynamicRangeColorComponentValue");
late final _sel_maximumFramesPerSecond = objc.registerName(
  "maximumFramesPerSecond",
);
final _objc_msgSend_1hz7y9r = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Long Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
        )
      >
    >()
    .asFunction<
      int Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
      )
    >();
late final _sel_minimumRefreshInterval = objc.registerName(
  "minimumRefreshInterval",
);
late final _sel_maximumRefreshInterval = objc.registerName(
  "maximumRefreshInterval",
);
late final _sel_displayUpdateGranularity = objc.registerName(
  "displayUpdateGranularity",
);
late final _sel_lastDisplayUpdateTimestamp = objc.registerName(
  "lastDisplayUpdateTimestamp",
);

///
extension unnamed on NSScreen {}

///
extension unnamed$1 on NSScreen {}

/// WARNING: CADisplayLink is a stub. To generate bindings for this class, include
/// CADisplayLink in your config's objc-interfaces list.
///
/// CADisplayLink
extension type CADisplayLink._(objc.ObjCObject object$)
    implements objc.ObjCObject {
  /// Constructs a [CADisplayLink] that points to the same underlying object as [other].
  CADisplayLink.as(objc.ObjCObject other) : object$ = other {}

  /// Constructs a [CADisplayLink] that wraps the given raw object pointer.
  CADisplayLink.fromPointer(
    ffi.Pointer<objc.ObjCObjectImpl> other, {
    bool retain = false,
    bool release = false,
  }) : object$ = objc.ObjCObject(other, retain: retain, release: release) {}
}

late final _sel_displayLinkWithTarget_selector_ = objc.registerName(
  "displayLinkWithTarget:selector:",
);
final _objc_msgSend_836y90 = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Pointer<objc.ObjCObjectImpl> Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
        )
      >
    >()
    .asFunction<
      ffi.Pointer<objc.ObjCObjectImpl> Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
      )
    >();

/// NSDisplayLink
extension NSDisplayLink on NSScreen {
  /// displayLinkWithTarget:selector:
  CADisplayLink displayLinkWithTarget(
    objc.ObjCObject target, {
    required ffi.Pointer<objc.ObjCSelector> selector,
  }) {
    objc.checkOsVersionInternal(
      'NSScreen.displayLinkWithTarget:selector:',
      iOS: (true, null),
    );
    final $ret = _objc_msgSend_836y90(
      object$.ref.pointer,
      _sel_displayLinkWithTarget_selector_,
      target.ref.pointer,
      selector,
    );
    return CADisplayLink.fromPointer($ret, retain: true, release: true);
  }
}

late final _sel_userSpaceScaleFactor = objc.registerName(
  "userSpaceScaleFactor",
);

/// NSDeprecated
extension NSDeprecated on NSScreen {
  /// userSpaceScaleFactor
  double userSpaceScaleFactor() {
    objc.checkOsVersionInternal(
      'NSScreen.userSpaceScaleFactor',
      iOS: (true, null),
      macOS: (false, (10, 4, 0)),
    );
    return objc.useMsgSendVariants
        ? _objc_msgSend_1ukqyt8Fpret(
            object$.ref.pointer,
            _sel_userSpaceScaleFactor,
          )
        : _objc_msgSend_1ukqyt8(object$.ref.pointer, _sel_userSpaceScaleFactor);
  }
}

/// NSScreen
extension type NSScreen._(objc.ObjCObject object$)
    implements objc.ObjCObject, objc.NSObject {
  /// Constructs a [NSScreen] that points to the same underlying object as [other].
  NSScreen.as(objc.ObjCObject other) : object$ = other {
    objc.checkOsVersionInternal('NSScreen', iOS: (true, null));
    assert(isA(object$));
  }

  /// Constructs a [NSScreen] that wraps the given raw object pointer.
  NSScreen.fromPointer(
    ffi.Pointer<objc.ObjCObjectImpl> other, {
    bool retain = false,
    bool release = false,
  }) : object$ = objc.ObjCObject(other, retain: retain, release: release) {
    objc.checkOsVersionInternal('NSScreen', iOS: (true, null));
    assert(isA(object$));
  }

  /// Returns whether [obj] is an instance of [NSScreen].
  static bool isA(objc.ObjCObject obj) => _objc_msgSend_19nvye5(
    obj.ref.pointer,
    _sel_isKindOfClass_,
    _class_NSScreen,
  );

  /// alloc
  static NSScreen alloc() {
    final $ret = _objc_msgSend_151sglz(_class_NSScreen, _sel_alloc);
    return NSScreen.fromPointer($ret, retain: false, release: true);
  }

  /// allocWithZone:
  static NSScreen allocWithZone(ffi.Pointer<objc.NSZone> zone) {
    final $ret = _objc_msgSend_1cwp428(
      _class_NSScreen,
      _sel_allocWithZone_,
      zone,
    );
    return NSScreen.fromPointer($ret, retain: false, release: true);
  }

  /// deepestScreen
  static NSScreen? getDeepestScreen() {
    objc.checkOsVersionInternal('NSScreen.deepestScreen', iOS: (true, null));
    final $ret = _objc_msgSend_151sglz(_class_NSScreen, _sel_deepestScreen);
    return $ret.address == 0
        ? null
        : NSScreen.fromPointer($ret, retain: true, release: true);
  }

  /// mainScreen
  static NSScreen? getMainScreen() {
    objc.checkOsVersionInternal('NSScreen.mainScreen', iOS: (true, null));
    final $ret = _objc_msgSend_151sglz(_class_NSScreen, _sel_mainScreen);
    return $ret.address == 0
        ? null
        : NSScreen.fromPointer($ret, retain: true, release: true);
  }

  /// new
  static NSScreen new$() {
    final $ret = _objc_msgSend_151sglz(_class_NSScreen, _sel_new);
    return NSScreen.fromPointer($ret, retain: false, release: true);
  }

  /// screens
  static objc.NSArray getScreens() {
    objc.checkOsVersionInternal('NSScreen.screens', iOS: (true, null));
    final $ret = _objc_msgSend_151sglz(_class_NSScreen, _sel_screens);
    return objc.NSArray.fromPointer($ret, retain: true, release: true);
  }

  /// screensHaveSeparateSpaces
  static bool getScreensHaveSeparateSpaces() {
    objc.checkOsVersionInternal(
      'NSScreen.screensHaveSeparateSpaces',
      iOS: (true, null),
      macOS: (false, (10, 9, 0)),
    );
    return _objc_msgSend_91o635(
      _class_NSScreen,
      _sel_screensHaveSeparateSpaces,
    );
  }

  /// Returns a new instance of NSScreen constructed with the default `new` method.
  NSScreen() : this.as(new$().object$);
}

extension NSScreen$Methods on NSScreen {
  /// CGDirectDisplayID
  int get CGDirectDisplayID {
    objc.checkOsVersionInternal(
      'NSScreen.CGDirectDisplayID',
      iOS: (true, null),
      macOS: (false, (26, 0, 0)),
    );
    return _objc_msgSend_usggvf(object$.ref.pointer, _sel_CGDirectDisplayID);
  }

  /// auxiliaryTopLeftArea
  objc.CGRect get auxiliaryTopLeftArea {
    objc.checkOsVersionInternal(
      'NSScreen.auxiliaryTopLeftArea',
      iOS: (true, null),
      macOS: (false, (12, 0, 0)),
    );
    final $ptr = pkg_ffi.calloc<objc.CGRect>();
    objc.useMsgSendVariants
        ? _objc_msgSend_bu1hbwStret(
            $ptr,
            object$.ref.pointer,
            _sel_auxiliaryTopLeftArea,
          )
        : $ptr.ref = _objc_msgSend_bu1hbw(
            object$.ref.pointer,
            _sel_auxiliaryTopLeftArea,
          );
    final $finalizable = $ptr.cast<ffi.Uint8>().asTypedList(
      ffi.sizeOf<objc.CGRect>(),
      finalizer: pkg_ffi.calloc.nativeFree,
    );
    return ffi.Struct.create<objc.CGRect>($finalizable);
  }

  /// auxiliaryTopRightArea
  objc.CGRect get auxiliaryTopRightArea {
    objc.checkOsVersionInternal(
      'NSScreen.auxiliaryTopRightArea',
      iOS: (true, null),
      macOS: (false, (12, 0, 0)),
    );
    final $ptr = pkg_ffi.calloc<objc.CGRect>();
    objc.useMsgSendVariants
        ? _objc_msgSend_bu1hbwStret(
            $ptr,
            object$.ref.pointer,
            _sel_auxiliaryTopRightArea,
          )
        : $ptr.ref = _objc_msgSend_bu1hbw(
            object$.ref.pointer,
            _sel_auxiliaryTopRightArea,
          );
    final $finalizable = $ptr.cast<ffi.Uint8>().asTypedList(
      ffi.sizeOf<objc.CGRect>(),
      finalizer: pkg_ffi.calloc.nativeFree,
    );
    return ffi.Struct.create<objc.CGRect>($finalizable);
  }

  /// backingAlignedRect:options:
  objc.CGRect backingAlignedRect(objc.CGRect rect, {required int options}) {
    objc.checkOsVersionInternal(
      'NSScreen.backingAlignedRect:options:',
      iOS: (true, null),
      macOS: (false, (10, 7, 0)),
    );
    final $ptr = pkg_ffi.calloc<objc.CGRect>();
    objc.useMsgSendVariants
        ? _objc_msgSend_qmdcb3Stret(
            $ptr,
            object$.ref.pointer,
            _sel_backingAlignedRect_options_,
            rect,
            options,
          )
        : $ptr.ref = _objc_msgSend_qmdcb3(
            object$.ref.pointer,
            _sel_backingAlignedRect_options_,
            rect,
            options,
          );
    final $finalizable = $ptr.cast<ffi.Uint8>().asTypedList(
      ffi.sizeOf<objc.CGRect>(),
      finalizer: pkg_ffi.calloc.nativeFree,
    );
    return ffi.Struct.create<objc.CGRect>($finalizable);
  }

  /// backingScaleFactor
  double get backingScaleFactor {
    objc.checkOsVersionInternal(
      'NSScreen.backingScaleFactor',
      iOS: (true, null),
      macOS: (false, (10, 7, 0)),
    );
    return objc.useMsgSendVariants
        ? _objc_msgSend_1ukqyt8Fpret(
            object$.ref.pointer,
            _sel_backingScaleFactor,
          )
        : _objc_msgSend_1ukqyt8(object$.ref.pointer, _sel_backingScaleFactor);
  }

  /// canRepresentDisplayGamut:
  bool canRepresentDisplayGamut(NSDisplayGamut displayGamut) {
    objc.checkOsVersionInternal(
      'NSScreen.canRepresentDisplayGamut:',
      iOS: (true, null),
      macOS: (false, (10, 12, 0)),
    );
    return _objc_msgSend_728x5i(
      object$.ref.pointer,
      _sel_canRepresentDisplayGamut_,
      displayGamut.value,
    );
  }

  /// colorSpace
  NSColorSpace? get colorSpace {
    objc.checkOsVersionInternal(
      'NSScreen.colorSpace',
      iOS: (true, null),
      macOS: (false, (10, 6, 0)),
    );
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_colorSpace);
    return $ret.address == 0
        ? null
        : NSColorSpace.fromPointer($ret, retain: true, release: true);
  }

  /// convertRectFromBacking:
  objc.CGRect convertRectFromBacking(objc.CGRect rect) {
    objc.checkOsVersionInternal(
      'NSScreen.convertRectFromBacking:',
      iOS: (true, null),
      macOS: (false, (10, 7, 0)),
    );
    final $ptr = pkg_ffi.calloc<objc.CGRect>();
    objc.useMsgSendVariants
        ? _objc_msgSend_1gn1s3dStret(
            $ptr,
            object$.ref.pointer,
            _sel_convertRectFromBacking_,
            rect,
          )
        : $ptr.ref = _objc_msgSend_1gn1s3d(
            object$.ref.pointer,
            _sel_convertRectFromBacking_,
            rect,
          );
    final $finalizable = $ptr.cast<ffi.Uint8>().asTypedList(
      ffi.sizeOf<objc.CGRect>(),
      finalizer: pkg_ffi.calloc.nativeFree,
    );
    return ffi.Struct.create<objc.CGRect>($finalizable);
  }

  /// convertRectToBacking:
  objc.CGRect convertRectToBacking(objc.CGRect rect) {
    objc.checkOsVersionInternal(
      'NSScreen.convertRectToBacking:',
      iOS: (true, null),
      macOS: (false, (10, 7, 0)),
    );
    final $ptr = pkg_ffi.calloc<objc.CGRect>();
    objc.useMsgSendVariants
        ? _objc_msgSend_1gn1s3dStret(
            $ptr,
            object$.ref.pointer,
            _sel_convertRectToBacking_,
            rect,
          )
        : $ptr.ref = _objc_msgSend_1gn1s3d(
            object$.ref.pointer,
            _sel_convertRectToBacking_,
            rect,
          );
    final $finalizable = $ptr.cast<ffi.Uint8>().asTypedList(
      ffi.sizeOf<objc.CGRect>(),
      finalizer: pkg_ffi.calloc.nativeFree,
    );
    return ffi.Struct.create<objc.CGRect>($finalizable);
  }

  /// depth
  NSWindowDepth get depth {
    objc.checkOsVersionInternal('NSScreen.depth', iOS: (true, null));
    final $ret = _objc_msgSend_8sdj0f(object$.ref.pointer, _sel_depth);
    return NSWindowDepth.fromValue($ret);
  }

  /// deviceDescription
  objc.NSDictionary get deviceDescription {
    objc.checkOsVersionInternal(
      'NSScreen.deviceDescription',
      iOS: (true, null),
    );
    final $ret = _objc_msgSend_151sglz(
      object$.ref.pointer,
      _sel_deviceDescription,
    );
    return objc.NSDictionary.fromPointer($ret, retain: true, release: true);
  }

  /// displayUpdateGranularity
  double get displayUpdateGranularity {
    objc.checkOsVersionInternal(
      'NSScreen.displayUpdateGranularity',
      iOS: (true, null),
      macOS: (false, (12, 0, 0)),
    );
    return objc.useMsgSendVariants
        ? _objc_msgSend_1ukqyt8Fpret(
            object$.ref.pointer,
            _sel_displayUpdateGranularity,
          )
        : _objc_msgSend_1ukqyt8(
            object$.ref.pointer,
            _sel_displayUpdateGranularity,
          );
  }

  /// frame
  objc.CGRect get frame {
    objc.checkOsVersionInternal('NSScreen.frame', iOS: (true, null));
    final $ptr = pkg_ffi.calloc<objc.CGRect>();
    objc.useMsgSendVariants
        ? _objc_msgSend_bu1hbwStret($ptr, object$.ref.pointer, _sel_frame)
        : $ptr.ref = _objc_msgSend_bu1hbw(object$.ref.pointer, _sel_frame);
    final $finalizable = $ptr.cast<ffi.Uint8>().asTypedList(
      ffi.sizeOf<objc.CGRect>(),
      finalizer: pkg_ffi.calloc.nativeFree,
    );
    return ffi.Struct.create<objc.CGRect>($finalizable);
  }

  /// init
  NSScreen init() {
    objc.checkOsVersionInternal(
      'NSScreen.init',
      iOS: (false, (2, 0, 0)),
      macOS: (false, (10, 0, 0)),
    );
    final $ret = _objc_msgSend_151sglz(
      object$.ref.retainAndReturnPointer(),
      _sel_init,
    );
    return NSScreen.fromPointer($ret, retain: false, release: true);
  }

  /// lastDisplayUpdateTimestamp
  double get lastDisplayUpdateTimestamp {
    objc.checkOsVersionInternal(
      'NSScreen.lastDisplayUpdateTimestamp',
      iOS: (true, null),
      macOS: (false, (12, 0, 0)),
    );
    return objc.useMsgSendVariants
        ? _objc_msgSend_1ukqyt8Fpret(
            object$.ref.pointer,
            _sel_lastDisplayUpdateTimestamp,
          )
        : _objc_msgSend_1ukqyt8(
            object$.ref.pointer,
            _sel_lastDisplayUpdateTimestamp,
          );
  }

  /// localizedName
  objc.NSString get localizedName {
    objc.checkOsVersionInternal(
      'NSScreen.localizedName',
      iOS: (true, null),
      macOS: (false, (10, 15, 0)),
    );
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_localizedName);
    return objc.NSString.fromPointer($ret, retain: true, release: true);
  }

  /// maximumExtendedDynamicRangeColorComponentValue
  double get maximumExtendedDynamicRangeColorComponentValue {
    objc.checkOsVersionInternal(
      'NSScreen.maximumExtendedDynamicRangeColorComponentValue',
      iOS: (true, null),
      macOS: (false, (10, 11, 0)),
    );
    return objc.useMsgSendVariants
        ? _objc_msgSend_1ukqyt8Fpret(
            object$.ref.pointer,
            _sel_maximumExtendedDynamicRangeColorComponentValue,
          )
        : _objc_msgSend_1ukqyt8(
            object$.ref.pointer,
            _sel_maximumExtendedDynamicRangeColorComponentValue,
          );
  }

  /// maximumFramesPerSecond
  int get maximumFramesPerSecond {
    objc.checkOsVersionInternal(
      'NSScreen.maximumFramesPerSecond',
      iOS: (true, null),
      macOS: (false, (12, 0, 0)),
    );
    return _objc_msgSend_1hz7y9r(
      object$.ref.pointer,
      _sel_maximumFramesPerSecond,
    );
  }

  /// maximumPotentialExtendedDynamicRangeColorComponentValue
  double get maximumPotentialExtendedDynamicRangeColorComponentValue {
    objc.checkOsVersionInternal(
      'NSScreen.maximumPotentialExtendedDynamicRangeColorComponentValue',
      iOS: (true, null),
      macOS: (false, (10, 15, 0)),
    );
    return objc.useMsgSendVariants
        ? _objc_msgSend_1ukqyt8Fpret(
            object$.ref.pointer,
            _sel_maximumPotentialExtendedDynamicRangeColorComponentValue,
          )
        : _objc_msgSend_1ukqyt8(
            object$.ref.pointer,
            _sel_maximumPotentialExtendedDynamicRangeColorComponentValue,
          );
  }

  /// maximumReferenceExtendedDynamicRangeColorComponentValue
  double get maximumReferenceExtendedDynamicRangeColorComponentValue {
    objc.checkOsVersionInternal(
      'NSScreen.maximumReferenceExtendedDynamicRangeColorComponentValue',
      iOS: (true, null),
      macOS: (false, (10, 15, 0)),
    );
    return objc.useMsgSendVariants
        ? _objc_msgSend_1ukqyt8Fpret(
            object$.ref.pointer,
            _sel_maximumReferenceExtendedDynamicRangeColorComponentValue,
          )
        : _objc_msgSend_1ukqyt8(
            object$.ref.pointer,
            _sel_maximumReferenceExtendedDynamicRangeColorComponentValue,
          );
  }

  /// maximumRefreshInterval
  double get maximumRefreshInterval {
    objc.checkOsVersionInternal(
      'NSScreen.maximumRefreshInterval',
      iOS: (true, null),
      macOS: (false, (12, 0, 0)),
    );
    return objc.useMsgSendVariants
        ? _objc_msgSend_1ukqyt8Fpret(
            object$.ref.pointer,
            _sel_maximumRefreshInterval,
          )
        : _objc_msgSend_1ukqyt8(
            object$.ref.pointer,
            _sel_maximumRefreshInterval,
          );
  }

  /// minimumRefreshInterval
  double get minimumRefreshInterval {
    objc.checkOsVersionInternal(
      'NSScreen.minimumRefreshInterval',
      iOS: (true, null),
      macOS: (false, (12, 0, 0)),
    );
    return objc.useMsgSendVariants
        ? _objc_msgSend_1ukqyt8Fpret(
            object$.ref.pointer,
            _sel_minimumRefreshInterval,
          )
        : _objc_msgSend_1ukqyt8(
            object$.ref.pointer,
            _sel_minimumRefreshInterval,
          );
  }

  /// safeAreaInsets
  objc.NSEdgeInsets get safeAreaInsets {
    objc.checkOsVersionInternal(
      'NSScreen.safeAreaInsets',
      iOS: (true, null),
      macOS: (false, (12, 0, 0)),
    );
    final $ptr = pkg_ffi.calloc<objc.NSEdgeInsets>();
    objc.useMsgSendVariants
        ? _objc_msgSend_sl0cgwStret(
            $ptr,
            object$.ref.pointer,
            _sel_safeAreaInsets,
          )
        : $ptr.ref = _objc_msgSend_sl0cgw(
            object$.ref.pointer,
            _sel_safeAreaInsets,
          );
    final $finalizable = $ptr.cast<ffi.Uint8>().asTypedList(
      ffi.sizeOf<objc.NSEdgeInsets>(),
      finalizer: pkg_ffi.calloc.nativeFree,
    );
    return ffi.Struct.create<objc.NSEdgeInsets>($finalizable);
  }

  /// supportedWindowDepths
  ffi.Pointer<ffi.Int32> get supportedWindowDepths {
    objc.checkOsVersionInternal(
      'NSScreen.supportedWindowDepths',
      iOS: (true, null),
    );
    return _objc_msgSend_1nb3zed(
      object$.ref.pointer,
      _sel_supportedWindowDepths,
    );
  }

  /// visibleFrame
  objc.CGRect get visibleFrame {
    objc.checkOsVersionInternal('NSScreen.visibleFrame', iOS: (true, null));
    final $ptr = pkg_ffi.calloc<objc.CGRect>();
    objc.useMsgSendVariants
        ? _objc_msgSend_bu1hbwStret(
            $ptr,
            object$.ref.pointer,
            _sel_visibleFrame,
          )
        : $ptr.ref = _objc_msgSend_bu1hbw(
            object$.ref.pointer,
            _sel_visibleFrame,
          );
    final $finalizable = $ptr.cast<ffi.Uint8>().asTypedList(
      ffi.sizeOf<objc.CGRect>(),
      finalizer: pkg_ffi.calloc.nativeFree,
    );
    return ffi.Struct.create<objc.CGRect>($finalizable);
  }
}

enum SCShareableContentStyle {
  SCShareableContentStyleNone(0),
  SCShareableContentStyleWindow(1),
  SCShareableContentStyleDisplay(2),
  SCShareableContentStyleApplication(3);

  final int value;
  const SCShareableContentStyle(this.value);

  static SCShareableContentStyle fromValue(int value) => switch (value) {
    0 => SCShareableContentStyleNone,
    1 => SCShareableContentStyleWindow,
    2 => SCShareableContentStyleDisplay,
    3 => SCShareableContentStyleApplication,
    _ => throw ArgumentError(
      'Unknown value for SCShareableContentStyle: $value',
    ),
  };
}

/// WARNING: SCWindow is a stub. To generate bindings for this class, include
/// SCWindow in your config's objc-interfaces list.
///
/// SCWindow
extension type SCWindow._(objc.ObjCObject object$)
    implements objc.ObjCObject, objc.NSObject {
  /// Constructs a [SCWindow] that points to the same underlying object as [other].
  SCWindow.as(objc.ObjCObject other) : object$ = other {
    objc.checkOsVersionInternal('SCWindow', macOS: (false, (12, 3, 0)));
  }

  /// Constructs a [SCWindow] that wraps the given raw object pointer.
  SCWindow.fromPointer(
    ffi.Pointer<objc.ObjCObjectImpl> other, {
    bool retain = false,
    bool release = false,
  }) : object$ = objc.ObjCObject(other, retain: retain, release: release) {
    objc.checkOsVersionInternal('SCWindow', macOS: (false, (12, 3, 0)));
  }
}

late final _class_SCDisplay = objc.getClass("SCDisplay");
late final _sel_displayID = objc.registerName("displayID");
late final _sel_width = objc.registerName("width");
late final _sel_height = objc.registerName("height");

/// SCDisplay
extension type SCDisplay._(objc.ObjCObject object$)
    implements objc.ObjCObject, objc.NSObject {
  /// Constructs a [SCDisplay] that points to the same underlying object as [other].
  SCDisplay.as(objc.ObjCObject other) : object$ = other {
    objc.checkOsVersionInternal('SCDisplay', macOS: (false, (12, 3, 0)));
    assert(isA(object$));
  }

  /// Constructs a [SCDisplay] that wraps the given raw object pointer.
  SCDisplay.fromPointer(
    ffi.Pointer<objc.ObjCObjectImpl> other, {
    bool retain = false,
    bool release = false,
  }) : object$ = objc.ObjCObject(other, retain: retain, release: release) {
    objc.checkOsVersionInternal('SCDisplay', macOS: (false, (12, 3, 0)));
    assert(isA(object$));
  }

  /// Returns whether [obj] is an instance of [SCDisplay].
  static bool isA(objc.ObjCObject obj) => _objc_msgSend_19nvye5(
    obj.ref.pointer,
    _sel_isKindOfClass_,
    _class_SCDisplay,
  );

  /// alloc
  static SCDisplay alloc() {
    final $ret = _objc_msgSend_151sglz(_class_SCDisplay, _sel_alloc);
    return SCDisplay.fromPointer($ret, retain: false, release: true);
  }

  /// allocWithZone:
  static SCDisplay allocWithZone(ffi.Pointer<objc.NSZone> zone) {
    final $ret = _objc_msgSend_1cwp428(
      _class_SCDisplay,
      _sel_allocWithZone_,
      zone,
    );
    return SCDisplay.fromPointer($ret, retain: false, release: true);
  }

  /// new
  static SCDisplay new$() {
    final $ret = _objc_msgSend_151sglz(_class_SCDisplay, _sel_new);
    return SCDisplay.fromPointer($ret, retain: false, release: true);
  }

  /// Returns a new instance of SCDisplay constructed with the default `new` method.
  SCDisplay() : this.as(new$().object$);
}

extension SCDisplay$Methods on SCDisplay {
  /// displayID
  int get displayID {
    objc.checkOsVersionInternal(
      'SCDisplay.displayID',
      macOS: (false, (12, 3, 0)),
    );
    return _objc_msgSend_usggvf(object$.ref.pointer, _sel_displayID);
  }

  /// frame
  objc.CGRect get frame {
    objc.checkOsVersionInternal('SCDisplay.frame', macOS: (false, (12, 3, 0)));
    final $ptr = pkg_ffi.calloc<objc.CGRect>();
    objc.useMsgSendVariants
        ? _objc_msgSend_bu1hbwStret($ptr, object$.ref.pointer, _sel_frame)
        : $ptr.ref = _objc_msgSend_bu1hbw(object$.ref.pointer, _sel_frame);
    final $finalizable = $ptr.cast<ffi.Uint8>().asTypedList(
      ffi.sizeOf<objc.CGRect>(),
      finalizer: pkg_ffi.calloc.nativeFree,
    );
    return ffi.Struct.create<objc.CGRect>($finalizable);
  }

  /// height
  int get height {
    objc.checkOsVersionInternal('SCDisplay.height', macOS: (false, (12, 3, 0)));
    return _objc_msgSend_1hz7y9r(object$.ref.pointer, _sel_height);
  }

  /// init
  SCDisplay init() {
    objc.checkOsVersionInternal(
      'SCDisplay.init',
      iOS: (false, (2, 0, 0)),
      macOS: (false, (10, 0, 0)),
    );
    final $ret = _objc_msgSend_151sglz(
      object$.ref.retainAndReturnPointer(),
      _sel_init,
    );
    return SCDisplay.fromPointer($ret, retain: false, release: true);
  }

  /// width
  int get width {
    objc.checkOsVersionInternal('SCDisplay.width', macOS: (false, (12, 3, 0)));
    return _objc_msgSend_1hz7y9r(object$.ref.pointer, _sel_width);
  }
}

/// WARNING: SCShareableContentInfo is a stub. To generate bindings for this class, include
/// SCShareableContentInfo in your config's objc-interfaces list.
///
/// SCShareableContentInfo
extension type SCShareableContentInfo._(objc.ObjCObject object$)
    implements objc.ObjCObject, objc.NSObject {
  /// Constructs a [SCShareableContentInfo] that points to the same underlying object as [other].
  SCShareableContentInfo.as(objc.ObjCObject other) : object$ = other {
    objc.checkOsVersionInternal(
      'SCShareableContentInfo',
      macOS: (false, (14, 0, 0)),
    );
  }

  /// Constructs a [SCShareableContentInfo] that wraps the given raw object pointer.
  SCShareableContentInfo.fromPointer(
    ffi.Pointer<objc.ObjCObjectImpl> other, {
    bool retain = false,
    bool release = false,
  }) : object$ = objc.ObjCObject(other, retain: retain, release: release) {
    objc.checkOsVersionInternal(
      'SCShareableContentInfo',
      macOS: (false, (14, 0, 0)),
    );
  }
}

late final _class_SCShareableContent = objc.getClass("SCShareableContent");

/// Construction methods for `objc.ObjCBlock<ffi.Void Function(SCShareableContent?, objc.NSError?)>`.
abstract final class ObjCBlock_ffiVoid_SCShareableContent_NSError {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<ffi.Void Function(SCShareableContent?, objc.NSError?)>
  fromPointer(
    ffi.Pointer<objc.ObjCBlockImpl> pointer, {
    bool retain = false,
    bool release = false,
  }) => objc.ObjCBlock<ffi.Void Function(SCShareableContent?, objc.NSError?)>(
    pointer,
    retain: retain,
    release: release,
  );

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<ffi.Void Function(SCShareableContent?, objc.NSError?)>
  fromFunctionPointer(
    ffi.Pointer<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<objc.ObjCObjectImpl> arg0,
          ffi.Pointer<objc.ObjCObjectImpl> arg1,
        )
      >
    >
    ptr,
  ) => objc.ObjCBlock<ffi.Void Function(SCShareableContent?, objc.NSError?)>(
    objc.newPointerBlock(_fnPtrCallable, ptr.cast()),
    retain: false,
    release: true,
  );

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Void Function(SCShareableContent?, objc.NSError?)>
  fromFunction(
    void Function(SCShareableContent?, objc.NSError?) fn, {
    bool keepIsolateAlive = true,
  }) => objc.ObjCBlock<ffi.Void Function(SCShareableContent?, objc.NSError?)>(
    objc.newClosureBlock(
      _closureCallable,
      (
        ffi.Pointer<objc.ObjCObjectImpl> arg0,
        ffi.Pointer<objc.ObjCObjectImpl> arg1,
      ) => fn(
        arg0.address == 0
            ? null
            : SCShareableContent.fromPointer(arg0, retain: true, release: true),
        arg1.address == 0
            ? null
            : objc.NSError.fromPointer(arg1, retain: true, release: true),
      ),
      keepIsolateAlive,
    ),
    retain: false,
    release: true,
  );

  /// Creates a listener block from a Dart function.
  ///
  /// This is based on FFI's NativeCallable.listener, and has the same
  /// capabilities and limitations. This block can be invoked from any thread,
  /// but only supports void functions, and is not run synchronously. See
  /// NativeCallable.listener for more details.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Void Function(SCShareableContent?, objc.NSError?)>
  listener(
    void Function(SCShareableContent?, objc.NSError?) fn, {
    bool keepIsolateAlive = true,
  }) {
    final raw = objc.newClosureBlock(
      _listenerCallable.nativeFunction.cast(),
      (
        ffi.Pointer<objc.ObjCObjectImpl> arg0,
        ffi.Pointer<objc.ObjCObjectImpl> arg1,
      ) => fn(
        arg0.address == 0
            ? null
            : SCShareableContent.fromPointer(
                arg0,
                retain: false,
                release: true,
              ),
        arg1.address == 0
            ? null
            : objc.NSError.fromPointer(arg1, retain: false, release: true),
      ),
      keepIsolateAlive,
    );
    final wrapper = _NativeLibrary_wrapListenerBlock_pfv6jd(raw);
    objc.objectRelease(raw.cast());
    return objc.ObjCBlock<
      ffi.Void Function(SCShareableContent?, objc.NSError?)
    >(wrapper, retain: false, release: true);
  }

  /// Creates a blocking block from a Dart function.
  ///
  /// This callback can be invoked from any native thread, and will block the
  /// caller until the callback is handled by the Dart isolate that created
  /// the block. Async functions are not supported.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC. If the owner isolate
  /// has shut down, and the block is invoked by native code, it may block
  /// indefinitely, or have other undefined behavior.
  static objc.ObjCBlock<ffi.Void Function(SCShareableContent?, objc.NSError?)>
  blocking(
    void Function(SCShareableContent?, objc.NSError?) fn, {
    bool keepIsolateAlive = true,
  }) {
    final raw = objc.newClosureBlock(
      _blockingCallable.nativeFunction.cast(),
      (
        ffi.Pointer<objc.ObjCObjectImpl> arg0,
        ffi.Pointer<objc.ObjCObjectImpl> arg1,
      ) => fn(
        arg0.address == 0
            ? null
            : SCShareableContent.fromPointer(
                arg0,
                retain: false,
                release: true,
              ),
        arg1.address == 0
            ? null
            : objc.NSError.fromPointer(arg1, retain: false, release: true),
      ),
      keepIsolateAlive,
    );
    final rawListener = objc.newClosureBlock(
      _blockingListenerCallable.nativeFunction.cast(),
      (
        ffi.Pointer<objc.ObjCObjectImpl> arg0,
        ffi.Pointer<objc.ObjCObjectImpl> arg1,
      ) => fn(
        arg0.address == 0
            ? null
            : SCShareableContent.fromPointer(
                arg0,
                retain: false,
                release: true,
              ),
        arg1.address == 0
            ? null
            : objc.NSError.fromPointer(arg1, retain: false, release: true),
      ),
      keepIsolateAlive,
    );
    final wrapper = _NativeLibrary_wrapBlockingBlock_pfv6jd(
      raw,
      rawListener,
      objc.objCContext,
    );
    objc.objectRelease(raw.cast());
    objc.objectRelease(rawListener.cast());
    return objc.ObjCBlock<
      ffi.Void Function(SCShareableContent?, objc.NSError?)
    >(wrapper, retain: false, release: true);
  }

  static void _listenerTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<objc.ObjCObjectImpl> arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
  ) {
    (objc.getBlockClosure(block)
        as void Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCObjectImpl>,
        ))(arg0, arg1);
    objc.objectRelease(block.cast());
  }

  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<objc.ObjCObjectImpl>,
      ffi.Pointer<objc.ObjCObjectImpl>,
    )
  >
  _listenerCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          )
        >.listener(_listenerTrampoline)
        ..keepIsolateAlive = false;
  static void _blockingTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> waiter,
    ffi.Pointer<objc.ObjCObjectImpl> arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
  ) {
    try {
      (objc.getBlockClosure(block)
          as void Function(
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          ))(arg0, arg1);
    } catch (e) {
    } finally {
      objc.signalWaiter(waiter);
      objc.objectRelease(block.cast());
    }
  }

  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<objc.ObjCObjectImpl>,
      ffi.Pointer<objc.ObjCObjectImpl>,
    )
  >
  _blockingCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          )
        >.isolateLocal(_blockingTrampoline)
        ..keepIsolateAlive = false;
  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<objc.ObjCObjectImpl>,
      ffi.Pointer<objc.ObjCObjectImpl>,
    )
  >
  _blockingListenerCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          )
        >.listener(_blockingTrampoline)
        ..keepIsolateAlive = false;
  static void _fnPtrTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<objc.ObjCObjectImpl> arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
  ) => block.ref.target
      .cast<
        ffi.NativeFunction<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCObjectImpl> arg0,
            ffi.Pointer<objc.ObjCObjectImpl> arg1,
          )
        >
      >()
      .asFunction<
        void Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCObjectImpl>,
        )
      >()(arg0, arg1);
  static ffi.Pointer<ffi.Void> _fnPtrCallable =
      ffi.Pointer.fromFunction<
            ffi.Void Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<objc.ObjCObjectImpl>,
              ffi.Pointer<objc.ObjCObjectImpl>,
            )
          >(_fnPtrTrampoline)
          .cast();
  static void _closureTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<objc.ObjCObjectImpl> arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
  ) =>
      (objc.getBlockClosure(block)
          as void Function(
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          ))(arg0, arg1);
  static ffi.Pointer<ffi.Void> _closureCallable =
      ffi.Pointer.fromFunction<
            ffi.Void Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<objc.ObjCObjectImpl>,
              ffi.Pointer<objc.ObjCObjectImpl>,
            )
          >(_closureTrampoline)
          .cast();
}

/// Call operator for `objc.ObjCBlock<ffi.Void Function(SCShareableContent?, objc.NSError?)>`.
extension ObjCBlock_ffiVoid_SCShareableContent_NSError$CallExtension
    on objc.ObjCBlock<ffi.Void Function(SCShareableContent?, objc.NSError?)> {
  void call(SCShareableContent? arg0, objc.NSError? arg1) =>
      ref.pointer.ref.invoke
          .cast<
            ffi.NativeFunction<
              ffi.Void Function(
                ffi.Pointer<objc.ObjCBlockImpl> block,
                ffi.Pointer<objc.ObjCObjectImpl> arg0,
                ffi.Pointer<objc.ObjCObjectImpl> arg1,
              )
            >
          >()
          .asFunction<
            void Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<objc.ObjCObjectImpl>,
              ffi.Pointer<objc.ObjCObjectImpl>,
            )
          >()(
        ref.pointer,
        arg0?.ref.pointer ?? ffi.nullptr,
        arg1?.ref.pointer ?? ffi.nullptr,
      );
}

late final _sel_getShareableContentWithCompletionHandler_ = objc.registerName(
  "getShareableContentWithCompletionHandler:",
);
final _objc_msgSend_f167m6 = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Pointer<objc.ObjCBlockImpl>,
        )
      >
    >()
    .asFunction<
      void Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
        ffi.Pointer<objc.ObjCBlockImpl>,
      )
    >();
late final _sel_getCurrentProcessShareableContentWithCompletionHandler_ = objc
    .registerName("getCurrentProcessShareableContentWithCompletionHandler:");
late final _sel_getShareableContentExcludingDesktopWindows_onScreenWindowsOnly_completionHandler_ =
    objc.registerName(
      "getShareableContentExcludingDesktopWindows:onScreenWindowsOnly:completionHandler:",
    );
final _objc_msgSend_1dik3tq = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Bool,
          ffi.Bool,
          ffi.Pointer<objc.ObjCBlockImpl>,
        )
      >
    >()
    .asFunction<
      void Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
        bool,
        bool,
        ffi.Pointer<objc.ObjCBlockImpl>,
      )
    >();
late final _sel_getShareableContentExcludingDesktopWindows_onScreenWindowsOnlyBelowWindow_completionHandler_ =
    objc.registerName(
      "getShareableContentExcludingDesktopWindows:onScreenWindowsOnlyBelowWindow:completionHandler:",
    );
final _objc_msgSend_1oby3xk = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Bool,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCBlockImpl>,
        )
      >
    >()
    .asFunction<
      void Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
        bool,
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCBlockImpl>,
      )
    >();
late final _sel_getShareableContentExcludingDesktopWindows_onScreenWindowsOnlyAboveWindow_completionHandler_ =
    objc.registerName(
      "getShareableContentExcludingDesktopWindows:onScreenWindowsOnlyAboveWindow:completionHandler:",
    );
late final _class_SCContentFilter = objc.getClass("SCContentFilter");

enum SCStreamType {
  SCStreamTypeWindow(0),
  SCStreamTypeDisplay(1);

  final int value;
  const SCStreamType(this.value);

  static SCStreamType fromValue(int value) => switch (value) {
    0 => SCStreamTypeWindow,
    1 => SCStreamTypeDisplay,
    _ => throw ArgumentError('Unknown value for SCStreamType: $value'),
  };
}

late final _sel_streamType = objc.registerName("streamType");
final _objc_msgSend_iwlyr3 = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Long Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
        )
      >
    >()
    .asFunction<
      int Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
      )
    >();
late final _sel_style = objc.registerName("style");
final _objc_msgSend_1h6ewvo = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Long Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
        )
      >
    >()
    .asFunction<
      int Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
      )
    >();
late final _sel_pointPixelScale = objc.registerName("pointPixelScale");
final _objc_msgSend_2cgrxl = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Float Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
        )
      >
    >()
    .asFunction<
      double Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
      )
    >();
final _objc_msgSend_2cgrxlFpret = objc.msgSendFpretPointer
    .cast<
      ffi.NativeFunction<
        ffi.Float Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
        )
      >
    >()
    .asFunction<
      double Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
      )
    >();
late final _sel_contentRect = objc.registerName("contentRect");
late final _sel_includeMenuBar = objc.registerName("includeMenuBar");
late final _sel_setIncludeMenuBar_ = objc.registerName("setIncludeMenuBar:");
final _objc_msgSend_1s56lr9 = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Bool,
        )
      >
    >()
    .asFunction<
      void Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
        bool,
      )
    >();
late final _sel_includedDisplays = objc.registerName("includedDisplays");
late final _sel_includedApplications = objc.registerName(
  "includedApplications",
);
late final _sel_includedWindows = objc.registerName("includedWindows");
late final _sel_initWithDesktopIndependentWindow_ = objc.registerName(
  "initWithDesktopIndependentWindow:",
);
final _objc_msgSend_1sotr3r = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Pointer<objc.ObjCObjectImpl> Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Pointer<objc.ObjCObjectImpl>,
        )
      >
    >()
    .asFunction<
      ffi.Pointer<objc.ObjCObjectImpl> Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
        ffi.Pointer<objc.ObjCObjectImpl>,
      )
    >();
late final _sel_initWithDisplay_excludingWindows_ = objc.registerName(
  "initWithDisplay:excludingWindows:",
);
final _objc_msgSend_15qeuct = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Pointer<objc.ObjCObjectImpl> Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCObjectImpl>,
        )
      >
    >()
    .asFunction<
      ffi.Pointer<objc.ObjCObjectImpl> Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCObjectImpl>,
      )
    >();
late final _sel_initWithDisplay_includingWindows_ = objc.registerName(
  "initWithDisplay:includingWindows:",
);
late final _sel_initWithDisplay_includingApplications_exceptingWindows_ = objc
    .registerName("initWithDisplay:includingApplications:exceptingWindows:");
final _objc_msgSend_11spmsz = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Pointer<objc.ObjCObjectImpl> Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCObjectImpl>,
        )
      >
    >()
    .asFunction<
      ffi.Pointer<objc.ObjCObjectImpl> Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCObjectImpl>,
      )
    >();
late final _sel_initWithDisplay_excludingApplications_exceptingWindows_ = objc
    .registerName("initWithDisplay:excludingApplications:exceptingWindows:");

/// SCContentFilter
extension type SCContentFilter._(objc.ObjCObject object$)
    implements objc.ObjCObject, objc.NSObject {
  /// Constructs a [SCContentFilter] that points to the same underlying object as [other].
  SCContentFilter.as(objc.ObjCObject other) : object$ = other {
    objc.checkOsVersionInternal('SCContentFilter', macOS: (false, (12, 3, 0)));
    assert(isA(object$));
  }

  /// Constructs a [SCContentFilter] that wraps the given raw object pointer.
  SCContentFilter.fromPointer(
    ffi.Pointer<objc.ObjCObjectImpl> other, {
    bool retain = false,
    bool release = false,
  }) : object$ = objc.ObjCObject(other, retain: retain, release: release) {
    objc.checkOsVersionInternal('SCContentFilter', macOS: (false, (12, 3, 0)));
    assert(isA(object$));
  }

  /// Returns whether [obj] is an instance of [SCContentFilter].
  static bool isA(objc.ObjCObject obj) => _objc_msgSend_19nvye5(
    obj.ref.pointer,
    _sel_isKindOfClass_,
    _class_SCContentFilter,
  );

  /// alloc
  static SCContentFilter alloc() {
    final $ret = _objc_msgSend_151sglz(_class_SCContentFilter, _sel_alloc);
    return SCContentFilter.fromPointer($ret, retain: false, release: true);
  }

  /// allocWithZone:
  static SCContentFilter allocWithZone(ffi.Pointer<objc.NSZone> zone) {
    final $ret = _objc_msgSend_1cwp428(
      _class_SCContentFilter,
      _sel_allocWithZone_,
      zone,
    );
    return SCContentFilter.fromPointer($ret, retain: false, release: true);
  }

  /// new
  static SCContentFilter new$() {
    final $ret = _objc_msgSend_151sglz(_class_SCContentFilter, _sel_new);
    return SCContentFilter.fromPointer($ret, retain: false, release: true);
  }

  /// Returns a new instance of SCContentFilter constructed with the default `new` method.
  SCContentFilter() : this.as(new$().object$);
}

extension SCContentFilter$Methods on SCContentFilter {
  /// contentRect
  objc.CGRect get contentRect {
    objc.checkOsVersionInternal(
      'SCContentFilter.contentRect',
      macOS: (false, (14, 0, 0)),
    );
    final $ptr = pkg_ffi.calloc<objc.CGRect>();
    objc.useMsgSendVariants
        ? _objc_msgSend_bu1hbwStret($ptr, object$.ref.pointer, _sel_contentRect)
        : $ptr.ref = _objc_msgSend_bu1hbw(
            object$.ref.pointer,
            _sel_contentRect,
          );
    final $finalizable = $ptr.cast<ffi.Uint8>().asTypedList(
      ffi.sizeOf<objc.CGRect>(),
      finalizer: pkg_ffi.calloc.nativeFree,
    );
    return ffi.Struct.create<objc.CGRect>($finalizable);
  }

  /// includeMenuBar
  bool get includeMenuBar {
    objc.checkOsVersionInternal(
      'SCContentFilter.includeMenuBar',
      macOS: (false, (14, 2, 0)),
    );
    return _objc_msgSend_91o635(object$.ref.pointer, _sel_includeMenuBar);
  }

  /// includedApplications
  objc.NSArray get includedApplications {
    objc.checkOsVersionInternal(
      'SCContentFilter.includedApplications',
      macOS: (false, (15, 2, 0)),
    );
    final $ret = _objc_msgSend_151sglz(
      object$.ref.pointer,
      _sel_includedApplications,
    );
    return objc.NSArray.fromPointer($ret, retain: true, release: true);
  }

  /// includedDisplays
  objc.NSArray get includedDisplays {
    objc.checkOsVersionInternal(
      'SCContentFilter.includedDisplays',
      macOS: (false, (15, 2, 0)),
    );
    final $ret = _objc_msgSend_151sglz(
      object$.ref.pointer,
      _sel_includedDisplays,
    );
    return objc.NSArray.fromPointer($ret, retain: true, release: true);
  }

  /// includedWindows
  objc.NSArray get includedWindows {
    objc.checkOsVersionInternal(
      'SCContentFilter.includedWindows',
      macOS: (false, (15, 2, 0)),
    );
    final $ret = _objc_msgSend_151sglz(
      object$.ref.pointer,
      _sel_includedWindows,
    );
    return objc.NSArray.fromPointer($ret, retain: true, release: true);
  }

  /// init
  SCContentFilter init() {
    objc.checkOsVersionInternal(
      'SCContentFilter.init',
      iOS: (false, (2, 0, 0)),
      macOS: (false, (10, 0, 0)),
    );
    final $ret = _objc_msgSend_151sglz(
      object$.ref.retainAndReturnPointer(),
      _sel_init,
    );
    return SCContentFilter.fromPointer($ret, retain: false, release: true);
  }

  /// initWithDesktopIndependentWindow:
  SCContentFilter initWithDesktopIndependentWindow(SCWindow window) {
    objc.checkOsVersionInternal(
      'SCContentFilter.initWithDesktopIndependentWindow:',
      macOS: (false, (12, 3, 0)),
    );
    final $ret = _objc_msgSend_1sotr3r(
      object$.ref.retainAndReturnPointer(),
      _sel_initWithDesktopIndependentWindow_,
      window.ref.pointer,
    );
    return SCContentFilter.fromPointer($ret, retain: false, release: true);
  }

  /// initWithDisplay:excludingApplications:exceptingWindows:
  SCContentFilter initWithDisplay(
    SCDisplay display, {
    required objc.NSArray excludingApplications,
    required objc.NSArray exceptingWindows,
  }) {
    objc.checkOsVersionInternal(
      'SCContentFilter.initWithDisplay:excludingApplications:exceptingWindows:',
      macOS: (false, (12, 3, 0)),
    );
    final $ret = _objc_msgSend_11spmsz(
      object$.ref.retainAndReturnPointer(),
      _sel_initWithDisplay_excludingApplications_exceptingWindows_,
      display.ref.pointer,
      excludingApplications.ref.pointer,
      exceptingWindows.ref.pointer,
    );
    return SCContentFilter.fromPointer($ret, retain: false, release: true);
  }

  /// initWithDisplay:excludingWindows:
  SCContentFilter initWithDisplay$1(
    SCDisplay display, {
    required objc.NSArray excludingWindows,
  }) {
    objc.checkOsVersionInternal(
      'SCContentFilter.initWithDisplay:excludingWindows:',
      macOS: (false, (12, 3, 0)),
    );
    final $ret = _objc_msgSend_15qeuct(
      object$.ref.retainAndReturnPointer(),
      _sel_initWithDisplay_excludingWindows_,
      display.ref.pointer,
      excludingWindows.ref.pointer,
    );
    return SCContentFilter.fromPointer($ret, retain: false, release: true);
  }

  /// initWithDisplay:includingApplications:exceptingWindows:
  SCContentFilter initWithDisplay$2(
    SCDisplay display, {
    required objc.NSArray includingApplications,
    required objc.NSArray exceptingWindows,
  }) {
    objc.checkOsVersionInternal(
      'SCContentFilter.initWithDisplay:includingApplications:exceptingWindows:',
      macOS: (false, (12, 3, 0)),
    );
    final $ret = _objc_msgSend_11spmsz(
      object$.ref.retainAndReturnPointer(),
      _sel_initWithDisplay_includingApplications_exceptingWindows_,
      display.ref.pointer,
      includingApplications.ref.pointer,
      exceptingWindows.ref.pointer,
    );
    return SCContentFilter.fromPointer($ret, retain: false, release: true);
  }

  /// initWithDisplay:includingWindows:
  SCContentFilter initWithDisplay$3(
    SCDisplay display, {
    required objc.NSArray includingWindows,
  }) {
    objc.checkOsVersionInternal(
      'SCContentFilter.initWithDisplay:includingWindows:',
      macOS: (false, (12, 3, 0)),
    );
    final $ret = _objc_msgSend_15qeuct(
      object$.ref.retainAndReturnPointer(),
      _sel_initWithDisplay_includingWindows_,
      display.ref.pointer,
      includingWindows.ref.pointer,
    );
    return SCContentFilter.fromPointer($ret, retain: false, release: true);
  }

  /// pointPixelScale
  double get pointPixelScale {
    objc.checkOsVersionInternal(
      'SCContentFilter.pointPixelScale',
      macOS: (false, (14, 0, 0)),
    );
    return objc.useMsgSendVariants
        ? _objc_msgSend_2cgrxlFpret(object$.ref.pointer, _sel_pointPixelScale)
        : _objc_msgSend_2cgrxl(object$.ref.pointer, _sel_pointPixelScale);
  }

  /// setIncludeMenuBar:
  set includeMenuBar(bool value) {
    objc.checkOsVersionInternal(
      'SCContentFilter.setIncludeMenuBar:',
      macOS: (false, (14, 2, 0)),
    );
    _objc_msgSend_1s56lr9(object$.ref.pointer, _sel_setIncludeMenuBar_, value);
  }

  /// streamType
  SCStreamType get streamType {
    objc.checkOsVersionInternal(
      'SCContentFilter.streamType',
      macOS: (false, (14, 0, 0)),
    );
    final $ret = _objc_msgSend_iwlyr3(object$.ref.pointer, _sel_streamType);
    return SCStreamType.fromValue($ret);
  }

  /// style
  SCShareableContentStyle get style {
    objc.checkOsVersionInternal(
      'SCContentFilter.style',
      macOS: (false, (14, 0, 0)),
    );
    final $ret = _objc_msgSend_1h6ewvo(object$.ref.pointer, _sel_style);
    return SCShareableContentStyle.fromValue($ret);
  }
}

late final _sel_infoForFilter_ = objc.registerName("infoForFilter:");
late final _sel_windows = objc.registerName("windows");
late final _sel_displays = objc.registerName("displays");
late final _sel_applications = objc.registerName("applications");

/// SCShareableContent
extension type SCShareableContent._(objc.ObjCObject object$)
    implements objc.ObjCObject, objc.NSObject {
  /// Constructs a [SCShareableContent] that points to the same underlying object as [other].
  SCShareableContent.as(objc.ObjCObject other) : object$ = other {
    objc.checkOsVersionInternal(
      'SCShareableContent',
      macOS: (false, (12, 3, 0)),
    );
    assert(isA(object$));
  }

  /// Constructs a [SCShareableContent] that wraps the given raw object pointer.
  SCShareableContent.fromPointer(
    ffi.Pointer<objc.ObjCObjectImpl> other, {
    bool retain = false,
    bool release = false,
  }) : object$ = objc.ObjCObject(other, retain: retain, release: release) {
    objc.checkOsVersionInternal(
      'SCShareableContent',
      macOS: (false, (12, 3, 0)),
    );
    assert(isA(object$));
  }

  /// Returns whether [obj] is an instance of [SCShareableContent].
  static bool isA(objc.ObjCObject obj) => _objc_msgSend_19nvye5(
    obj.ref.pointer,
    _sel_isKindOfClass_,
    _class_SCShareableContent,
  );

  /// alloc
  static SCShareableContent alloc() {
    final $ret = _objc_msgSend_151sglz(_class_SCShareableContent, _sel_alloc);
    return SCShareableContent.fromPointer($ret, retain: false, release: true);
  }

  /// allocWithZone:
  static SCShareableContent allocWithZone(ffi.Pointer<objc.NSZone> zone) {
    final $ret = _objc_msgSend_1cwp428(
      _class_SCShareableContent,
      _sel_allocWithZone_,
      zone,
    );
    return SCShareableContent.fromPointer($ret, retain: false, release: true);
  }

  /// getCurrentProcessShareableContentWithCompletionHandler:
  static void getCurrentProcessShareableContentWithCompletionHandler(
    objc.ObjCBlock<ffi.Void Function(SCShareableContent?, objc.NSError?)>
    completionHandler,
  ) {
    objc.checkOsVersionInternal(
      'SCShareableContent.getCurrentProcessShareableContentWithCompletionHandler:',
      macOS: (false, (14, 4, 0)),
    );
    _objc_msgSend_f167m6(
      _class_SCShareableContent,
      _sel_getCurrentProcessShareableContentWithCompletionHandler_,
      completionHandler.ref.pointer,
    );
  }

  /// getShareableContentExcludingDesktopWindows:onScreenWindowsOnly:completionHandler:
  static void getShareableContentExcludingDesktopWindows(
    bool excludeDesktopWindows, {
    required bool onScreenWindowsOnly,
    required objc.ObjCBlock<
      ffi.Void Function(SCShareableContent?, objc.NSError?)
    >
    completionHandler,
  }) {
    objc.checkOsVersionInternal(
      'SCShareableContent.getShareableContentExcludingDesktopWindows:onScreenWindowsOnly:completionHandler:',
      macOS: (false, (12, 3, 0)),
    );
    _objc_msgSend_1dik3tq(
      _class_SCShareableContent,
      _sel_getShareableContentExcludingDesktopWindows_onScreenWindowsOnly_completionHandler_,
      excludeDesktopWindows,
      onScreenWindowsOnly,
      completionHandler.ref.pointer,
    );
  }

  /// getShareableContentExcludingDesktopWindows:onScreenWindowsOnlyAboveWindow:completionHandler:
  static void getShareableContentExcludingDesktopWindows$1(
    bool excludeDesktopWindows, {
    required SCWindow onScreenWindowsOnlyAboveWindow,
    required objc.ObjCBlock<
      ffi.Void Function(SCShareableContent?, objc.NSError?)
    >
    completionHandler,
  }) {
    objc.checkOsVersionInternal(
      'SCShareableContent.getShareableContentExcludingDesktopWindows:onScreenWindowsOnlyAboveWindow:completionHandler:',
      macOS: (false, (12, 3, 0)),
    );
    _objc_msgSend_1oby3xk(
      _class_SCShareableContent,
      _sel_getShareableContentExcludingDesktopWindows_onScreenWindowsOnlyAboveWindow_completionHandler_,
      excludeDesktopWindows,
      onScreenWindowsOnlyAboveWindow.ref.pointer,
      completionHandler.ref.pointer,
    );
  }

  /// getShareableContentExcludingDesktopWindows:onScreenWindowsOnlyBelowWindow:completionHandler:
  static void getShareableContentExcludingDesktopWindows$2(
    bool excludeDesktopWindows, {
    required SCWindow onScreenWindowsOnlyBelowWindow,
    required objc.ObjCBlock<
      ffi.Void Function(SCShareableContent?, objc.NSError?)
    >
    completionHandler,
  }) {
    objc.checkOsVersionInternal(
      'SCShareableContent.getShareableContentExcludingDesktopWindows:onScreenWindowsOnlyBelowWindow:completionHandler:',
      macOS: (false, (12, 3, 0)),
    );
    _objc_msgSend_1oby3xk(
      _class_SCShareableContent,
      _sel_getShareableContentExcludingDesktopWindows_onScreenWindowsOnlyBelowWindow_completionHandler_,
      excludeDesktopWindows,
      onScreenWindowsOnlyBelowWindow.ref.pointer,
      completionHandler.ref.pointer,
    );
  }

  /// getShareableContentWithCompletionHandler:
  static void getShareableContentWithCompletionHandler(
    objc.ObjCBlock<ffi.Void Function(SCShareableContent?, objc.NSError?)>
    completionHandler,
  ) {
    objc.checkOsVersionInternal(
      'SCShareableContent.getShareableContentWithCompletionHandler:',
      macOS: (false, (12, 3, 0)),
    );
    _objc_msgSend_f167m6(
      _class_SCShareableContent,
      _sel_getShareableContentWithCompletionHandler_,
      completionHandler.ref.pointer,
    );
  }

  /// infoForFilter:
  static SCShareableContentInfo infoForFilter(SCContentFilter filter) {
    objc.checkOsVersionInternal(
      'SCShareableContent.infoForFilter:',
      macOS: (false, (14, 0, 0)),
    );
    final $ret = _objc_msgSend_1sotr3r(
      _class_SCShareableContent,
      _sel_infoForFilter_,
      filter.ref.pointer,
    );
    return SCShareableContentInfo.fromPointer(
      $ret,
      retain: true,
      release: true,
    );
  }

  /// new
  static SCShareableContent new$() {
    final $ret = _objc_msgSend_151sglz(_class_SCShareableContent, _sel_new);
    return SCShareableContent.fromPointer($ret, retain: false, release: true);
  }

  /// Returns a new instance of SCShareableContent constructed with the default `new` method.
  SCShareableContent() : this.as(new$().object$);
}

extension SCShareableContent$Methods on SCShareableContent {
  /// applications
  objc.NSArray get applications {
    objc.checkOsVersionInternal(
      'SCShareableContent.applications',
      macOS: (false, (12, 3, 0)),
    );
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_applications);
    return objc.NSArray.fromPointer($ret, retain: true, release: true);
  }

  /// displays
  objc.NSArray get displays {
    objc.checkOsVersionInternal(
      'SCShareableContent.displays',
      macOS: (false, (12, 3, 0)),
    );
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_displays);
    return objc.NSArray.fromPointer($ret, retain: true, release: true);
  }

  /// init
  SCShareableContent init() {
    objc.checkOsVersionInternal(
      'SCShareableContent.init',
      iOS: (false, (2, 0, 0)),
      macOS: (false, (10, 0, 0)),
    );
    final $ret = _objc_msgSend_151sglz(
      object$.ref.retainAndReturnPointer(),
      _sel_init,
    );
    return SCShareableContent.fromPointer($ret, retain: false, release: true);
  }

  /// windows
  objc.NSArray get windows {
    objc.checkOsVersionInternal(
      'SCShareableContent.windows',
      macOS: (false, (12, 3, 0)),
    );
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_windows);
    return objc.NSArray.fromPointer($ret, retain: true, release: true);
  }
}

sealed class CMTimeFlags {
  static const kCMTimeFlags_Valid = 1;
  static const kCMTimeFlags_HasBeenRounded = 2;
  static const kCMTimeFlags_PositiveInfinity = 4;
  static const kCMTimeFlags_NegativeInfinity = 8;
  static const kCMTimeFlags_Indefinite = 16;
  static const kCMTimeFlags_ImpliedValueFlagsMask = 28;
}

@ffi.Packed(4)
final class CMTime extends ffi.Struct {
  @ffi.Int64()
  external int value;

  @ffi.Int32()
  external int timescale;

  @ffi.Uint32()
  external int flags;

  @ffi.Int64()
  external int epoch;
}

final class opaqueCMSampleBuffer extends ffi.Opaque {}

enum SCPresenterOverlayAlertSetting {
  SCPresenterOverlayAlertSettingSystem(0),
  SCPresenterOverlayAlertSettingNever(1),
  SCPresenterOverlayAlertSettingAlways(2);

  final int value;
  const SCPresenterOverlayAlertSetting(this.value);

  static SCPresenterOverlayAlertSetting fromValue(int value) => switch (value) {
    0 => SCPresenterOverlayAlertSettingSystem,
    1 => SCPresenterOverlayAlertSettingNever,
    2 => SCPresenterOverlayAlertSettingAlways,
    _ => throw ArgumentError(
      'Unknown value for SCPresenterOverlayAlertSetting: $value',
    ),
  };
}

enum SCCaptureResolutionType {
  SCCaptureResolutionAutomatic(0),
  SCCaptureResolutionBest(1),
  SCCaptureResolutionNominal(2);

  final int value;
  const SCCaptureResolutionType(this.value);

  static SCCaptureResolutionType fromValue(int value) => switch (value) {
    0 => SCCaptureResolutionAutomatic,
    1 => SCCaptureResolutionBest,
    2 => SCCaptureResolutionNominal,
    _ => throw ArgumentError(
      'Unknown value for SCCaptureResolutionType: $value',
    ),
  };
}

enum SCCaptureDynamicRange {
  SCCaptureDynamicRangeSDR(0),
  SCCaptureDynamicRangeHDRLocalDisplay(1),
  SCCaptureDynamicRangeHDRCanonicalDisplay(2);

  final int value;
  const SCCaptureDynamicRange(this.value);

  static SCCaptureDynamicRange fromValue(int value) => switch (value) {
    0 => SCCaptureDynamicRangeSDR,
    1 => SCCaptureDynamicRangeHDRLocalDisplay,
    2 => SCCaptureDynamicRangeHDRCanonicalDisplay,
    _ => throw ArgumentError('Unknown value for SCCaptureDynamicRange: $value'),
  };
}

/// WARNING: SCStreamConfiguration is a stub. To generate bindings for this class, include
/// SCStreamConfiguration in your config's objc-interfaces list.
///
/// SCStreamConfiguration
extension type SCStreamConfiguration._(objc.ObjCObject object$)
    implements objc.ObjCObject, objc.NSObject {
  /// Constructs a [SCStreamConfiguration] that points to the same underlying object as [other].
  SCStreamConfiguration.as(objc.ObjCObject other) : object$ = other {
    objc.checkOsVersionInternal(
      'SCStreamConfiguration',
      macOS: (false, (12, 3, 0)),
    );
  }

  /// Constructs a [SCStreamConfiguration] that wraps the given raw object pointer.
  SCStreamConfiguration.fromPointer(
    ffi.Pointer<objc.ObjCObjectImpl> other, {
    bool retain = false,
    bool release = false,
  }) : object$ = objc.ObjCObject(other, retain: retain, release: release) {
    objc.checkOsVersionInternal(
      'SCStreamConfiguration',
      macOS: (false, (12, 3, 0)),
    );
  }
}

enum SCStreamConfigurationPreset {
  SCStreamConfigurationPresetCaptureHDRStreamLocalDisplay(0),
  SCStreamConfigurationPresetCaptureHDRStreamCanonicalDisplay(1),
  SCStreamConfigurationPresetCaptureHDRScreenshotLocalDisplay(2),
  SCStreamConfigurationPresetCaptureHDRScreenshotCanonicalDisplay(3),
  SCStreamConfigurationPresetCaptureHDRRecordingPreservedSDRHDR10(4);

  final int value;
  const SCStreamConfigurationPreset(this.value);

  static SCStreamConfigurationPreset fromValue(int value) => switch (value) {
    0 => SCStreamConfigurationPresetCaptureHDRStreamLocalDisplay,
    1 => SCStreamConfigurationPresetCaptureHDRStreamCanonicalDisplay,
    2 => SCStreamConfigurationPresetCaptureHDRScreenshotLocalDisplay,
    3 => SCStreamConfigurationPresetCaptureHDRScreenshotCanonicalDisplay,
    4 => SCStreamConfigurationPresetCaptureHDRRecordingPreservedSDRHDR10,
    _ => throw ArgumentError(
      'Unknown value for SCStreamConfigurationPreset: $value',
    ),
  };
}

enum SCScreenshotDisplayIntent {
  SCScreenshotDisplayIntentCanonical(0),
  SCScreenshotDisplayIntentLocal(1);

  final int value;
  const SCScreenshotDisplayIntent(this.value);

  static SCScreenshotDisplayIntent fromValue(int value) => switch (value) {
    0 => SCScreenshotDisplayIntentCanonical,
    1 => SCScreenshotDisplayIntentLocal,
    _ => throw ArgumentError(
      'Unknown value for SCScreenshotDisplayIntent: $value',
    ),
  };
}

enum SCScreenshotDynamicRange {
  SCScreenshotDynamicRangeSDR(0),
  SCScreenshotDynamicRangeHDR(1),
  SCScreenshotDynamicRangeSDRAndHDR(2);

  final int value;
  const SCScreenshotDynamicRange(this.value);

  static SCScreenshotDynamicRange fromValue(int value) => switch (value) {
    0 => SCScreenshotDynamicRangeSDR,
    1 => SCScreenshotDynamicRangeHDR,
    2 => SCScreenshotDynamicRangeSDRAndHDR,
    _ => throw ArgumentError(
      'Unknown value for SCScreenshotDynamicRange: $value',
    ),
  };
}

late final _class_SCScreenshotConfiguration = objc.getClass(
  "SCScreenshotConfiguration",
);
late final _sel_setWidth_ = objc.registerName("setWidth:");
final _objc_msgSend_4sp4xj = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Long,
        )
      >
    >()
    .asFunction<
      void Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
        int,
      )
    >();
late final _sel_setHeight_ = objc.registerName("setHeight:");
late final _sel_showsCursor = objc.registerName("showsCursor");
late final _sel_setShowsCursor_ = objc.registerName("setShowsCursor:");
late final _sel_sourceRect = objc.registerName("sourceRect");
late final _sel_setSourceRect_ = objc.registerName("setSourceRect:");
final _objc_msgSend_1okkq16 = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
          objc.CGRect,
        )
      >
    >()
    .asFunction<
      void Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
        objc.CGRect,
      )
    >();
late final _sel_destinationRect = objc.registerName("destinationRect");
late final _sel_setDestinationRect_ = objc.registerName("setDestinationRect:");
late final _sel_ignoreShadows = objc.registerName("ignoreShadows");
late final _sel_setIgnoreShadows_ = objc.registerName("setIgnoreShadows:");
late final _sel_ignoreClipping = objc.registerName("ignoreClipping");
late final _sel_setIgnoreClipping_ = objc.registerName("setIgnoreClipping:");
late final _sel_includeChildWindows = objc.registerName("includeChildWindows");
late final _sel_setIncludeChildWindows_ = objc.registerName(
  "setIncludeChildWindows:",
);
late final _sel_displayIntent = objc.registerName("displayIntent");
final _objc_msgSend_1hd3foh = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Long Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
        )
      >
    >()
    .asFunction<
      int Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
      )
    >();
late final _sel_setDisplayIntent_ = objc.registerName("setDisplayIntent:");
final _objc_msgSend_1aipfm1 = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Long,
        )
      >
    >()
    .asFunction<
      void Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
        int,
      )
    >();
late final _sel_dynamicRange = objc.registerName("dynamicRange");
final _objc_msgSend_ibmwpx = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Long Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
        )
      >
    >()
    .asFunction<
      int Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
      )
    >();
late final _sel_setDynamicRange_ = objc.registerName("setDynamicRange:");
final _objc_msgSend_1wrfi5l = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Long,
        )
      >
    >()
    .asFunction<
      void Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
        int,
      )
    >();
late final _class_UTType = objc.getClass("UTType");
late final _sel_typeWithIdentifier_ = objc.registerName("typeWithIdentifier:");
late final _sel_typeWithFilenameExtension_ = objc.registerName(
  "typeWithFilenameExtension:",
);
late final _sel_typeWithFilenameExtension_conformingToType_ = objc.registerName(
  "typeWithFilenameExtension:conformingToType:",
);
late final _sel_typeWithMIMEType_ = objc.registerName("typeWithMIMEType:");
late final _sel_typeWithMIMEType_conformingToType_ = objc.registerName(
  "typeWithMIMEType:conformingToType:",
);
late final _sel_identifier = objc.registerName("identifier");
late final _sel_preferredFilenameExtension = objc.registerName(
  "preferredFilenameExtension",
);
late final _sel_preferredMIMEType = objc.registerName("preferredMIMEType");
late final _sel_localizedDescription = objc.registerName(
  "localizedDescription",
);
late final _sel_version = objc.registerName("version");
late final _sel_referenceURL = objc.registerName("referenceURL");
late final _sel_isDynamic = objc.registerName("isDynamic");
late final _sel_isDeclared = objc.registerName("isDeclared");
late final _sel_isPublicType = objc.registerName("isPublicType");
late final _sel_supportsSecureCoding = objc.registerName(
  "supportsSecureCoding",
);

/// Construction methods for `objc.ObjCBlock<ffi.Bool Function(ffi.Pointer<ffi.Void>)>`.
abstract final class ObjCBlock_bool_ffiVoid {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<ffi.Bool Function(ffi.Pointer<ffi.Void>)> fromPointer(
    ffi.Pointer<objc.ObjCBlockImpl> pointer, {
    bool retain = false,
    bool release = false,
  }) => objc.ObjCBlock<ffi.Bool Function(ffi.Pointer<ffi.Void>)>(
    pointer,
    retain: retain,
    release: release,
  );

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<ffi.Bool Function(ffi.Pointer<ffi.Void>)>
  fromFunctionPointer(
    ffi.Pointer<
      ffi.NativeFunction<ffi.Bool Function(ffi.Pointer<ffi.Void> arg0)>
    >
    ptr,
  ) => objc.ObjCBlock<ffi.Bool Function(ffi.Pointer<ffi.Void>)>(
    objc.newPointerBlock(_fnPtrCallable, ptr.cast()),
    retain: false,
    release: true,
  );

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Bool Function(ffi.Pointer<ffi.Void>)> fromFunction(
    bool Function(ffi.Pointer<ffi.Void>) fn, {
    bool keepIsolateAlive = true,
  }) => objc.ObjCBlock<ffi.Bool Function(ffi.Pointer<ffi.Void>)>(
    objc.newClosureBlock(
      _closureCallable,
      (ffi.Pointer<ffi.Void> arg0) => fn(arg0),
      keepIsolateAlive,
    ),
    retain: false,
    release: true,
  );

  static bool _fnPtrTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
  ) => block.ref.target
      .cast<ffi.NativeFunction<ffi.Bool Function(ffi.Pointer<ffi.Void> arg0)>>()
      .asFunction<bool Function(ffi.Pointer<ffi.Void>)>()(arg0);
  static ffi.Pointer<ffi.Void> _fnPtrCallable =
      ffi.Pointer.fromFunction<
            ffi.Bool Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
            )
          >(_fnPtrTrampoline, false)
          .cast();
  static bool _closureTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
  ) => (objc.getBlockClosure(block) as bool Function(ffi.Pointer<ffi.Void>))(
    arg0,
  );
  static ffi.Pointer<ffi.Void> _closureCallable =
      ffi.Pointer.fromFunction<
            ffi.Bool Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
            )
          >(_closureTrampoline, false)
          .cast();
}

/// Call operator for `objc.ObjCBlock<ffi.Bool Function(ffi.Pointer<ffi.Void>)>`.
extension ObjCBlock_bool_ffiVoid$CallExtension
    on objc.ObjCBlock<ffi.Bool Function(ffi.Pointer<ffi.Void>)> {
  bool call(ffi.Pointer<ffi.Void> arg0) => ref.pointer.ref.invoke
      .cast<
        ffi.NativeFunction<
          ffi.Bool Function(
            ffi.Pointer<objc.ObjCBlockImpl> block,
            ffi.Pointer<ffi.Void> arg0,
          )
        >
      >()
      .asFunction<
        bool Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>)
      >()(ref.pointer, arg0);
}

late final _sel_encodeWithCoder_ = objc.registerName("encodeWithCoder:");
final _objc_msgSend_xtuoz7 = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Pointer<objc.ObjCObjectImpl>,
        )
      >
    >()
    .asFunction<
      void Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
        ffi.Pointer<objc.ObjCObjectImpl>,
      )
    >();

/// Construction methods for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, objc.NSCoder)>`.
abstract final class ObjCBlock_ffiVoid_ffiVoid_NSCoder {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, objc.NSCoder)>
  fromPointer(
    ffi.Pointer<objc.ObjCBlockImpl> pointer, {
    bool retain = false,
    bool release = false,
  }) => objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, objc.NSCoder)>(
    pointer,
    retain: retain,
    release: release,
  );

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, objc.NSCoder)>
  fromFunctionPointer(
    ffi.Pointer<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<ffi.Void> arg0,
          ffi.Pointer<objc.ObjCObjectImpl> arg1,
        )
      >
    >
    ptr,
  ) => objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, objc.NSCoder)>(
    objc.newPointerBlock(_fnPtrCallable, ptr.cast()),
    retain: false,
    release: true,
  );

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, objc.NSCoder)>
  fromFunction(
    void Function(ffi.Pointer<ffi.Void>, objc.NSCoder) fn, {
    bool keepIsolateAlive = true,
  }) => objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, objc.NSCoder)>(
    objc.newClosureBlock(
      _closureCallable,
      (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1) =>
          fn(arg0, objc.NSCoder.fromPointer(arg1, retain: true, release: true)),
      keepIsolateAlive,
    ),
    retain: false,
    release: true,
  );

  /// Creates a listener block from a Dart function.
  ///
  /// This is based on FFI's NativeCallable.listener, and has the same
  /// capabilities and limitations. This block can be invoked from any thread,
  /// but only supports void functions, and is not run synchronously. See
  /// NativeCallable.listener for more details.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, objc.NSCoder)>
  listener(
    void Function(ffi.Pointer<ffi.Void>, objc.NSCoder) fn, {
    bool keepIsolateAlive = true,
  }) {
    final raw = objc.newClosureBlock(
      _listenerCallable.nativeFunction.cast(),
      (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1) => fn(
        arg0,
        objc.NSCoder.fromPointer(arg1, retain: false, release: true),
      ),
      keepIsolateAlive,
    );
    final wrapper = _NativeLibrary_wrapListenerBlock_18v1jvf(raw);
    objc.objectRelease(raw.cast());
    return objc.ObjCBlock<
      ffi.Void Function(ffi.Pointer<ffi.Void>, objc.NSCoder)
    >(wrapper, retain: false, release: true);
  }

  /// Creates a blocking block from a Dart function.
  ///
  /// This callback can be invoked from any native thread, and will block the
  /// caller until the callback is handled by the Dart isolate that created
  /// the block. Async functions are not supported.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC. If the owner isolate
  /// has shut down, and the block is invoked by native code, it may block
  /// indefinitely, or have other undefined behavior.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, objc.NSCoder)>
  blocking(
    void Function(ffi.Pointer<ffi.Void>, objc.NSCoder) fn, {
    bool keepIsolateAlive = true,
  }) {
    final raw = objc.newClosureBlock(
      _blockingCallable.nativeFunction.cast(),
      (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1) => fn(
        arg0,
        objc.NSCoder.fromPointer(arg1, retain: false, release: true),
      ),
      keepIsolateAlive,
    );
    final rawListener = objc.newClosureBlock(
      _blockingListenerCallable.nativeFunction.cast(),
      (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1) => fn(
        arg0,
        objc.NSCoder.fromPointer(arg1, retain: false, release: true),
      ),
      keepIsolateAlive,
    );
    final wrapper = _NativeLibrary_wrapBlockingBlock_18v1jvf(
      raw,
      rawListener,
      objc.objCContext,
    );
    objc.objectRelease(raw.cast());
    objc.objectRelease(rawListener.cast());
    return objc.ObjCBlock<
      ffi.Void Function(ffi.Pointer<ffi.Void>, objc.NSCoder)
    >(wrapper, retain: false, release: true);
  }

  static void _listenerTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
  ) {
    (objc.getBlockClosure(block)
        as void Function(
          ffi.Pointer<ffi.Void>,
          ffi.Pointer<objc.ObjCObjectImpl>,
        ))(arg0, arg1);
    objc.objectRelease(block.cast());
  }

  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<objc.ObjCObjectImpl>,
    )
  >
  _listenerCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          )
        >.listener(_listenerTrampoline)
        ..keepIsolateAlive = false;
  static void _blockingTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> waiter,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
  ) {
    try {
      (objc.getBlockClosure(block)
          as void Function(
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          ))(arg0, arg1);
    } catch (e) {
    } finally {
      objc.signalWaiter(waiter);
      objc.objectRelease(block.cast());
    }
  }

  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<objc.ObjCObjectImpl>,
    )
  >
  _blockingCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          )
        >.isolateLocal(_blockingTrampoline)
        ..keepIsolateAlive = false;
  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<objc.ObjCObjectImpl>,
    )
  >
  _blockingListenerCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          )
        >.listener(_blockingTrampoline)
        ..keepIsolateAlive = false;
  static void _fnPtrTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
  ) => block.ref.target
      .cast<
        ffi.NativeFunction<
          ffi.Void Function(
            ffi.Pointer<ffi.Void> arg0,
            ffi.Pointer<objc.ObjCObjectImpl> arg1,
          )
        >
      >()
      .asFunction<
        void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObjectImpl>)
      >()(arg0, arg1);
  static ffi.Pointer<ffi.Void> _fnPtrCallable =
      ffi.Pointer.fromFunction<
            ffi.Void Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<objc.ObjCObjectImpl>,
            )
          >(_fnPtrTrampoline)
          .cast();
  static void _closureTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
  ) =>
      (objc.getBlockClosure(block)
          as void Function(
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          ))(arg0, arg1);
  static ffi.Pointer<ffi.Void> _closureCallable =
      ffi.Pointer.fromFunction<
            ffi.Void Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<objc.ObjCObjectImpl>,
            )
          >(_closureTrampoline)
          .cast();
}

/// Call operator for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, objc.NSCoder)>`.
extension ObjCBlock_ffiVoid_ffiVoid_NSCoder$CallExtension
    on objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, objc.NSCoder)> {
  void call(ffi.Pointer<ffi.Void> arg0, objc.NSCoder arg1) => ref
      .pointer
      .ref
      .invoke
      .cast<
        ffi.NativeFunction<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl> block,
            ffi.Pointer<ffi.Void> arg0,
            ffi.Pointer<objc.ObjCObjectImpl> arg1,
          )
        >
      >()
      .asFunction<
        void Function(
          ffi.Pointer<objc.ObjCBlockImpl>,
          ffi.Pointer<ffi.Void>,
          ffi.Pointer<objc.ObjCObjectImpl>,
        )
      >()(ref.pointer, arg0, arg1.ref.pointer);
}

late final _sel_initWithCoder_ = objc.registerName("initWithCoder:");

/// Construction methods for `objc.ObjCBlock<objc.Retained<ffi.Pointer<objc.ObjCObjectImpl>?> Function(ffi.Pointer<ffi.Void>, objc.NSCoder)>`.
abstract final class ObjCBlock_instancetype_ffiVoid_NSCoder {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<
    objc.Retained<ffi.Pointer<objc.ObjCObjectImpl>?> Function(
      ffi.Pointer<ffi.Void>,
      objc.NSCoder,
    )
  >
  fromPointer(
    ffi.Pointer<objc.ObjCBlockImpl> pointer, {
    bool retain = false,
    bool release = false,
  }) =>
      objc.ObjCBlock<
        objc.Retained<ffi.Pointer<objc.ObjCObjectImpl>?> Function(
          ffi.Pointer<ffi.Void>,
          objc.NSCoder,
        )
      >(pointer, retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<
    objc.Retained<ffi.Pointer<objc.ObjCObjectImpl>?> Function(
      ffi.Pointer<ffi.Void>,
      objc.NSCoder,
    )
  >
  fromFunctionPointer(
    ffi.Pointer<
      ffi.NativeFunction<
        instancetype Function(
          ffi.Pointer<ffi.Void> arg0,
          ffi.Pointer<objc.ObjCObjectImpl> arg1,
        )
      >
    >
    ptr,
  ) =>
      objc.ObjCBlock<
        objc.Retained<ffi.Pointer<objc.ObjCObjectImpl>?> Function(
          ffi.Pointer<ffi.Void>,
          objc.NSCoder,
        )
      >(
        objc.newPointerBlock(_fnPtrCallable, ptr.cast()),
        retain: false,
        release: true,
      );

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<
    objc.Retained<ffi.Pointer<objc.ObjCObjectImpl>?> Function(
      ffi.Pointer<ffi.Void>,
      objc.NSCoder,
    )
  >
  fromFunction(
    Dartinstancetype? Function(ffi.Pointer<ffi.Void>, objc.NSCoder) fn, {
    bool keepIsolateAlive = true,
  }) =>
      objc.ObjCBlock<
        objc.Retained<ffi.Pointer<objc.ObjCObjectImpl>?> Function(
          ffi.Pointer<ffi.Void>,
          objc.NSCoder,
        )
      >(
        objc.newClosureBlock(
          _closureCallable,
          (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1) =>
              fn(
                arg0,
                objc.NSCoder.fromPointer(arg1, retain: true, release: true),
              )?.ref.retainAndReturnPointer() ??
              ffi.nullptr,
          keepIsolateAlive,
        ),
        retain: false,
        release: true,
      );

  static instancetype _fnPtrTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
  ) => block.ref.target
      .cast<
        ffi.NativeFunction<
          instancetype Function(
            ffi.Pointer<ffi.Void> arg0,
            ffi.Pointer<objc.ObjCObjectImpl> arg1,
          )
        >
      >()
      .asFunction<
        instancetype Function(
          ffi.Pointer<ffi.Void>,
          ffi.Pointer<objc.ObjCObjectImpl>,
        )
      >()(arg0, arg1);
  static ffi.Pointer<ffi.Void> _fnPtrCallable =
      ffi.Pointer.fromFunction<
            instancetype Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<objc.ObjCObjectImpl>,
            )
          >(_fnPtrTrampoline)
          .cast();
  static instancetype _closureTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
  ) =>
      (objc.getBlockClosure(block)
          as instancetype Function(
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          ))(arg0, arg1);
  static ffi.Pointer<ffi.Void> _closureCallable =
      ffi.Pointer.fromFunction<
            instancetype Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<objc.ObjCObjectImpl>,
            )
          >(_closureTrampoline)
          .cast();
}

/// Call operator for `objc.ObjCBlock<objc.Retained<ffi.Pointer<objc.ObjCObjectImpl>?> Function(ffi.Pointer<ffi.Void>, objc.NSCoder)>`.
extension ObjCBlock_instancetype_ffiVoid_NSCoder$CallExtension
    on
        objc.ObjCBlock<
          objc.Retained<ffi.Pointer<objc.ObjCObjectImpl>?> Function(
            ffi.Pointer<ffi.Void>,
            objc.NSCoder,
          )
        > {
  Dartinstancetype? call(ffi.Pointer<ffi.Void> arg0, objc.NSCoder arg1) =>
      ref.pointer.ref.invoke
              .cast<
                ffi.NativeFunction<
                  instancetype Function(
                    ffi.Pointer<objc.ObjCBlockImpl> block,
                    ffi.Pointer<ffi.Void> arg0,
                    ffi.Pointer<objc.ObjCObjectImpl> arg1,
                  )
                >
              >()
              .asFunction<
                instancetype Function(
                  ffi.Pointer<objc.ObjCBlockImpl>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<objc.ObjCObjectImpl>,
                )
              >()(ref.pointer, arg0, arg1.ref.pointer)
              .address ==
          0
      ? null
      : objc.ObjCObject(
          ref.pointer.ref.invoke
              .cast<
                ffi.NativeFunction<
                  instancetype Function(
                    ffi.Pointer<objc.ObjCBlockImpl> block,
                    ffi.Pointer<ffi.Void> arg0,
                    ffi.Pointer<objc.ObjCObjectImpl> arg1,
                  )
                >
              >()
              .asFunction<
                instancetype Function(
                  ffi.Pointer<objc.ObjCBlockImpl>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<objc.ObjCObjectImpl>,
                )
              >()(ref.pointer, arg0, arg1.ref.pointer),
          retain: false,
          release: true,
        );
}

late final _sel_typeWithTag_tagClass_conformingToType_ = objc.registerName(
  "typeWithTag:tagClass:conformingToType:",
);
late final _sel_conformsToType_ = objc.registerName("conformsToType:");
late final _sel_isSupertypeOfType_ = objc.registerName("isSupertypeOfType:");
late final _sel_isSubtypeOfType_ = objc.registerName("isSubtypeOfType:");
late final _sel_supertypes = objc.registerName("supertypes");

/// Conformance
extension Conformance on UTType {
  /// conformsToType:
  bool conformsToType(UTType type) {
    objc.checkOsVersionInternal(
      'UTType.conformsToType:',
      iOS: (false, (14, 0, 0)),
      macOS: (false, (11, 0, 0)),
    );
    return _objc_msgSend_19nvye5(
      object$.ref.pointer,
      _sel_conformsToType_,
      type.ref.pointer,
    );
  }

  /// isSubtypeOfType:
  bool isSubtypeOfType(UTType type) {
    objc.checkOsVersionInternal(
      'UTType.isSubtypeOfType:',
      iOS: (false, (14, 0, 0)),
      macOS: (false, (11, 0, 0)),
    );
    return _objc_msgSend_19nvye5(
      object$.ref.pointer,
      _sel_isSubtypeOfType_,
      type.ref.pointer,
    );
  }

  /// isSupertypeOfType:
  bool isSupertypeOfType(UTType type) {
    objc.checkOsVersionInternal(
      'UTType.isSupertypeOfType:',
      iOS: (false, (14, 0, 0)),
      macOS: (false, (11, 0, 0)),
    );
    return _objc_msgSend_19nvye5(
      object$.ref.pointer,
      _sel_isSupertypeOfType_,
      type.ref.pointer,
    );
  }

  /// supertypes
  objc.NSSet get supertypes {
    objc.checkOsVersionInternal(
      'UTType.supertypes',
      iOS: (false, (14, 0, 0)),
      macOS: (false, (11, 0, 0)),
    );
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_supertypes);
    return objc.NSSet.fromPointer($ret, retain: true, release: true);
  }
}

late final _sel_typesWithTag_tagClass_conformingToType_ = objc.registerName(
  "typesWithTag:tagClass:conformingToType:",
);
late final _sel_tags = objc.registerName("tags");

/// UTTagSpecification
extension UTTagSpecification on UTType {
  /// tags
  objc.NSDictionary get tags {
    objc.checkOsVersionInternal(
      'UTType.tags',
      iOS: (false, (14, 0, 0)),
      macOS: (false, (11, 0, 0)),
    );
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_tags);
    return objc.NSDictionary.fromPointer($ret, retain: true, release: true);
  }

  /// typesWithTag:tagClass:conformingToType:
  static objc.NSArray typesWithTag(
    objc.NSString tag, {
    required objc.NSString tagClass,
    UTType? conformingToType,
  }) {
    objc.checkOsVersionInternal(
      'UTType.typesWithTag:tagClass:conformingToType:',
      iOS: (false, (14, 0, 0)),
      macOS: (false, (11, 0, 0)),
    );
    final $ret = _objc_msgSend_11spmsz(
      _class_UTType,
      _sel_typesWithTag_tagClass_conformingToType_,
      tag.ref.pointer,
      tagClass.ref.pointer,
      conformingToType?.ref.pointer ?? ffi.nullptr,
    );
    return objc.NSArray.fromPointer($ret, retain: true, release: true);
  }
}

late final _sel_exportedTypeWithIdentifier_ = objc.registerName(
  "exportedTypeWithIdentifier:",
);
late final _sel_exportedTypeWithIdentifier_conformingToType_ = objc
    .registerName("exportedTypeWithIdentifier:conformingToType:");
late final _sel_importedTypeWithIdentifier_ = objc.registerName(
  "importedTypeWithIdentifier:",
);
late final _sel_importedTypeWithIdentifier_conformingToType_ = objc
    .registerName("importedTypeWithIdentifier:conformingToType:");

/// LocalConstants
extension LocalConstants on UTType {
  /// exportedTypeWithIdentifier:
  static UTType exportedTypeWithIdentifier(objc.NSString identifier) {
    objc.checkOsVersionInternal(
      'UTType.exportedTypeWithIdentifier:',
      iOS: (false, (14, 0, 0)),
      macOS: (false, (11, 0, 0)),
    );
    final $ret = _objc_msgSend_1sotr3r(
      _class_UTType,
      _sel_exportedTypeWithIdentifier_,
      identifier.ref.pointer,
    );
    return UTType.fromPointer($ret, retain: true, release: true);
  }

  /// exportedTypeWithIdentifier:conformingToType:
  static UTType exportedTypeWithIdentifier$1(
    objc.NSString identifier, {
    required UTType conformingToType,
  }) {
    objc.checkOsVersionInternal(
      'UTType.exportedTypeWithIdentifier:conformingToType:',
      iOS: (false, (14, 0, 0)),
      macOS: (false, (11, 0, 0)),
    );
    final $ret = _objc_msgSend_15qeuct(
      _class_UTType,
      _sel_exportedTypeWithIdentifier_conformingToType_,
      identifier.ref.pointer,
      conformingToType.ref.pointer,
    );
    return UTType.fromPointer($ret, retain: true, release: true);
  }

  /// importedTypeWithIdentifier:
  static UTType importedTypeWithIdentifier(objc.NSString identifier) {
    objc.checkOsVersionInternal(
      'UTType.importedTypeWithIdentifier:',
      iOS: (false, (14, 0, 0)),
      macOS: (false, (11, 0, 0)),
    );
    final $ret = _objc_msgSend_1sotr3r(
      _class_UTType,
      _sel_importedTypeWithIdentifier_,
      identifier.ref.pointer,
    );
    return UTType.fromPointer($ret, retain: true, release: true);
  }

  /// importedTypeWithIdentifier:conformingToType:
  static UTType importedTypeWithIdentifier$1(
    objc.NSString identifier, {
    required UTType conformingToType,
  }) {
    objc.checkOsVersionInternal(
      'UTType.importedTypeWithIdentifier:conformingToType:',
      iOS: (false, (14, 0, 0)),
      macOS: (false, (11, 0, 0)),
    );
    final $ret = _objc_msgSend_15qeuct(
      _class_UTType,
      _sel_importedTypeWithIdentifier_conformingToType_,
      identifier.ref.pointer,
      conformingToType.ref.pointer,
    );
    return UTType.fromPointer($ret, retain: true, release: true);
  }
}

/// UTType
extension type UTType._(objc.ObjCObject object$)
    implements
        objc.ObjCObject,
        objc.NSObject,
        objc.NSCopying,
        objc.NSSecureCoding {
  /// Constructs a [UTType] that points to the same underlying object as [other].
  UTType.as(objc.ObjCObject other) : object$ = other {
    assert(isA(object$));
  }

  /// Constructs a [UTType] that wraps the given raw object pointer.
  UTType.fromPointer(
    ffi.Pointer<objc.ObjCObjectImpl> other, {
    bool retain = false,
    bool release = false,
  }) : object$ = objc.ObjCObject(other, retain: retain, release: release) {
    assert(isA(object$));
  }

  /// Returns whether [obj] is an instance of [UTType].
  static bool isA(objc.ObjCObject obj) => _objc_msgSend_19nvye5(
    obj.ref.pointer,
    _sel_isKindOfClass_,
    _class_UTType,
  );

  /// alloc
  static UTType alloc() {
    final $ret = _objc_msgSend_151sglz(_class_UTType, _sel_alloc);
    return UTType.fromPointer($ret, retain: false, release: true);
  }

  /// allocWithZone:
  static UTType allocWithZone(ffi.Pointer<objc.NSZone> zone) {
    final $ret = _objc_msgSend_1cwp428(
      _class_UTType,
      _sel_allocWithZone_,
      zone,
    );
    return UTType.fromPointer($ret, retain: false, release: true);
  }

  /// new
  static UTType new$() {
    final $ret = _objc_msgSend_151sglz(_class_UTType, _sel_new);
    return UTType.fromPointer($ret, retain: false, release: true);
  }

  /// supportsSecureCoding
  static bool getSupportsSecureCoding() {
    return _objc_msgSend_91o635(_class_UTType, _sel_supportsSecureCoding);
  }

  /// typeWithFilenameExtension:
  static UTType? typeWithFilenameExtension(objc.NSString filenameExtension) {
    objc.checkOsVersionInternal(
      'UTType.typeWithFilenameExtension:',
      iOS: (false, (14, 0, 0)),
      macOS: (false, (11, 0, 0)),
    );
    final $ret = _objc_msgSend_1sotr3r(
      _class_UTType,
      _sel_typeWithFilenameExtension_,
      filenameExtension.ref.pointer,
    );
    return $ret.address == 0
        ? null
        : UTType.fromPointer($ret, retain: true, release: true);
  }

  /// typeWithFilenameExtension:conformingToType:
  static UTType? typeWithFilenameExtension$1(
    objc.NSString filenameExtension, {
    required UTType conformingToType,
  }) {
    objc.checkOsVersionInternal(
      'UTType.typeWithFilenameExtension:conformingToType:',
      iOS: (false, (14, 0, 0)),
      macOS: (false, (11, 0, 0)),
    );
    final $ret = _objc_msgSend_15qeuct(
      _class_UTType,
      _sel_typeWithFilenameExtension_conformingToType_,
      filenameExtension.ref.pointer,
      conformingToType.ref.pointer,
    );
    return $ret.address == 0
        ? null
        : UTType.fromPointer($ret, retain: true, release: true);
  }

  /// typeWithIdentifier:
  static UTType? typeWithIdentifier(objc.NSString identifier) {
    objc.checkOsVersionInternal(
      'UTType.typeWithIdentifier:',
      iOS: (false, (14, 0, 0)),
      macOS: (false, (11, 0, 0)),
    );
    final $ret = _objc_msgSend_1sotr3r(
      _class_UTType,
      _sel_typeWithIdentifier_,
      identifier.ref.pointer,
    );
    return $ret.address == 0
        ? null
        : UTType.fromPointer($ret, retain: true, release: true);
  }

  /// typeWithMIMEType:
  static UTType? typeWithMIMEType(objc.NSString mimeType) {
    objc.checkOsVersionInternal(
      'UTType.typeWithMIMEType:',
      iOS: (false, (14, 0, 0)),
      macOS: (false, (11, 0, 0)),
    );
    final $ret = _objc_msgSend_1sotr3r(
      _class_UTType,
      _sel_typeWithMIMEType_,
      mimeType.ref.pointer,
    );
    return $ret.address == 0
        ? null
        : UTType.fromPointer($ret, retain: true, release: true);
  }

  /// typeWithMIMEType:conformingToType:
  static UTType? typeWithMIMEType$1(
    objc.NSString mimeType, {
    required UTType conformingToType,
  }) {
    objc.checkOsVersionInternal(
      'UTType.typeWithMIMEType:conformingToType:',
      iOS: (false, (14, 0, 0)),
      macOS: (false, (11, 0, 0)),
    );
    final $ret = _objc_msgSend_15qeuct(
      _class_UTType,
      _sel_typeWithMIMEType_conformingToType_,
      mimeType.ref.pointer,
      conformingToType.ref.pointer,
    );
    return $ret.address == 0
        ? null
        : UTType.fromPointer($ret, retain: true, release: true);
  }

  /// typeWithTag:tagClass:conformingToType:
  static UTType? typeWithTag(
    objc.NSString tag, {
    required objc.NSString tagClass,
    UTType? conformingToType,
  }) {
    objc.checkOsVersionInternal(
      'UTType.typeWithTag:tagClass:conformingToType:',
      iOS: (false, (14, 0, 0)),
      macOS: (false, (11, 0, 0)),
    );
    final $ret = _objc_msgSend_11spmsz(
      _class_UTType,
      _sel_typeWithTag_tagClass_conformingToType_,
      tag.ref.pointer,
      tagClass.ref.pointer,
      conformingToType?.ref.pointer ?? ffi.nullptr,
    );
    return $ret.address == 0
        ? null
        : UTType.fromPointer($ret, retain: true, release: true);
  }

  /// Returns a new instance of UTType constructed with the default `new` method.
  UTType() : this.as(new$().object$);
}

extension UTType$Methods on UTType {
  /// encodeWithCoder:
  void encodeWithCoder(objc.NSCoder coder) {
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_encodeWithCoder_,
      coder.ref.pointer,
    );
  }

  /// identifier
  objc.NSString get identifier {
    objc.checkOsVersionInternal(
      'UTType.identifier',
      iOS: (false, (14, 0, 0)),
      macOS: (false, (11, 0, 0)),
    );
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_identifier);
    return objc.NSString.fromPointer($ret, retain: true, release: true);
  }

  /// init
  UTType init() {
    objc.checkOsVersionInternal(
      'UTType.init',
      iOS: (false, (2, 0, 0)),
      macOS: (false, (10, 0, 0)),
    );
    final $ret = _objc_msgSend_151sglz(
      object$.ref.retainAndReturnPointer(),
      _sel_init,
    );
    return UTType.fromPointer($ret, retain: false, release: true);
  }

  /// initWithCoder:
  UTType? initWithCoder(objc.NSCoder coder) {
    final $ret = _objc_msgSend_1sotr3r(
      object$.ref.retainAndReturnPointer(),
      _sel_initWithCoder_,
      coder.ref.pointer,
    );
    return $ret.address == 0
        ? null
        : UTType.fromPointer($ret, retain: false, release: true);
  }

  /// isDeclared
  bool get isDeclared {
    objc.checkOsVersionInternal(
      'UTType.isDeclared',
      iOS: (false, (14, 0, 0)),
      macOS: (false, (11, 0, 0)),
    );
    return _objc_msgSend_91o635(object$.ref.pointer, _sel_isDeclared);
  }

  /// isDynamic
  bool get isDynamic {
    objc.checkOsVersionInternal(
      'UTType.isDynamic',
      iOS: (false, (14, 0, 0)),
      macOS: (false, (11, 0, 0)),
    );
    return _objc_msgSend_91o635(object$.ref.pointer, _sel_isDynamic);
  }

  /// isPublicType
  bool get isPublicType {
    objc.checkOsVersionInternal(
      'UTType.isPublicType',
      iOS: (false, (14, 0, 0)),
      macOS: (false, (11, 0, 0)),
    );
    return _objc_msgSend_91o635(object$.ref.pointer, _sel_isPublicType);
  }

  /// localizedDescription
  objc.NSString? get localizedDescription {
    objc.checkOsVersionInternal(
      'UTType.localizedDescription',
      iOS: (false, (14, 0, 0)),
      macOS: (false, (11, 0, 0)),
    );
    final $ret = _objc_msgSend_151sglz(
      object$.ref.pointer,
      _sel_localizedDescription,
    );
    return $ret.address == 0
        ? null
        : objc.NSString.fromPointer($ret, retain: true, release: true);
  }

  /// preferredFilenameExtension
  objc.NSString? get preferredFilenameExtension {
    objc.checkOsVersionInternal(
      'UTType.preferredFilenameExtension',
      iOS: (false, (14, 0, 0)),
      macOS: (false, (11, 0, 0)),
    );
    final $ret = _objc_msgSend_151sglz(
      object$.ref.pointer,
      _sel_preferredFilenameExtension,
    );
    return $ret.address == 0
        ? null
        : objc.NSString.fromPointer($ret, retain: true, release: true);
  }

  /// preferredMIMEType
  objc.NSString? get preferredMIMEType {
    objc.checkOsVersionInternal(
      'UTType.preferredMIMEType',
      iOS: (false, (14, 0, 0)),
      macOS: (false, (11, 0, 0)),
    );
    final $ret = _objc_msgSend_151sglz(
      object$.ref.pointer,
      _sel_preferredMIMEType,
    );
    return $ret.address == 0
        ? null
        : objc.NSString.fromPointer($ret, retain: true, release: true);
  }

  /// referenceURL
  objc.NSURL? get referenceURL {
    objc.checkOsVersionInternal(
      'UTType.referenceURL',
      iOS: (false, (14, 0, 0)),
      macOS: (false, (11, 0, 0)),
    );
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_referenceURL);
    return $ret.address == 0
        ? null
        : objc.NSURL.fromPointer($ret, retain: true, release: true);
  }

  /// version
  objc.NSNumber? get version {
    objc.checkOsVersionInternal(
      'UTType.version',
      iOS: (false, (14, 0, 0)),
      macOS: (false, (11, 0, 0)),
    );
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_version);
    return $ret.address == 0
        ? null
        : objc.NSNumber.fromPointer($ret, retain: true, release: true);
  }
}

late final _sel_contentType = objc.registerName("contentType");
late final _sel_setContentType_ = objc.registerName("setContentType:");
late final _sel_fileURL = objc.registerName("fileURL");
late final _sel_setFileURL_ = objc.registerName("setFileURL:");
late final _sel_supportedContentTypes = objc.registerName(
  "supportedContentTypes",
);

/// SCScreenshotConfiguration
extension type SCScreenshotConfiguration._(objc.ObjCObject object$)
    implements objc.ObjCObject, objc.NSObject {
  /// Constructs a [SCScreenshotConfiguration] that points to the same underlying object as [other].
  SCScreenshotConfiguration.as(objc.ObjCObject other) : object$ = other {
    assert(isA(object$));
  }

  /// Constructs a [SCScreenshotConfiguration] that wraps the given raw object pointer.
  SCScreenshotConfiguration.fromPointer(
    ffi.Pointer<objc.ObjCObjectImpl> other, {
    bool retain = false,
    bool release = false,
  }) : object$ = objc.ObjCObject(other, retain: retain, release: release) {
    assert(isA(object$));
  }

  /// Returns whether [obj] is an instance of [SCScreenshotConfiguration].
  static bool isA(objc.ObjCObject obj) => _objc_msgSend_19nvye5(
    obj.ref.pointer,
    _sel_isKindOfClass_,
    _class_SCScreenshotConfiguration,
  );

  /// alloc
  static SCScreenshotConfiguration alloc() {
    final $ret = _objc_msgSend_151sglz(
      _class_SCScreenshotConfiguration,
      _sel_alloc,
    );
    return SCScreenshotConfiguration.fromPointer(
      $ret,
      retain: false,
      release: true,
    );
  }

  /// allocWithZone:
  static SCScreenshotConfiguration allocWithZone(
    ffi.Pointer<objc.NSZone> zone,
  ) {
    final $ret = _objc_msgSend_1cwp428(
      _class_SCScreenshotConfiguration,
      _sel_allocWithZone_,
      zone,
    );
    return SCScreenshotConfiguration.fromPointer(
      $ret,
      retain: false,
      release: true,
    );
  }

  /// new
  static SCScreenshotConfiguration new$() {
    final $ret = _objc_msgSend_151sglz(
      _class_SCScreenshotConfiguration,
      _sel_new,
    );
    return SCScreenshotConfiguration.fromPointer(
      $ret,
      retain: false,
      release: true,
    );
  }

  /// supportedContentTypes
  static objc.NSArray getSupportedContentTypes() {
    final $ret = _objc_msgSend_151sglz(
      _class_SCScreenshotConfiguration,
      _sel_supportedContentTypes,
    );
    return objc.NSArray.fromPointer($ret, retain: true, release: true);
  }

  /// Returns a new instance of SCScreenshotConfiguration constructed with the default `new` method.
  SCScreenshotConfiguration() : this.as(new$().object$);
}

extension SCScreenshotConfiguration$Methods on SCScreenshotConfiguration {
  /// contentType
  UTType get contentType {
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_contentType);
    return UTType.fromPointer($ret, retain: true, release: true);
  }

  /// destinationRect
  objc.CGRect get destinationRect {
    final $ptr = pkg_ffi.calloc<objc.CGRect>();
    objc.useMsgSendVariants
        ? _objc_msgSend_bu1hbwStret(
            $ptr,
            object$.ref.pointer,
            _sel_destinationRect,
          )
        : $ptr.ref = _objc_msgSend_bu1hbw(
            object$.ref.pointer,
            _sel_destinationRect,
          );
    final $finalizable = $ptr.cast<ffi.Uint8>().asTypedList(
      ffi.sizeOf<objc.CGRect>(),
      finalizer: pkg_ffi.calloc.nativeFree,
    );
    return ffi.Struct.create<objc.CGRect>($finalizable);
  }

  /// displayIntent
  SCScreenshotDisplayIntent get displayIntent {
    final $ret = _objc_msgSend_1hd3foh(object$.ref.pointer, _sel_displayIntent);
    return SCScreenshotDisplayIntent.fromValue($ret);
  }

  /// dynamicRange
  SCScreenshotDynamicRange get dynamicRange {
    final $ret = _objc_msgSend_ibmwpx(object$.ref.pointer, _sel_dynamicRange);
    return SCScreenshotDynamicRange.fromValue($ret);
  }

  /// fileURL
  objc.NSURL? get fileURL {
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_fileURL);
    return $ret.address == 0
        ? null
        : objc.NSURL.fromPointer($ret, retain: true, release: true);
  }

  /// height
  int get height {
    return _objc_msgSend_1hz7y9r(object$.ref.pointer, _sel_height);
  }

  /// ignoreClipping
  bool get ignoreClipping {
    return _objc_msgSend_91o635(object$.ref.pointer, _sel_ignoreClipping);
  }

  /// ignoreShadows
  bool get ignoreShadows {
    return _objc_msgSend_91o635(object$.ref.pointer, _sel_ignoreShadows);
  }

  /// includeChildWindows
  bool get includeChildWindows {
    return _objc_msgSend_91o635(object$.ref.pointer, _sel_includeChildWindows);
  }

  /// init
  SCScreenshotConfiguration init() {
    objc.checkOsVersionInternal(
      'SCScreenshotConfiguration.init',
      iOS: (false, (2, 0, 0)),
      macOS: (false, (10, 0, 0)),
    );
    final $ret = _objc_msgSend_151sglz(
      object$.ref.retainAndReturnPointer(),
      _sel_init,
    );
    return SCScreenshotConfiguration.fromPointer(
      $ret,
      retain: false,
      release: true,
    );
  }

  /// setContentType:
  set contentType(UTType value) {
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_setContentType_,
      value.ref.pointer,
    );
  }

  /// setDestinationRect:
  set destinationRect(objc.CGRect value) {
    _objc_msgSend_1okkq16(object$.ref.pointer, _sel_setDestinationRect_, value);
  }

  /// setDisplayIntent:
  set displayIntent(SCScreenshotDisplayIntent value) {
    _objc_msgSend_1aipfm1(
      object$.ref.pointer,
      _sel_setDisplayIntent_,
      value.value,
    );
  }

  /// setDynamicRange:
  set dynamicRange(SCScreenshotDynamicRange value) {
    _objc_msgSend_1wrfi5l(
      object$.ref.pointer,
      _sel_setDynamicRange_,
      value.value,
    );
  }

  /// setFileURL:
  set fileURL(objc.NSURL? value) {
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_setFileURL_,
      value?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// setHeight:
  set height(int value) {
    _objc_msgSend_4sp4xj(object$.ref.pointer, _sel_setHeight_, value);
  }

  /// setIgnoreClipping:
  set ignoreClipping(bool value) {
    _objc_msgSend_1s56lr9(object$.ref.pointer, _sel_setIgnoreClipping_, value);
  }

  /// setIgnoreShadows:
  set ignoreShadows(bool value) {
    _objc_msgSend_1s56lr9(object$.ref.pointer, _sel_setIgnoreShadows_, value);
  }

  /// setIncludeChildWindows:
  set includeChildWindows(bool value) {
    _objc_msgSend_1s56lr9(
      object$.ref.pointer,
      _sel_setIncludeChildWindows_,
      value,
    );
  }

  /// setShowsCursor:
  set showsCursor(bool value) {
    _objc_msgSend_1s56lr9(object$.ref.pointer, _sel_setShowsCursor_, value);
  }

  /// setSourceRect:
  set sourceRect(objc.CGRect value) {
    _objc_msgSend_1okkq16(object$.ref.pointer, _sel_setSourceRect_, value);
  }

  /// setWidth:
  set width(int value) {
    _objc_msgSend_4sp4xj(object$.ref.pointer, _sel_setWidth_, value);
  }

  /// showsCursor
  bool get showsCursor {
    return _objc_msgSend_91o635(object$.ref.pointer, _sel_showsCursor);
  }

  /// sourceRect
  objc.CGRect get sourceRect {
    final $ptr = pkg_ffi.calloc<objc.CGRect>();
    objc.useMsgSendVariants
        ? _objc_msgSend_bu1hbwStret($ptr, object$.ref.pointer, _sel_sourceRect)
        : $ptr.ref = _objc_msgSend_bu1hbw(object$.ref.pointer, _sel_sourceRect);
    final $finalizable = $ptr.cast<ffi.Uint8>().asTypedList(
      ffi.sizeOf<objc.CGRect>(),
      finalizer: pkg_ffi.calloc.nativeFree,
    );
    return ffi.Struct.create<objc.CGRect>($finalizable);
  }

  /// width
  int get width {
    return _objc_msgSend_1hz7y9r(object$.ref.pointer, _sel_width);
  }
}

late final _class_SCScreenshotOutput = objc.getClass("SCScreenshotOutput");
late final _sel_sdrImage = objc.registerName("sdrImage");
final _objc_msgSend_y1izi1 = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Pointer<CGImage> Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
        )
      >
    >()
    .asFunction<
      ffi.Pointer<CGImage> Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
      )
    >();
late final _sel_setSdrImage_ = objc.registerName("setSdrImage:");
final _objc_msgSend_1gs4jd1 = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Pointer<CGImage>,
        )
      >
    >()
    .asFunction<
      void Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
        ffi.Pointer<CGImage>,
      )
    >();
late final _sel_hdrImage = objc.registerName("hdrImage");
late final _sel_setHdrImage_ = objc.registerName("setHdrImage:");

/// SCScreenshotOutput
extension type SCScreenshotOutput._(objc.ObjCObject object$)
    implements objc.ObjCObject, objc.NSObject {
  /// Constructs a [SCScreenshotOutput] that points to the same underlying object as [other].
  SCScreenshotOutput.as(objc.ObjCObject other) : object$ = other {
    assert(isA(object$));
  }

  /// Constructs a [SCScreenshotOutput] that wraps the given raw object pointer.
  SCScreenshotOutput.fromPointer(
    ffi.Pointer<objc.ObjCObjectImpl> other, {
    bool retain = false,
    bool release = false,
  }) : object$ = objc.ObjCObject(other, retain: retain, release: release) {
    assert(isA(object$));
  }

  /// Returns whether [obj] is an instance of [SCScreenshotOutput].
  static bool isA(objc.ObjCObject obj) => _objc_msgSend_19nvye5(
    obj.ref.pointer,
    _sel_isKindOfClass_,
    _class_SCScreenshotOutput,
  );

  /// alloc
  static SCScreenshotOutput alloc() {
    final $ret = _objc_msgSend_151sglz(_class_SCScreenshotOutput, _sel_alloc);
    return SCScreenshotOutput.fromPointer($ret, retain: false, release: true);
  }

  /// allocWithZone:
  static SCScreenshotOutput allocWithZone(ffi.Pointer<objc.NSZone> zone) {
    final $ret = _objc_msgSend_1cwp428(
      _class_SCScreenshotOutput,
      _sel_allocWithZone_,
      zone,
    );
    return SCScreenshotOutput.fromPointer($ret, retain: false, release: true);
  }

  /// new
  static SCScreenshotOutput new$() {
    final $ret = _objc_msgSend_151sglz(_class_SCScreenshotOutput, _sel_new);
    return SCScreenshotOutput.fromPointer($ret, retain: false, release: true);
  }

  /// Returns a new instance of SCScreenshotOutput constructed with the default `new` method.
  SCScreenshotOutput() : this.as(new$().object$);
}

extension SCScreenshotOutput$Methods on SCScreenshotOutput {
  /// fileURL
  objc.NSURL? get fileURL {
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_fileURL);
    return $ret.address == 0
        ? null
        : objc.NSURL.fromPointer($ret, retain: true, release: true);
  }

  /// hdrImage
  ffi.Pointer<CGImage> get hdrImage {
    return _objc_msgSend_y1izi1(object$.ref.pointer, _sel_hdrImage);
  }

  /// init
  SCScreenshotOutput init() {
    objc.checkOsVersionInternal(
      'SCScreenshotOutput.init',
      iOS: (false, (2, 0, 0)),
      macOS: (false, (10, 0, 0)),
    );
    final $ret = _objc_msgSend_151sglz(
      object$.ref.retainAndReturnPointer(),
      _sel_init,
    );
    return SCScreenshotOutput.fromPointer($ret, retain: false, release: true);
  }

  /// sdrImage
  ffi.Pointer<CGImage> get sdrImage {
    return _objc_msgSend_y1izi1(object$.ref.pointer, _sel_sdrImage);
  }

  /// setFileURL:
  set fileURL(objc.NSURL? value) {
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_setFileURL_,
      value?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// setHdrImage:
  set hdrImage(ffi.Pointer<CGImage> value) {
    _objc_msgSend_1gs4jd1(object$.ref.pointer, _sel_setHdrImage_, value);
  }

  /// setSdrImage:
  set sdrImage(ffi.Pointer<CGImage> value) {
    _objc_msgSend_1gs4jd1(object$.ref.pointer, _sel_setSdrImage_, value);
  }
}

late final _class_SCScreenshotManager = objc.getClass("SCScreenshotManager");

/// Construction methods for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<opaqueCMSampleBuffer>, objc.NSError?)>`.
abstract final class ObjCBlock_ffiVoid_CMSampleBufferRef_NSError {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<
    ffi.Void Function(ffi.Pointer<opaqueCMSampleBuffer>, objc.NSError?)
  >
  fromPointer(
    ffi.Pointer<objc.ObjCBlockImpl> pointer, {
    bool retain = false,
    bool release = false,
  }) =>
      objc.ObjCBlock<
        ffi.Void Function(ffi.Pointer<opaqueCMSampleBuffer>, objc.NSError?)
      >(pointer, retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<
    ffi.Void Function(ffi.Pointer<opaqueCMSampleBuffer>, objc.NSError?)
  >
  fromFunctionPointer(
    ffi.Pointer<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<opaqueCMSampleBuffer> arg0,
          ffi.Pointer<objc.ObjCObjectImpl> arg1,
        )
      >
    >
    ptr,
  ) =>
      objc.ObjCBlock<
        ffi.Void Function(ffi.Pointer<opaqueCMSampleBuffer>, objc.NSError?)
      >(
        objc.newPointerBlock(_fnPtrCallable, ptr.cast()),
        retain: false,
        release: true,
      );

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<
    ffi.Void Function(ffi.Pointer<opaqueCMSampleBuffer>, objc.NSError?)
  >
  fromFunction(
    void Function(ffi.Pointer<opaqueCMSampleBuffer>, objc.NSError?) fn, {
    bool keepIsolateAlive = true,
  }) =>
      objc.ObjCBlock<
        ffi.Void Function(ffi.Pointer<opaqueCMSampleBuffer>, objc.NSError?)
      >(
        objc.newClosureBlock(
          _closureCallable,
          (
            ffi.Pointer<opaqueCMSampleBuffer> arg0,
            ffi.Pointer<objc.ObjCObjectImpl> arg1,
          ) => fn(
            arg0,
            arg1.address == 0
                ? null
                : objc.NSError.fromPointer(arg1, retain: true, release: true),
          ),
          keepIsolateAlive,
        ),
        retain: false,
        release: true,
      );

  /// Creates a listener block from a Dart function.
  ///
  /// This is based on FFI's NativeCallable.listener, and has the same
  /// capabilities and limitations. This block can be invoked from any thread,
  /// but only supports void functions, and is not run synchronously. See
  /// NativeCallable.listener for more details.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<
    ffi.Void Function(ffi.Pointer<opaqueCMSampleBuffer>, objc.NSError?)
  >
  listener(
    void Function(ffi.Pointer<opaqueCMSampleBuffer>, objc.NSError?) fn, {
    bool keepIsolateAlive = true,
  }) {
    final raw = objc.newClosureBlock(
      _listenerCallable.nativeFunction.cast(),
      (
        ffi.Pointer<opaqueCMSampleBuffer> arg0,
        ffi.Pointer<objc.ObjCObjectImpl> arg1,
      ) => fn(
        arg0,
        arg1.address == 0
            ? null
            : objc.NSError.fromPointer(arg1, retain: false, release: true),
      ),
      keepIsolateAlive,
    );
    final wrapper = _NativeLibrary_wrapListenerBlock_ro4zln(raw);
    objc.objectRelease(raw.cast());
    return objc.ObjCBlock<
      ffi.Void Function(ffi.Pointer<opaqueCMSampleBuffer>, objc.NSError?)
    >(wrapper, retain: false, release: true);
  }

  /// Creates a blocking block from a Dart function.
  ///
  /// This callback can be invoked from any native thread, and will block the
  /// caller until the callback is handled by the Dart isolate that created
  /// the block. Async functions are not supported.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC. If the owner isolate
  /// has shut down, and the block is invoked by native code, it may block
  /// indefinitely, or have other undefined behavior.
  static objc.ObjCBlock<
    ffi.Void Function(ffi.Pointer<opaqueCMSampleBuffer>, objc.NSError?)
  >
  blocking(
    void Function(ffi.Pointer<opaqueCMSampleBuffer>, objc.NSError?) fn, {
    bool keepIsolateAlive = true,
  }) {
    final raw = objc.newClosureBlock(
      _blockingCallable.nativeFunction.cast(),
      (
        ffi.Pointer<opaqueCMSampleBuffer> arg0,
        ffi.Pointer<objc.ObjCObjectImpl> arg1,
      ) => fn(
        arg0,
        arg1.address == 0
            ? null
            : objc.NSError.fromPointer(arg1, retain: false, release: true),
      ),
      keepIsolateAlive,
    );
    final rawListener = objc.newClosureBlock(
      _blockingListenerCallable.nativeFunction.cast(),
      (
        ffi.Pointer<opaqueCMSampleBuffer> arg0,
        ffi.Pointer<objc.ObjCObjectImpl> arg1,
      ) => fn(
        arg0,
        arg1.address == 0
            ? null
            : objc.NSError.fromPointer(arg1, retain: false, release: true),
      ),
      keepIsolateAlive,
    );
    final wrapper = _NativeLibrary_wrapBlockingBlock_ro4zln(
      raw,
      rawListener,
      objc.objCContext,
    );
    objc.objectRelease(raw.cast());
    objc.objectRelease(rawListener.cast());
    return objc.ObjCBlock<
      ffi.Void Function(ffi.Pointer<opaqueCMSampleBuffer>, objc.NSError?)
    >(wrapper, retain: false, release: true);
  }

  static void _listenerTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<opaqueCMSampleBuffer> arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
  ) {
    (objc.getBlockClosure(block)
        as void Function(
          ffi.Pointer<opaqueCMSampleBuffer>,
          ffi.Pointer<objc.ObjCObjectImpl>,
        ))(arg0, arg1);
    objc.objectRelease(block.cast());
  }

  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<opaqueCMSampleBuffer>,
      ffi.Pointer<objc.ObjCObjectImpl>,
    )
  >
  _listenerCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<opaqueCMSampleBuffer>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          )
        >.listener(_listenerTrampoline)
        ..keepIsolateAlive = false;
  static void _blockingTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> waiter,
    ffi.Pointer<opaqueCMSampleBuffer> arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
  ) {
    try {
      (objc.getBlockClosure(block)
          as void Function(
            ffi.Pointer<opaqueCMSampleBuffer>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          ))(arg0, arg1);
    } catch (e) {
    } finally {
      objc.signalWaiter(waiter);
      objc.objectRelease(block.cast());
    }
  }

  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<opaqueCMSampleBuffer>,
      ffi.Pointer<objc.ObjCObjectImpl>,
    )
  >
  _blockingCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<opaqueCMSampleBuffer>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          )
        >.isolateLocal(_blockingTrampoline)
        ..keepIsolateAlive = false;
  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<opaqueCMSampleBuffer>,
      ffi.Pointer<objc.ObjCObjectImpl>,
    )
  >
  _blockingListenerCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<opaqueCMSampleBuffer>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          )
        >.listener(_blockingTrampoline)
        ..keepIsolateAlive = false;
  static void _fnPtrTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<opaqueCMSampleBuffer> arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
  ) => block.ref.target
      .cast<
        ffi.NativeFunction<
          ffi.Void Function(
            ffi.Pointer<opaqueCMSampleBuffer> arg0,
            ffi.Pointer<objc.ObjCObjectImpl> arg1,
          )
        >
      >()
      .asFunction<
        void Function(
          ffi.Pointer<opaqueCMSampleBuffer>,
          ffi.Pointer<objc.ObjCObjectImpl>,
        )
      >()(arg0, arg1);
  static ffi.Pointer<ffi.Void> _fnPtrCallable =
      ffi.Pointer.fromFunction<
            ffi.Void Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<opaqueCMSampleBuffer>,
              ffi.Pointer<objc.ObjCObjectImpl>,
            )
          >(_fnPtrTrampoline)
          .cast();
  static void _closureTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<opaqueCMSampleBuffer> arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
  ) =>
      (objc.getBlockClosure(block)
          as void Function(
            ffi.Pointer<opaqueCMSampleBuffer>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          ))(arg0, arg1);
  static ffi.Pointer<ffi.Void> _closureCallable =
      ffi.Pointer.fromFunction<
            ffi.Void Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<opaqueCMSampleBuffer>,
              ffi.Pointer<objc.ObjCObjectImpl>,
            )
          >(_closureTrampoline)
          .cast();
}

/// Call operator for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<opaqueCMSampleBuffer>, objc.NSError?)>`.
extension ObjCBlock_ffiVoid_CMSampleBufferRef_NSError$CallExtension
    on
        objc.ObjCBlock<
          ffi.Void Function(ffi.Pointer<opaqueCMSampleBuffer>, objc.NSError?)
        > {
  void call(ffi.Pointer<opaqueCMSampleBuffer> arg0, objc.NSError? arg1) => ref
      .pointer
      .ref
      .invoke
      .cast<
        ffi.NativeFunction<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl> block,
            ffi.Pointer<opaqueCMSampleBuffer> arg0,
            ffi.Pointer<objc.ObjCObjectImpl> arg1,
          )
        >
      >()
      .asFunction<
        void Function(
          ffi.Pointer<objc.ObjCBlockImpl>,
          ffi.Pointer<opaqueCMSampleBuffer>,
          ffi.Pointer<objc.ObjCObjectImpl>,
        )
      >()(ref.pointer, arg0, arg1?.ref.pointer ?? ffi.nullptr);
}

late final _sel_captureSampleBufferWithFilter_configuration_completionHandler_ =
    objc.registerName(
      "captureSampleBufferWithFilter:configuration:completionHandler:",
    );
final _objc_msgSend_18qun1e = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCBlockImpl>,
        )
      >
    >()
    .asFunction<
      void Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCBlockImpl>,
      )
    >();

/// Construction methods for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<CGImage>, objc.NSError?)>`.
abstract final class ObjCBlock_ffiVoid_CGImageRef_NSError {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<CGImage>, objc.NSError?)>
  fromPointer(
    ffi.Pointer<objc.ObjCBlockImpl> pointer, {
    bool retain = false,
    bool release = false,
  }) => objc.ObjCBlock<ffi.Void Function(ffi.Pointer<CGImage>, objc.NSError?)>(
    pointer,
    retain: retain,
    release: release,
  );

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<CGImage>, objc.NSError?)>
  fromFunctionPointer(
    ffi.Pointer<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<CGImage> arg0,
          ffi.Pointer<objc.ObjCObjectImpl> arg1,
        )
      >
    >
    ptr,
  ) => objc.ObjCBlock<ffi.Void Function(ffi.Pointer<CGImage>, objc.NSError?)>(
    objc.newPointerBlock(_fnPtrCallable, ptr.cast()),
    retain: false,
    release: true,
  );

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<CGImage>, objc.NSError?)>
  fromFunction(
    void Function(ffi.Pointer<CGImage>, objc.NSError?) fn, {
    bool keepIsolateAlive = true,
  }) => objc.ObjCBlock<ffi.Void Function(ffi.Pointer<CGImage>, objc.NSError?)>(
    objc.newClosureBlock(
      _closureCallable,
      (ffi.Pointer<CGImage> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1) => fn(
        arg0,
        arg1.address == 0
            ? null
            : objc.NSError.fromPointer(arg1, retain: true, release: true),
      ),
      keepIsolateAlive,
    ),
    retain: false,
    release: true,
  );

  /// Creates a listener block from a Dart function.
  ///
  /// This is based on FFI's NativeCallable.listener, and has the same
  /// capabilities and limitations. This block can be invoked from any thread,
  /// but only supports void functions, and is not run synchronously. See
  /// NativeCallable.listener for more details.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<CGImage>, objc.NSError?)>
  listener(
    void Function(ffi.Pointer<CGImage>, objc.NSError?) fn, {
    bool keepIsolateAlive = true,
  }) {
    final raw = objc.newClosureBlock(
      _listenerCallable.nativeFunction.cast(),
      (ffi.Pointer<CGImage> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1) => fn(
        arg0,
        arg1.address == 0
            ? null
            : objc.NSError.fromPointer(arg1, retain: false, release: true),
      ),
      keepIsolateAlive,
    );
    final wrapper = _NativeLibrary_wrapListenerBlock_19ugjh7(raw);
    objc.objectRelease(raw.cast());
    return objc.ObjCBlock<
      ffi.Void Function(ffi.Pointer<CGImage>, objc.NSError?)
    >(wrapper, retain: false, release: true);
  }

  /// Creates a blocking block from a Dart function.
  ///
  /// This callback can be invoked from any native thread, and will block the
  /// caller until the callback is handled by the Dart isolate that created
  /// the block. Async functions are not supported.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC. If the owner isolate
  /// has shut down, and the block is invoked by native code, it may block
  /// indefinitely, or have other undefined behavior.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<CGImage>, objc.NSError?)>
  blocking(
    void Function(ffi.Pointer<CGImage>, objc.NSError?) fn, {
    bool keepIsolateAlive = true,
  }) {
    final raw = objc.newClosureBlock(
      _blockingCallable.nativeFunction.cast(),
      (ffi.Pointer<CGImage> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1) => fn(
        arg0,
        arg1.address == 0
            ? null
            : objc.NSError.fromPointer(arg1, retain: false, release: true),
      ),
      keepIsolateAlive,
    );
    final rawListener = objc.newClosureBlock(
      _blockingListenerCallable.nativeFunction.cast(),
      (ffi.Pointer<CGImage> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1) => fn(
        arg0,
        arg1.address == 0
            ? null
            : objc.NSError.fromPointer(arg1, retain: false, release: true),
      ),
      keepIsolateAlive,
    );
    final wrapper = _NativeLibrary_wrapBlockingBlock_19ugjh7(
      raw,
      rawListener,
      objc.objCContext,
    );
    objc.objectRelease(raw.cast());
    objc.objectRelease(rawListener.cast());
    return objc.ObjCBlock<
      ffi.Void Function(ffi.Pointer<CGImage>, objc.NSError?)
    >(wrapper, retain: false, release: true);
  }

  static void _listenerTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<CGImage> arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
  ) {
    (objc.getBlockClosure(block)
        as void Function(
          ffi.Pointer<CGImage>,
          ffi.Pointer<objc.ObjCObjectImpl>,
        ))(arg0, arg1);
    objc.objectRelease(block.cast());
  }

  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<CGImage>,
      ffi.Pointer<objc.ObjCObjectImpl>,
    )
  >
  _listenerCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<CGImage>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          )
        >.listener(_listenerTrampoline)
        ..keepIsolateAlive = false;
  static void _blockingTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> waiter,
    ffi.Pointer<CGImage> arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
  ) {
    try {
      (objc.getBlockClosure(block)
          as void Function(
            ffi.Pointer<CGImage>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          ))(arg0, arg1);
    } catch (e) {
    } finally {
      objc.signalWaiter(waiter);
      objc.objectRelease(block.cast());
    }
  }

  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<CGImage>,
      ffi.Pointer<objc.ObjCObjectImpl>,
    )
  >
  _blockingCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<CGImage>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          )
        >.isolateLocal(_blockingTrampoline)
        ..keepIsolateAlive = false;
  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<CGImage>,
      ffi.Pointer<objc.ObjCObjectImpl>,
    )
  >
  _blockingListenerCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<CGImage>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          )
        >.listener(_blockingTrampoline)
        ..keepIsolateAlive = false;
  static void _fnPtrTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<CGImage> arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
  ) => block.ref.target
      .cast<
        ffi.NativeFunction<
          ffi.Void Function(
            ffi.Pointer<CGImage> arg0,
            ffi.Pointer<objc.ObjCObjectImpl> arg1,
          )
        >
      >()
      .asFunction<
        void Function(ffi.Pointer<CGImage>, ffi.Pointer<objc.ObjCObjectImpl>)
      >()(arg0, arg1);
  static ffi.Pointer<ffi.Void> _fnPtrCallable =
      ffi.Pointer.fromFunction<
            ffi.Void Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<CGImage>,
              ffi.Pointer<objc.ObjCObjectImpl>,
            )
          >(_fnPtrTrampoline)
          .cast();
  static void _closureTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<CGImage> arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
  ) =>
      (objc.getBlockClosure(block)
          as void Function(
            ffi.Pointer<CGImage>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          ))(arg0, arg1);
  static ffi.Pointer<ffi.Void> _closureCallable =
      ffi.Pointer.fromFunction<
            ffi.Void Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<CGImage>,
              ffi.Pointer<objc.ObjCObjectImpl>,
            )
          >(_closureTrampoline)
          .cast();
}

/// Call operator for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<CGImage>, objc.NSError?)>`.
extension ObjCBlock_ffiVoid_CGImageRef_NSError$CallExtension
    on objc.ObjCBlock<ffi.Void Function(ffi.Pointer<CGImage>, objc.NSError?)> {
  void call(ffi.Pointer<CGImage> arg0, objc.NSError? arg1) => ref
      .pointer
      .ref
      .invoke
      .cast<
        ffi.NativeFunction<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl> block,
            ffi.Pointer<CGImage> arg0,
            ffi.Pointer<objc.ObjCObjectImpl> arg1,
          )
        >
      >()
      .asFunction<
        void Function(
          ffi.Pointer<objc.ObjCBlockImpl>,
          ffi.Pointer<CGImage>,
          ffi.Pointer<objc.ObjCObjectImpl>,
        )
      >()(ref.pointer, arg0, arg1?.ref.pointer ?? ffi.nullptr);
}

late final _sel_captureImageWithFilter_configuration_completionHandler_ = objc
    .registerName("captureImageWithFilter:configuration:completionHandler:");
late final _sel_captureImageInRect_completionHandler_ = objc.registerName(
  "captureImageInRect:completionHandler:",
);
final _objc_msgSend_1ekrzmp = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
          objc.CGRect,
          ffi.Pointer<objc.ObjCBlockImpl>,
        )
      >
    >()
    .asFunction<
      void Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
        objc.CGRect,
        ffi.Pointer<objc.ObjCBlockImpl>,
      )
    >();

/// Construction methods for `objc.ObjCBlock<ffi.Void Function(SCScreenshotOutput?, objc.NSError?)>`.
abstract final class ObjCBlock_ffiVoid_SCScreenshotOutput_NSError {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<ffi.Void Function(SCScreenshotOutput?, objc.NSError?)>
  fromPointer(
    ffi.Pointer<objc.ObjCBlockImpl> pointer, {
    bool retain = false,
    bool release = false,
  }) => objc.ObjCBlock<ffi.Void Function(SCScreenshotOutput?, objc.NSError?)>(
    pointer,
    retain: retain,
    release: release,
  );

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<ffi.Void Function(SCScreenshotOutput?, objc.NSError?)>
  fromFunctionPointer(
    ffi.Pointer<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<objc.ObjCObjectImpl> arg0,
          ffi.Pointer<objc.ObjCObjectImpl> arg1,
        )
      >
    >
    ptr,
  ) => objc.ObjCBlock<ffi.Void Function(SCScreenshotOutput?, objc.NSError?)>(
    objc.newPointerBlock(_fnPtrCallable, ptr.cast()),
    retain: false,
    release: true,
  );

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Void Function(SCScreenshotOutput?, objc.NSError?)>
  fromFunction(
    void Function(SCScreenshotOutput?, objc.NSError?) fn, {
    bool keepIsolateAlive = true,
  }) => objc.ObjCBlock<ffi.Void Function(SCScreenshotOutput?, objc.NSError?)>(
    objc.newClosureBlock(
      _closureCallable,
      (
        ffi.Pointer<objc.ObjCObjectImpl> arg0,
        ffi.Pointer<objc.ObjCObjectImpl> arg1,
      ) => fn(
        arg0.address == 0
            ? null
            : SCScreenshotOutput.fromPointer(arg0, retain: true, release: true),
        arg1.address == 0
            ? null
            : objc.NSError.fromPointer(arg1, retain: true, release: true),
      ),
      keepIsolateAlive,
    ),
    retain: false,
    release: true,
  );

  /// Creates a listener block from a Dart function.
  ///
  /// This is based on FFI's NativeCallable.listener, and has the same
  /// capabilities and limitations. This block can be invoked from any thread,
  /// but only supports void functions, and is not run synchronously. See
  /// NativeCallable.listener for more details.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Void Function(SCScreenshotOutput?, objc.NSError?)>
  listener(
    void Function(SCScreenshotOutput?, objc.NSError?) fn, {
    bool keepIsolateAlive = true,
  }) {
    final raw = objc.newClosureBlock(
      _listenerCallable.nativeFunction.cast(),
      (
        ffi.Pointer<objc.ObjCObjectImpl> arg0,
        ffi.Pointer<objc.ObjCObjectImpl> arg1,
      ) => fn(
        arg0.address == 0
            ? null
            : SCScreenshotOutput.fromPointer(
                arg0,
                retain: false,
                release: true,
              ),
        arg1.address == 0
            ? null
            : objc.NSError.fromPointer(arg1, retain: false, release: true),
      ),
      keepIsolateAlive,
    );
    final wrapper = _NativeLibrary_wrapListenerBlock_pfv6jd(raw);
    objc.objectRelease(raw.cast());
    return objc.ObjCBlock<
      ffi.Void Function(SCScreenshotOutput?, objc.NSError?)
    >(wrapper, retain: false, release: true);
  }

  /// Creates a blocking block from a Dart function.
  ///
  /// This callback can be invoked from any native thread, and will block the
  /// caller until the callback is handled by the Dart isolate that created
  /// the block. Async functions are not supported.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC. If the owner isolate
  /// has shut down, and the block is invoked by native code, it may block
  /// indefinitely, or have other undefined behavior.
  static objc.ObjCBlock<ffi.Void Function(SCScreenshotOutput?, objc.NSError?)>
  blocking(
    void Function(SCScreenshotOutput?, objc.NSError?) fn, {
    bool keepIsolateAlive = true,
  }) {
    final raw = objc.newClosureBlock(
      _blockingCallable.nativeFunction.cast(),
      (
        ffi.Pointer<objc.ObjCObjectImpl> arg0,
        ffi.Pointer<objc.ObjCObjectImpl> arg1,
      ) => fn(
        arg0.address == 0
            ? null
            : SCScreenshotOutput.fromPointer(
                arg0,
                retain: false,
                release: true,
              ),
        arg1.address == 0
            ? null
            : objc.NSError.fromPointer(arg1, retain: false, release: true),
      ),
      keepIsolateAlive,
    );
    final rawListener = objc.newClosureBlock(
      _blockingListenerCallable.nativeFunction.cast(),
      (
        ffi.Pointer<objc.ObjCObjectImpl> arg0,
        ffi.Pointer<objc.ObjCObjectImpl> arg1,
      ) => fn(
        arg0.address == 0
            ? null
            : SCScreenshotOutput.fromPointer(
                arg0,
                retain: false,
                release: true,
              ),
        arg1.address == 0
            ? null
            : objc.NSError.fromPointer(arg1, retain: false, release: true),
      ),
      keepIsolateAlive,
    );
    final wrapper = _NativeLibrary_wrapBlockingBlock_pfv6jd(
      raw,
      rawListener,
      objc.objCContext,
    );
    objc.objectRelease(raw.cast());
    objc.objectRelease(rawListener.cast());
    return objc.ObjCBlock<
      ffi.Void Function(SCScreenshotOutput?, objc.NSError?)
    >(wrapper, retain: false, release: true);
  }

  static void _listenerTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<objc.ObjCObjectImpl> arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
  ) {
    (objc.getBlockClosure(block)
        as void Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCObjectImpl>,
        ))(arg0, arg1);
    objc.objectRelease(block.cast());
  }

  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<objc.ObjCObjectImpl>,
      ffi.Pointer<objc.ObjCObjectImpl>,
    )
  >
  _listenerCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          )
        >.listener(_listenerTrampoline)
        ..keepIsolateAlive = false;
  static void _blockingTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> waiter,
    ffi.Pointer<objc.ObjCObjectImpl> arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
  ) {
    try {
      (objc.getBlockClosure(block)
          as void Function(
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          ))(arg0, arg1);
    } catch (e) {
    } finally {
      objc.signalWaiter(waiter);
      objc.objectRelease(block.cast());
    }
  }

  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<objc.ObjCObjectImpl>,
      ffi.Pointer<objc.ObjCObjectImpl>,
    )
  >
  _blockingCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          )
        >.isolateLocal(_blockingTrampoline)
        ..keepIsolateAlive = false;
  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<objc.ObjCObjectImpl>,
      ffi.Pointer<objc.ObjCObjectImpl>,
    )
  >
  _blockingListenerCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          )
        >.listener(_blockingTrampoline)
        ..keepIsolateAlive = false;
  static void _fnPtrTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<objc.ObjCObjectImpl> arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
  ) => block.ref.target
      .cast<
        ffi.NativeFunction<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCObjectImpl> arg0,
            ffi.Pointer<objc.ObjCObjectImpl> arg1,
          )
        >
      >()
      .asFunction<
        void Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCObjectImpl>,
        )
      >()(arg0, arg1);
  static ffi.Pointer<ffi.Void> _fnPtrCallable =
      ffi.Pointer.fromFunction<
            ffi.Void Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<objc.ObjCObjectImpl>,
              ffi.Pointer<objc.ObjCObjectImpl>,
            )
          >(_fnPtrTrampoline)
          .cast();
  static void _closureTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<objc.ObjCObjectImpl> arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
  ) =>
      (objc.getBlockClosure(block)
          as void Function(
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          ))(arg0, arg1);
  static ffi.Pointer<ffi.Void> _closureCallable =
      ffi.Pointer.fromFunction<
            ffi.Void Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<objc.ObjCObjectImpl>,
              ffi.Pointer<objc.ObjCObjectImpl>,
            )
          >(_closureTrampoline)
          .cast();
}

/// Call operator for `objc.ObjCBlock<ffi.Void Function(SCScreenshotOutput?, objc.NSError?)>`.
extension ObjCBlock_ffiVoid_SCScreenshotOutput_NSError$CallExtension
    on objc.ObjCBlock<ffi.Void Function(SCScreenshotOutput?, objc.NSError?)> {
  void call(SCScreenshotOutput? arg0, objc.NSError? arg1) =>
      ref.pointer.ref.invoke
          .cast<
            ffi.NativeFunction<
              ffi.Void Function(
                ffi.Pointer<objc.ObjCBlockImpl> block,
                ffi.Pointer<objc.ObjCObjectImpl> arg0,
                ffi.Pointer<objc.ObjCObjectImpl> arg1,
              )
            >
          >()
          .asFunction<
            void Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<objc.ObjCObjectImpl>,
              ffi.Pointer<objc.ObjCObjectImpl>,
            )
          >()(
        ref.pointer,
        arg0?.ref.pointer ?? ffi.nullptr,
        arg1?.ref.pointer ?? ffi.nullptr,
      );
}

late final _sel_captureScreenshotWithFilter_configuration_completionHandler_ =
    objc.registerName(
      "captureScreenshotWithFilter:configuration:completionHandler:",
    );
late final _sel_captureScreenshotWithRect_configuration_completionHandler_ =
    objc.registerName(
      "captureScreenshotWithRect:configuration:completionHandler:",
    );
final _objc_msgSend_4u48uz = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
          objc.CGRect,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCBlockImpl>,
        )
      >
    >()
    .asFunction<
      void Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
        objc.CGRect,
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCBlockImpl>,
      )
    >();

/// SCScreenshotManager
extension type SCScreenshotManager._(objc.ObjCObject object$)
    implements objc.ObjCObject, objc.NSObject {
  /// Constructs a [SCScreenshotManager] that points to the same underlying object as [other].
  SCScreenshotManager.as(objc.ObjCObject other) : object$ = other {
    objc.checkOsVersionInternal(
      'SCScreenshotManager',
      macOS: (false, (14, 0, 0)),
    );
    assert(isA(object$));
  }

  /// Constructs a [SCScreenshotManager] that wraps the given raw object pointer.
  SCScreenshotManager.fromPointer(
    ffi.Pointer<objc.ObjCObjectImpl> other, {
    bool retain = false,
    bool release = false,
  }) : object$ = objc.ObjCObject(other, retain: retain, release: release) {
    objc.checkOsVersionInternal(
      'SCScreenshotManager',
      macOS: (false, (14, 0, 0)),
    );
    assert(isA(object$));
  }

  /// Returns whether [obj] is an instance of [SCScreenshotManager].
  static bool isA(objc.ObjCObject obj) => _objc_msgSend_19nvye5(
    obj.ref.pointer,
    _sel_isKindOfClass_,
    _class_SCScreenshotManager,
  );

  /// alloc
  static SCScreenshotManager alloc() {
    final $ret = _objc_msgSend_151sglz(_class_SCScreenshotManager, _sel_alloc);
    return SCScreenshotManager.fromPointer($ret, retain: false, release: true);
  }

  /// allocWithZone:
  static SCScreenshotManager allocWithZone(ffi.Pointer<objc.NSZone> zone) {
    final $ret = _objc_msgSend_1cwp428(
      _class_SCScreenshotManager,
      _sel_allocWithZone_,
      zone,
    );
    return SCScreenshotManager.fromPointer($ret, retain: false, release: true);
  }

  /// captureImageInRect:completionHandler:
  static void captureImageInRect(
    objc.CGRect rect, {
    objc.ObjCBlock<ffi.Void Function(ffi.Pointer<CGImage>, objc.NSError?)>?
    completionHandler,
  }) {
    objc.checkOsVersionInternal(
      'SCScreenshotManager.captureImageInRect:completionHandler:',
      macOS: (false, (15, 2, 0)),
    );
    _objc_msgSend_1ekrzmp(
      _class_SCScreenshotManager,
      _sel_captureImageInRect_completionHandler_,
      rect,
      completionHandler?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// captureImageWithFilter:configuration:completionHandler:
  static void captureImageWithFilter(
    SCContentFilter contentFilter, {
    required SCStreamConfiguration configuration,
    objc.ObjCBlock<ffi.Void Function(ffi.Pointer<CGImage>, objc.NSError?)>?
    completionHandler,
  }) {
    objc.checkOsVersionInternal(
      'SCScreenshotManager.captureImageWithFilter:configuration:completionHandler:',
      macOS: (false, (14, 0, 0)),
    );
    _objc_msgSend_18qun1e(
      _class_SCScreenshotManager,
      _sel_captureImageWithFilter_configuration_completionHandler_,
      contentFilter.ref.pointer,
      configuration.ref.pointer,
      completionHandler?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// captureSampleBufferWithFilter:configuration:completionHandler:
  static void captureSampleBufferWithFilter(
    SCContentFilter contentFilter, {
    required SCStreamConfiguration configuration,
    objc.ObjCBlock<
      ffi.Void Function(ffi.Pointer<opaqueCMSampleBuffer>, objc.NSError?)
    >?
    completionHandler,
  }) {
    objc.checkOsVersionInternal(
      'SCScreenshotManager.captureSampleBufferWithFilter:configuration:completionHandler:',
      macOS: (false, (14, 0, 0)),
    );
    _objc_msgSend_18qun1e(
      _class_SCScreenshotManager,
      _sel_captureSampleBufferWithFilter_configuration_completionHandler_,
      contentFilter.ref.pointer,
      configuration.ref.pointer,
      completionHandler?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// captureScreenshotWithFilter:configuration:completionHandler:
  static void captureScreenshotWithFilter(
    SCContentFilter contentFilter, {
    required SCScreenshotConfiguration configuration,
    objc.ObjCBlock<ffi.Void Function(SCScreenshotOutput?, objc.NSError?)>?
    completionHandler,
  }) {
    objc.checkOsVersionInternal(
      'SCScreenshotManager.captureScreenshotWithFilter:configuration:completionHandler:',
      macOS: (false, (26, 0, 0)),
    );
    _objc_msgSend_18qun1e(
      _class_SCScreenshotManager,
      _sel_captureScreenshotWithFilter_configuration_completionHandler_,
      contentFilter.ref.pointer,
      configuration.ref.pointer,
      completionHandler?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// captureScreenshotWithRect:configuration:completionHandler:
  static void captureScreenshotWithRect(
    objc.CGRect rect, {
    required SCScreenshotConfiguration configuration,
    objc.ObjCBlock<ffi.Void Function(SCScreenshotOutput?, objc.NSError?)>?
    completionHandler,
  }) {
    objc.checkOsVersionInternal(
      'SCScreenshotManager.captureScreenshotWithRect:configuration:completionHandler:',
      macOS: (false, (26, 0, 0)),
    );
    _objc_msgSend_4u48uz(
      _class_SCScreenshotManager,
      _sel_captureScreenshotWithRect_configuration_completionHandler_,
      rect,
      configuration.ref.pointer,
      completionHandler?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// new
  static SCScreenshotManager new$() {
    final $ret = _objc_msgSend_151sglz(_class_SCScreenshotManager, _sel_new);
    return SCScreenshotManager.fromPointer($ret, retain: false, release: true);
  }

  /// Returns a new instance of SCScreenshotManager constructed with the default `new` method.
  SCScreenshotManager() : this.as(new$().object$);
}

extension SCScreenshotManager$Methods on SCScreenshotManager {
  /// init
  SCScreenshotManager init() {
    objc.checkOsVersionInternal(
      'SCScreenshotManager.init',
      iOS: (false, (2, 0, 0)),
      macOS: (false, (10, 0, 0)),
    );
    final $ret = _objc_msgSend_151sglz(
      object$.ref.retainAndReturnPointer(),
      _sel_init,
    );
    return SCScreenshotManager.fromPointer($ret, retain: false, release: true);
  }
}
