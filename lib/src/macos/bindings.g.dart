// AUTO GENERATED FILE, DO NOT EDIT.
//
// Generated by `package:ffigen`.
// ignore_for_file: type=lint, unused_import
import 'dart:ffi' as ffi;
import 'package:objective_c/objective_c.dart' as objc;
import 'package:ffi/ffi.dart' as pkg_ffi;

@ffi.Native<ffi.Void Function(ffi.Pointer<ffi.Void>)>()
external void CFRelease(ffi.Pointer<ffi.Void> cf);

@ffi.Native<
  ffi.Pointer<__CFData> Function(ffi.Pointer<__CFAllocator>, ffi.Long)
>()
external ffi.Pointer<__CFData> CFDataCreateMutable(
  ffi.Pointer<__CFAllocator> allocator,
  int capacity,
);

@ffi.Native<ffi.Long Function(ffi.Pointer<__CFData>)>()
external int CFDataGetLength(ffi.Pointer<__CFData> theData);

@ffi.Native<ffi.Pointer<ffi.UnsignedChar> Function(ffi.Pointer<__CFData>)>()
external ffi.Pointer<ffi.UnsignedChar> CFDataGetBytePtr(
  ffi.Pointer<__CFData> theData,
);

@ffi.Native<ffi.Pointer<objc.CFString>>()
external ffi.Pointer<objc.CFString> kUTTypePNG;

@ffi.Native<ffi.Size Function(ffi.Pointer<CGImage>)>()
external int CGImageGetWidth(ffi.Pointer<CGImage> image);

@ffi.Native<ffi.Size Function(ffi.Pointer<CGImage>)>()
external int CGImageGetHeight(ffi.Pointer<CGImage> image);

@ffi.Native<ffi.Bool Function()>()
external bool CGPreflightScreenCaptureAccess();

@ffi.Native<ffi.Bool Function()>()
external bool CGRequestScreenCaptureAccess();

@ffi.Native<
  ffi.Pointer<CGImageDestination> Function(
    ffi.Pointer<__CFData>,
    ffi.Pointer<objc.CFString>,
    ffi.Size,
    ffi.Pointer<__CFDictionary>,
  )
>()
external ffi.Pointer<CGImageDestination> CGImageDestinationCreateWithData(
  ffi.Pointer<__CFData> data,
  ffi.Pointer<objc.CFString> type,
  int count,
  ffi.Pointer<__CFDictionary> options,
);

@ffi.Native<
  ffi.Void Function(
    ffi.Pointer<CGImageDestination>,
    ffi.Pointer<CGImage>,
    ffi.Pointer<__CFDictionary>,
  )
>()
external void CGImageDestinationAddImage(
  ffi.Pointer<CGImageDestination> idst,
  ffi.Pointer<CGImage> image,
  ffi.Pointer<__CFDictionary> properties,
);

@ffi.Native<ffi.Bool Function(ffi.Pointer<CGImageDestination>)>()
external bool CGImageDestinationFinalize(ffi.Pointer<CGImageDestination> idst);

@ffi.Native<
  ffi.Pointer<objc.ObjCBlockImpl> Function(ffi.Pointer<objc.ObjCBlockImpl>)
>(isLeaf: true)
external ffi.Pointer<objc.ObjCBlockImpl>
_NativeLibrary_wrapListenerBlock_pfv6jd(ffi.Pointer<objc.ObjCBlockImpl> block);

@ffi.Native<
  ffi.Pointer<objc.ObjCBlockImpl> Function(
    ffi.Pointer<objc.ObjCBlockImpl>,
    ffi.Pointer<objc.ObjCBlockImpl>,
    ffi.Pointer<objc.DOBJC_Context>,
  )
>(isLeaf: true)
external ffi.Pointer<objc.ObjCBlockImpl>
_NativeLibrary_wrapBlockingBlock_pfv6jd(
  ffi.Pointer<objc.ObjCBlockImpl> block,
  ffi.Pointer<objc.ObjCBlockImpl> listnerBlock,
  ffi.Pointer<objc.DOBJC_Context> context,
);

@ffi.Native<
  ffi.Pointer<objc.ObjCBlockImpl> Function(ffi.Pointer<objc.ObjCBlockImpl>)
>(isLeaf: true)
external ffi.Pointer<objc.ObjCBlockImpl>
_NativeLibrary_wrapListenerBlock_ro4zln(ffi.Pointer<objc.ObjCBlockImpl> block);

@ffi.Native<
  ffi.Pointer<objc.ObjCBlockImpl> Function(
    ffi.Pointer<objc.ObjCBlockImpl>,
    ffi.Pointer<objc.ObjCBlockImpl>,
    ffi.Pointer<objc.DOBJC_Context>,
  )
>(isLeaf: true)
external ffi.Pointer<objc.ObjCBlockImpl>
_NativeLibrary_wrapBlockingBlock_ro4zln(
  ffi.Pointer<objc.ObjCBlockImpl> block,
  ffi.Pointer<objc.ObjCBlockImpl> listnerBlock,
  ffi.Pointer<objc.DOBJC_Context> context,
);

@ffi.Native<
  ffi.Pointer<objc.ObjCBlockImpl> Function(ffi.Pointer<objc.ObjCBlockImpl>)
>(isLeaf: true)
external ffi.Pointer<objc.ObjCBlockImpl>
_NativeLibrary_wrapListenerBlock_19ugjh7(ffi.Pointer<objc.ObjCBlockImpl> block);

@ffi.Native<
  ffi.Pointer<objc.ObjCBlockImpl> Function(
    ffi.Pointer<objc.ObjCBlockImpl>,
    ffi.Pointer<objc.ObjCBlockImpl>,
    ffi.Pointer<objc.DOBJC_Context>,
  )
>(isLeaf: true)
external ffi.Pointer<objc.ObjCBlockImpl>
_NativeLibrary_wrapBlockingBlock_19ugjh7(
  ffi.Pointer<objc.ObjCBlockImpl> block,
  ffi.Pointer<objc.ObjCBlockImpl> listnerBlock,
  ffi.Pointer<objc.DOBJC_Context> context,
);

@ffi.Native<ffi.Pointer<objc.ObjCObjectImpl>>(symbol: 'UTTypePNG')
external ffi.Pointer<objc.ObjCObjectImpl> _UTTypePNG;

UTType get UTTypePNG =>
    UTType.fromPointer(_UTTypePNG, retain: true, release: true);

set UTTypePNG(UTType value) {
  UTType.fromPointer(_UTTypePNG, retain: false, release: true).ref.release();
  _UTTypePNG = value.ref.retainAndReturnPointer();
}

final class __CFAllocator extends ffi.Opaque {}

final class __CFDictionary extends ffi.Opaque {}

final class __CFData extends ffi.Opaque {}

final class CGColor extends ffi.Opaque {}

final class CGImage extends ffi.Opaque {}

final class CGImageDestination extends ffi.Opaque {}

enum SCShareableContentStyle {
  SCShareableContentStyleNone(0),
  SCShareableContentStyleWindow(1),
  SCShareableContentStyleDisplay(2),
  SCShareableContentStyleApplication(3);

  final int value;
  const SCShareableContentStyle(this.value);

  static SCShareableContentStyle fromValue(int value) => switch (value) {
    0 => SCShareableContentStyleNone,
    1 => SCShareableContentStyleWindow,
    2 => SCShareableContentStyleDisplay,
    3 => SCShareableContentStyleApplication,
    _ => throw ArgumentError(
      'Unknown value for SCShareableContentStyle: $value',
    ),
  };
}

late final _class_SCRunningApplication = objc.getClass("SCRunningApplication");
late final _sel_isKindOfClass_ = objc.registerName("isKindOfClass:");
final _objc_msgSend_19nvye5 = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Bool Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Pointer<objc.ObjCObjectImpl>,
        )
      >
    >()
    .asFunction<
      bool Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
        ffi.Pointer<objc.ObjCObjectImpl>,
      )
    >();
late final _sel_bundleIdentifier = objc.registerName("bundleIdentifier");
final _objc_msgSend_151sglz = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Pointer<objc.ObjCObjectImpl> Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
        )
      >
    >()
    .asFunction<
      ffi.Pointer<objc.ObjCObjectImpl> Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
      )
    >();
late final _sel_applicationName = objc.registerName("applicationName");
late final _sel_processID = objc.registerName("processID");
final _objc_msgSend_13yqbb6 = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Int Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
        )
      >
    >()
    .asFunction<
      int Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
      )
    >();
typedef instancetype = ffi.Pointer<objc.ObjCObjectImpl>;
typedef Dartinstancetype = objc.ObjCObject;
late final _sel_init = objc.registerName("init");
late final _sel_new = objc.registerName("new");
late final _sel_allocWithZone_ = objc.registerName("allocWithZone:");
final _objc_msgSend_1cwp428 = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Pointer<objc.ObjCObjectImpl> Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Pointer<objc.NSZone>,
        )
      >
    >()
    .asFunction<
      ffi.Pointer<objc.ObjCObjectImpl> Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
        ffi.Pointer<objc.NSZone>,
      )
    >();
late final _sel_alloc = objc.registerName("alloc");

/// SCRunningApplication
extension type SCRunningApplication._(objc.ObjCObject object$)
    implements objc.ObjCObject, objc.NSObject {
  /// Constructs a [SCRunningApplication] that points to the same underlying object as [other].
  SCRunningApplication.as(objc.ObjCObject other) : object$ = other {
    objc.checkOsVersionInternal(
      'SCRunningApplication',
      macOS: (false, (12, 3, 0)),
    );
    assert(isA(object$));
  }

  /// Constructs a [SCRunningApplication] that wraps the given raw object pointer.
  SCRunningApplication.fromPointer(
    ffi.Pointer<objc.ObjCObjectImpl> other, {
    bool retain = false,
    bool release = false,
  }) : object$ = objc.ObjCObject(other, retain: retain, release: release) {
    objc.checkOsVersionInternal(
      'SCRunningApplication',
      macOS: (false, (12, 3, 0)),
    );
    assert(isA(object$));
  }

  /// Returns whether [obj] is an instance of [SCRunningApplication].
  static bool isA(objc.ObjCObject obj) => _objc_msgSend_19nvye5(
    obj.ref.pointer,
    _sel_isKindOfClass_,
    _class_SCRunningApplication,
  );

  /// alloc
  static SCRunningApplication alloc() {
    final $ret = _objc_msgSend_151sglz(_class_SCRunningApplication, _sel_alloc);
    return SCRunningApplication.fromPointer($ret, retain: false, release: true);
  }

  /// allocWithZone:
  static SCRunningApplication allocWithZone(ffi.Pointer<objc.NSZone> zone) {
    final $ret = _objc_msgSend_1cwp428(
      _class_SCRunningApplication,
      _sel_allocWithZone_,
      zone,
    );
    return SCRunningApplication.fromPointer($ret, retain: false, release: true);
  }

  /// new
  static SCRunningApplication new$() {
    final $ret = _objc_msgSend_151sglz(_class_SCRunningApplication, _sel_new);
    return SCRunningApplication.fromPointer($ret, retain: false, release: true);
  }

  /// Returns a new instance of SCRunningApplication constructed with the default `new` method.
  SCRunningApplication() : this.as(new$().object$);
}

extension SCRunningApplication$Methods on SCRunningApplication {
  /// applicationName
  objc.NSString get applicationName {
    objc.checkOsVersionInternal(
      'SCRunningApplication.applicationName',
      macOS: (false, (12, 3, 0)),
    );
    final $ret = _objc_msgSend_151sglz(
      object$.ref.pointer,
      _sel_applicationName,
    );
    return objc.NSString.fromPointer($ret, retain: true, release: true);
  }

  /// bundleIdentifier
  objc.NSString get bundleIdentifier {
    objc.checkOsVersionInternal(
      'SCRunningApplication.bundleIdentifier',
      macOS: (false, (12, 3, 0)),
    );
    final $ret = _objc_msgSend_151sglz(
      object$.ref.pointer,
      _sel_bundleIdentifier,
    );
    return objc.NSString.fromPointer($ret, retain: true, release: true);
  }

  /// init
  SCRunningApplication init() {
    objc.checkOsVersionInternal(
      'SCRunningApplication.init',
      iOS: (false, (2, 0, 0)),
      macOS: (false, (10, 0, 0)),
    );
    final $ret = _objc_msgSend_151sglz(
      object$.ref.retainAndReturnPointer(),
      _sel_init,
    );
    return SCRunningApplication.fromPointer($ret, retain: false, release: true);
  }

  /// processID
  int get processID {
    objc.checkOsVersionInternal(
      'SCRunningApplication.processID',
      macOS: (false, (12, 3, 0)),
    );
    return _objc_msgSend_13yqbb6(object$.ref.pointer, _sel_processID);
  }
}

late final _class_SCWindow = objc.getClass("SCWindow");
late final _sel_windowID = objc.registerName("windowID");
final _objc_msgSend_usggvf = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Uint32 Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
        )
      >
    >()
    .asFunction<
      int Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
      )
    >();
late final _sel_frame = objc.registerName("frame");
final _objc_msgSend_bu1hbw = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        objc.CGRect Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
        )
      >
    >()
    .asFunction<
      objc.CGRect Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
      )
    >();
final _objc_msgSend_bu1hbwStret = objc.msgSendStretPointer
    .cast<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<objc.CGRect>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
        )
      >
    >()
    .asFunction<
      void Function(
        ffi.Pointer<objc.CGRect>,
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
      )
    >();
late final _sel_title = objc.registerName("title");
late final _sel_windowLayer = objc.registerName("windowLayer");
final _objc_msgSend_1hz7y9r = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Long Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
        )
      >
    >()
    .asFunction<
      int Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
      )
    >();
late final _sel_owningApplication = objc.registerName("owningApplication");
late final _sel_isOnScreen = objc.registerName("isOnScreen");
final _objc_msgSend_91o635 = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Bool Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
        )
      >
    >()
    .asFunction<
      bool Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
      )
    >();
late final _sel_isActive = objc.registerName("isActive");

/// SCWindow
extension type SCWindow._(objc.ObjCObject object$)
    implements objc.ObjCObject, objc.NSObject {
  /// Constructs a [SCWindow] that points to the same underlying object as [other].
  SCWindow.as(objc.ObjCObject other) : object$ = other {
    objc.checkOsVersionInternal('SCWindow', macOS: (false, (12, 3, 0)));
    assert(isA(object$));
  }

  /// Constructs a [SCWindow] that wraps the given raw object pointer.
  SCWindow.fromPointer(
    ffi.Pointer<objc.ObjCObjectImpl> other, {
    bool retain = false,
    bool release = false,
  }) : object$ = objc.ObjCObject(other, retain: retain, release: release) {
    objc.checkOsVersionInternal('SCWindow', macOS: (false, (12, 3, 0)));
    assert(isA(object$));
  }

  /// Returns whether [obj] is an instance of [SCWindow].
  static bool isA(objc.ObjCObject obj) => _objc_msgSend_19nvye5(
    obj.ref.pointer,
    _sel_isKindOfClass_,
    _class_SCWindow,
  );

  /// alloc
  static SCWindow alloc() {
    final $ret = _objc_msgSend_151sglz(_class_SCWindow, _sel_alloc);
    return SCWindow.fromPointer($ret, retain: false, release: true);
  }

  /// allocWithZone:
  static SCWindow allocWithZone(ffi.Pointer<objc.NSZone> zone) {
    final $ret = _objc_msgSend_1cwp428(
      _class_SCWindow,
      _sel_allocWithZone_,
      zone,
    );
    return SCWindow.fromPointer($ret, retain: false, release: true);
  }

  /// new
  static SCWindow new$() {
    final $ret = _objc_msgSend_151sglz(_class_SCWindow, _sel_new);
    return SCWindow.fromPointer($ret, retain: false, release: true);
  }

  /// Returns a new instance of SCWindow constructed with the default `new` method.
  SCWindow() : this.as(new$().object$);
}

extension SCWindow$Methods on SCWindow {
  /// frame
  objc.CGRect get frame {
    objc.checkOsVersionInternal('SCWindow.frame', macOS: (false, (12, 3, 0)));
    final $ptr = pkg_ffi.calloc<objc.CGRect>();
    objc.useMsgSendVariants
        ? _objc_msgSend_bu1hbwStret($ptr, object$.ref.pointer, _sel_frame)
        : $ptr.ref = _objc_msgSend_bu1hbw(object$.ref.pointer, _sel_frame);
    final $finalizable = $ptr.cast<ffi.Uint8>().asTypedList(
      ffi.sizeOf<objc.CGRect>(),
      finalizer: pkg_ffi.calloc.nativeFree,
    );
    return ffi.Struct.create<objc.CGRect>($finalizable);
  }

  /// init
  SCWindow init() {
    objc.checkOsVersionInternal(
      'SCWindow.init',
      iOS: (false, (2, 0, 0)),
      macOS: (false, (10, 0, 0)),
    );
    final $ret = _objc_msgSend_151sglz(
      object$.ref.retainAndReturnPointer(),
      _sel_init,
    );
    return SCWindow.fromPointer($ret, retain: false, release: true);
  }

  /// isActive
  bool get isActive {
    objc.checkOsVersionInternal(
      'SCWindow.isActive',
      macOS: (false, (13, 1, 0)),
    );
    return _objc_msgSend_91o635(object$.ref.pointer, _sel_isActive);
  }

  /// isOnScreen
  bool get isOnScreen {
    objc.checkOsVersionInternal(
      'SCWindow.isOnScreen',
      macOS: (false, (12, 3, 0)),
    );
    return _objc_msgSend_91o635(object$.ref.pointer, _sel_isOnScreen);
  }

  /// owningApplication
  SCRunningApplication? get owningApplication {
    objc.checkOsVersionInternal(
      'SCWindow.owningApplication',
      macOS: (false, (12, 3, 0)),
    );
    final $ret = _objc_msgSend_151sglz(
      object$.ref.pointer,
      _sel_owningApplication,
    );
    return $ret.address == 0
        ? null
        : SCRunningApplication.fromPointer($ret, retain: true, release: true);
  }

  /// title
  objc.NSString? get title {
    objc.checkOsVersionInternal('SCWindow.title', macOS: (false, (12, 3, 0)));
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_title);
    return $ret.address == 0
        ? null
        : objc.NSString.fromPointer($ret, retain: true, release: true);
  }

  /// windowID
  int get windowID {
    objc.checkOsVersionInternal(
      'SCWindow.windowID',
      macOS: (false, (12, 3, 0)),
    );
    return _objc_msgSend_usggvf(object$.ref.pointer, _sel_windowID);
  }

  /// windowLayer
  int get windowLayer {
    objc.checkOsVersionInternal(
      'SCWindow.windowLayer',
      macOS: (false, (12, 3, 0)),
    );
    return _objc_msgSend_1hz7y9r(object$.ref.pointer, _sel_windowLayer);
  }
}

late final _class_SCDisplay = objc.getClass("SCDisplay");
late final _sel_displayID = objc.registerName("displayID");
late final _sel_width = objc.registerName("width");
late final _sel_height = objc.registerName("height");

/// SCDisplay
extension type SCDisplay._(objc.ObjCObject object$)
    implements objc.ObjCObject, objc.NSObject {
  /// Constructs a [SCDisplay] that points to the same underlying object as [other].
  SCDisplay.as(objc.ObjCObject other) : object$ = other {
    objc.checkOsVersionInternal('SCDisplay', macOS: (false, (12, 3, 0)));
    assert(isA(object$));
  }

  /// Constructs a [SCDisplay] that wraps the given raw object pointer.
  SCDisplay.fromPointer(
    ffi.Pointer<objc.ObjCObjectImpl> other, {
    bool retain = false,
    bool release = false,
  }) : object$ = objc.ObjCObject(other, retain: retain, release: release) {
    objc.checkOsVersionInternal('SCDisplay', macOS: (false, (12, 3, 0)));
    assert(isA(object$));
  }

  /// Returns whether [obj] is an instance of [SCDisplay].
  static bool isA(objc.ObjCObject obj) => _objc_msgSend_19nvye5(
    obj.ref.pointer,
    _sel_isKindOfClass_,
    _class_SCDisplay,
  );

  /// alloc
  static SCDisplay alloc() {
    final $ret = _objc_msgSend_151sglz(_class_SCDisplay, _sel_alloc);
    return SCDisplay.fromPointer($ret, retain: false, release: true);
  }

  /// allocWithZone:
  static SCDisplay allocWithZone(ffi.Pointer<objc.NSZone> zone) {
    final $ret = _objc_msgSend_1cwp428(
      _class_SCDisplay,
      _sel_allocWithZone_,
      zone,
    );
    return SCDisplay.fromPointer($ret, retain: false, release: true);
  }

  /// new
  static SCDisplay new$() {
    final $ret = _objc_msgSend_151sglz(_class_SCDisplay, _sel_new);
    return SCDisplay.fromPointer($ret, retain: false, release: true);
  }

  /// Returns a new instance of SCDisplay constructed with the default `new` method.
  SCDisplay() : this.as(new$().object$);
}

extension SCDisplay$Methods on SCDisplay {
  /// displayID
  int get displayID {
    objc.checkOsVersionInternal(
      'SCDisplay.displayID',
      macOS: (false, (12, 3, 0)),
    );
    return _objc_msgSend_usggvf(object$.ref.pointer, _sel_displayID);
  }

  /// frame
  objc.CGRect get frame {
    objc.checkOsVersionInternal('SCDisplay.frame', macOS: (false, (12, 3, 0)));
    final $ptr = pkg_ffi.calloc<objc.CGRect>();
    objc.useMsgSendVariants
        ? _objc_msgSend_bu1hbwStret($ptr, object$.ref.pointer, _sel_frame)
        : $ptr.ref = _objc_msgSend_bu1hbw(object$.ref.pointer, _sel_frame);
    final $finalizable = $ptr.cast<ffi.Uint8>().asTypedList(
      ffi.sizeOf<objc.CGRect>(),
      finalizer: pkg_ffi.calloc.nativeFree,
    );
    return ffi.Struct.create<objc.CGRect>($finalizable);
  }

  /// height
  int get height {
    objc.checkOsVersionInternal('SCDisplay.height', macOS: (false, (12, 3, 0)));
    return _objc_msgSend_1hz7y9r(object$.ref.pointer, _sel_height);
  }

  /// init
  SCDisplay init() {
    objc.checkOsVersionInternal(
      'SCDisplay.init',
      iOS: (false, (2, 0, 0)),
      macOS: (false, (10, 0, 0)),
    );
    final $ret = _objc_msgSend_151sglz(
      object$.ref.retainAndReturnPointer(),
      _sel_init,
    );
    return SCDisplay.fromPointer($ret, retain: false, release: true);
  }

  /// width
  int get width {
    objc.checkOsVersionInternal('SCDisplay.width', macOS: (false, (12, 3, 0)));
    return _objc_msgSend_1hz7y9r(object$.ref.pointer, _sel_width);
  }
}

/// WARNING: SCShareableContentInfo is a stub. To generate bindings for this class, include
/// SCShareableContentInfo in your config's objc-interfaces list.
///
/// SCShareableContentInfo
extension type SCShareableContentInfo._(objc.ObjCObject object$)
    implements objc.ObjCObject, objc.NSObject {
  /// Constructs a [SCShareableContentInfo] that points to the same underlying object as [other].
  SCShareableContentInfo.as(objc.ObjCObject other) : object$ = other {
    objc.checkOsVersionInternal(
      'SCShareableContentInfo',
      macOS: (false, (14, 0, 0)),
    );
  }

  /// Constructs a [SCShareableContentInfo] that wraps the given raw object pointer.
  SCShareableContentInfo.fromPointer(
    ffi.Pointer<objc.ObjCObjectImpl> other, {
    bool retain = false,
    bool release = false,
  }) : object$ = objc.ObjCObject(other, retain: retain, release: release) {
    objc.checkOsVersionInternal(
      'SCShareableContentInfo',
      macOS: (false, (14, 0, 0)),
    );
  }
}

late final _class_SCShareableContent = objc.getClass("SCShareableContent");

/// Construction methods for `objc.ObjCBlock<ffi.Void Function(SCShareableContent?, objc.NSError?)>`.
abstract final class ObjCBlock_ffiVoid_SCShareableContent_NSError {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<ffi.Void Function(SCShareableContent?, objc.NSError?)>
  fromPointer(
    ffi.Pointer<objc.ObjCBlockImpl> pointer, {
    bool retain = false,
    bool release = false,
  }) => objc.ObjCBlock<ffi.Void Function(SCShareableContent?, objc.NSError?)>(
    pointer,
    retain: retain,
    release: release,
  );

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<ffi.Void Function(SCShareableContent?, objc.NSError?)>
  fromFunctionPointer(
    ffi.Pointer<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<objc.ObjCObjectImpl> arg0,
          ffi.Pointer<objc.ObjCObjectImpl> arg1,
        )
      >
    >
    ptr,
  ) => objc.ObjCBlock<ffi.Void Function(SCShareableContent?, objc.NSError?)>(
    objc.newPointerBlock(_fnPtrCallable, ptr.cast()),
    retain: false,
    release: true,
  );

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Void Function(SCShareableContent?, objc.NSError?)>
  fromFunction(
    void Function(SCShareableContent?, objc.NSError?) fn, {
    bool keepIsolateAlive = true,
  }) => objc.ObjCBlock<ffi.Void Function(SCShareableContent?, objc.NSError?)>(
    objc.newClosureBlock(
      _closureCallable,
      (
        ffi.Pointer<objc.ObjCObjectImpl> arg0,
        ffi.Pointer<objc.ObjCObjectImpl> arg1,
      ) => fn(
        arg0.address == 0
            ? null
            : SCShareableContent.fromPointer(arg0, retain: true, release: true),
        arg1.address == 0
            ? null
            : objc.NSError.fromPointer(arg1, retain: true, release: true),
      ),
      keepIsolateAlive,
    ),
    retain: false,
    release: true,
  );

  /// Creates a listener block from a Dart function.
  ///
  /// This is based on FFI's NativeCallable.listener, and has the same
  /// capabilities and limitations. This block can be invoked from any thread,
  /// but only supports void functions, and is not run synchronously. See
  /// NativeCallable.listener for more details.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Void Function(SCShareableContent?, objc.NSError?)>
  listener(
    void Function(SCShareableContent?, objc.NSError?) fn, {
    bool keepIsolateAlive = true,
  }) {
    final raw = objc.newClosureBlock(
      _listenerCallable.nativeFunction.cast(),
      (
        ffi.Pointer<objc.ObjCObjectImpl> arg0,
        ffi.Pointer<objc.ObjCObjectImpl> arg1,
      ) => fn(
        arg0.address == 0
            ? null
            : SCShareableContent.fromPointer(
                arg0,
                retain: false,
                release: true,
              ),
        arg1.address == 0
            ? null
            : objc.NSError.fromPointer(arg1, retain: false, release: true),
      ),
      keepIsolateAlive,
    );
    final wrapper = _NativeLibrary_wrapListenerBlock_pfv6jd(raw);
    objc.objectRelease(raw.cast());
    return objc.ObjCBlock<
      ffi.Void Function(SCShareableContent?, objc.NSError?)
    >(wrapper, retain: false, release: true);
  }

  /// Creates a blocking block from a Dart function.
  ///
  /// This callback can be invoked from any native thread, and will block the
  /// caller until the callback is handled by the Dart isolate that created
  /// the block. Async functions are not supported.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC. If the owner isolate
  /// has shut down, and the block is invoked by native code, it may block
  /// indefinitely, or have other undefined behavior.
  static objc.ObjCBlock<ffi.Void Function(SCShareableContent?, objc.NSError?)>
  blocking(
    void Function(SCShareableContent?, objc.NSError?) fn, {
    bool keepIsolateAlive = true,
  }) {
    final raw = objc.newClosureBlock(
      _blockingCallable.nativeFunction.cast(),
      (
        ffi.Pointer<objc.ObjCObjectImpl> arg0,
        ffi.Pointer<objc.ObjCObjectImpl> arg1,
      ) => fn(
        arg0.address == 0
            ? null
            : SCShareableContent.fromPointer(
                arg0,
                retain: false,
                release: true,
              ),
        arg1.address == 0
            ? null
            : objc.NSError.fromPointer(arg1, retain: false, release: true),
      ),
      keepIsolateAlive,
    );
    final rawListener = objc.newClosureBlock(
      _blockingListenerCallable.nativeFunction.cast(),
      (
        ffi.Pointer<objc.ObjCObjectImpl> arg0,
        ffi.Pointer<objc.ObjCObjectImpl> arg1,
      ) => fn(
        arg0.address == 0
            ? null
            : SCShareableContent.fromPointer(
                arg0,
                retain: false,
                release: true,
              ),
        arg1.address == 0
            ? null
            : objc.NSError.fromPointer(arg1, retain: false, release: true),
      ),
      keepIsolateAlive,
    );
    final wrapper = _NativeLibrary_wrapBlockingBlock_pfv6jd(
      raw,
      rawListener,
      objc.objCContext,
    );
    objc.objectRelease(raw.cast());
    objc.objectRelease(rawListener.cast());
    return objc.ObjCBlock<
      ffi.Void Function(SCShareableContent?, objc.NSError?)
    >(wrapper, retain: false, release: true);
  }

  static void _listenerTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<objc.ObjCObjectImpl> arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
  ) {
    (objc.getBlockClosure(block)
        as void Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCObjectImpl>,
        ))(arg0, arg1);
    objc.objectRelease(block.cast());
  }

  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<objc.ObjCObjectImpl>,
      ffi.Pointer<objc.ObjCObjectImpl>,
    )
  >
  _listenerCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          )
        >.listener(_listenerTrampoline)
        ..keepIsolateAlive = false;
  static void _blockingTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> waiter,
    ffi.Pointer<objc.ObjCObjectImpl> arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
  ) {
    try {
      (objc.getBlockClosure(block)
          as void Function(
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          ))(arg0, arg1);
    } catch (e) {
    } finally {
      objc.signalWaiter(waiter);
      objc.objectRelease(block.cast());
    }
  }

  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<objc.ObjCObjectImpl>,
      ffi.Pointer<objc.ObjCObjectImpl>,
    )
  >
  _blockingCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          )
        >.isolateLocal(_blockingTrampoline)
        ..keepIsolateAlive = false;
  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<objc.ObjCObjectImpl>,
      ffi.Pointer<objc.ObjCObjectImpl>,
    )
  >
  _blockingListenerCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          )
        >.listener(_blockingTrampoline)
        ..keepIsolateAlive = false;
  static void _fnPtrTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<objc.ObjCObjectImpl> arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
  ) => block.ref.target
      .cast<
        ffi.NativeFunction<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCObjectImpl> arg0,
            ffi.Pointer<objc.ObjCObjectImpl> arg1,
          )
        >
      >()
      .asFunction<
        void Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCObjectImpl>,
        )
      >()(arg0, arg1);
  static ffi.Pointer<ffi.Void> _fnPtrCallable =
      ffi.Pointer.fromFunction<
            ffi.Void Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<objc.ObjCObjectImpl>,
              ffi.Pointer<objc.ObjCObjectImpl>,
            )
          >(_fnPtrTrampoline)
          .cast();
  static void _closureTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<objc.ObjCObjectImpl> arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
  ) =>
      (objc.getBlockClosure(block)
          as void Function(
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          ))(arg0, arg1);
  static ffi.Pointer<ffi.Void> _closureCallable =
      ffi.Pointer.fromFunction<
            ffi.Void Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<objc.ObjCObjectImpl>,
              ffi.Pointer<objc.ObjCObjectImpl>,
            )
          >(_closureTrampoline)
          .cast();
}

/// Call operator for `objc.ObjCBlock<ffi.Void Function(SCShareableContent?, objc.NSError?)>`.
extension ObjCBlock_ffiVoid_SCShareableContent_NSError$CallExtension
    on objc.ObjCBlock<ffi.Void Function(SCShareableContent?, objc.NSError?)> {
  void call(SCShareableContent? arg0, objc.NSError? arg1) =>
      ref.pointer.ref.invoke
          .cast<
            ffi.NativeFunction<
              ffi.Void Function(
                ffi.Pointer<objc.ObjCBlockImpl> block,
                ffi.Pointer<objc.ObjCObjectImpl> arg0,
                ffi.Pointer<objc.ObjCObjectImpl> arg1,
              )
            >
          >()
          .asFunction<
            void Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<objc.ObjCObjectImpl>,
              ffi.Pointer<objc.ObjCObjectImpl>,
            )
          >()(
        ref.pointer,
        arg0?.ref.pointer ?? ffi.nullptr,
        arg1?.ref.pointer ?? ffi.nullptr,
      );
}

late final _sel_getShareableContentWithCompletionHandler_ = objc.registerName(
  "getShareableContentWithCompletionHandler:",
);
final _objc_msgSend_f167m6 = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Pointer<objc.ObjCBlockImpl>,
        )
      >
    >()
    .asFunction<
      void Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
        ffi.Pointer<objc.ObjCBlockImpl>,
      )
    >();
late final _sel_getCurrentProcessShareableContentWithCompletionHandler_ = objc
    .registerName("getCurrentProcessShareableContentWithCompletionHandler:");
late final _sel_getShareableContentExcludingDesktopWindows_onScreenWindowsOnly_completionHandler_ =
    objc.registerName(
      "getShareableContentExcludingDesktopWindows:onScreenWindowsOnly:completionHandler:",
    );
final _objc_msgSend_1dik3tq = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Bool,
          ffi.Bool,
          ffi.Pointer<objc.ObjCBlockImpl>,
        )
      >
    >()
    .asFunction<
      void Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
        bool,
        bool,
        ffi.Pointer<objc.ObjCBlockImpl>,
      )
    >();
late final _sel_getShareableContentExcludingDesktopWindows_onScreenWindowsOnlyBelowWindow_completionHandler_ =
    objc.registerName(
      "getShareableContentExcludingDesktopWindows:onScreenWindowsOnlyBelowWindow:completionHandler:",
    );
final _objc_msgSend_1oby3xk = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Bool,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCBlockImpl>,
        )
      >
    >()
    .asFunction<
      void Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
        bool,
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCBlockImpl>,
      )
    >();
late final _sel_getShareableContentExcludingDesktopWindows_onScreenWindowsOnlyAboveWindow_completionHandler_ =
    objc.registerName(
      "getShareableContentExcludingDesktopWindows:onScreenWindowsOnlyAboveWindow:completionHandler:",
    );
late final _class_SCContentFilter = objc.getClass("SCContentFilter");

enum SCStreamType {
  SCStreamTypeWindow(0),
  SCStreamTypeDisplay(1);

  final int value;
  const SCStreamType(this.value);

  static SCStreamType fromValue(int value) => switch (value) {
    0 => SCStreamTypeWindow,
    1 => SCStreamTypeDisplay,
    _ => throw ArgumentError('Unknown value for SCStreamType: $value'),
  };
}

late final _sel_streamType = objc.registerName("streamType");
final _objc_msgSend_iwlyr3 = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Long Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
        )
      >
    >()
    .asFunction<
      int Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
      )
    >();
late final _sel_style = objc.registerName("style");
final _objc_msgSend_1h6ewvo = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Long Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
        )
      >
    >()
    .asFunction<
      int Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
      )
    >();
late final _sel_pointPixelScale = objc.registerName("pointPixelScale");
final _objc_msgSend_2cgrxl = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Float Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
        )
      >
    >()
    .asFunction<
      double Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
      )
    >();
final _objc_msgSend_2cgrxlFpret = objc.msgSendFpretPointer
    .cast<
      ffi.NativeFunction<
        ffi.Float Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
        )
      >
    >()
    .asFunction<
      double Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
      )
    >();
late final _sel_contentRect = objc.registerName("contentRect");
late final _sel_includeMenuBar = objc.registerName("includeMenuBar");
late final _sel_setIncludeMenuBar_ = objc.registerName("setIncludeMenuBar:");
final _objc_msgSend_1s56lr9 = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Bool,
        )
      >
    >()
    .asFunction<
      void Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
        bool,
      )
    >();
late final _sel_includedDisplays = objc.registerName("includedDisplays");
late final _sel_includedApplications = objc.registerName(
  "includedApplications",
);
late final _sel_includedWindows = objc.registerName("includedWindows");
late final _sel_initWithDesktopIndependentWindow_ = objc.registerName(
  "initWithDesktopIndependentWindow:",
);
final _objc_msgSend_1sotr3r = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Pointer<objc.ObjCObjectImpl> Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Pointer<objc.ObjCObjectImpl>,
        )
      >
    >()
    .asFunction<
      ffi.Pointer<objc.ObjCObjectImpl> Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
        ffi.Pointer<objc.ObjCObjectImpl>,
      )
    >();
late final _sel_initWithDisplay_excludingWindows_ = objc.registerName(
  "initWithDisplay:excludingWindows:",
);
final _objc_msgSend_15qeuct = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Pointer<objc.ObjCObjectImpl> Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCObjectImpl>,
        )
      >
    >()
    .asFunction<
      ffi.Pointer<objc.ObjCObjectImpl> Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCObjectImpl>,
      )
    >();
late final _sel_initWithDisplay_includingWindows_ = objc.registerName(
  "initWithDisplay:includingWindows:",
);
late final _sel_initWithDisplay_includingApplications_exceptingWindows_ = objc
    .registerName("initWithDisplay:includingApplications:exceptingWindows:");
final _objc_msgSend_11spmsz = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Pointer<objc.ObjCObjectImpl> Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCObjectImpl>,
        )
      >
    >()
    .asFunction<
      ffi.Pointer<objc.ObjCObjectImpl> Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCObjectImpl>,
      )
    >();
late final _sel_initWithDisplay_excludingApplications_exceptingWindows_ = objc
    .registerName("initWithDisplay:excludingApplications:exceptingWindows:");

/// SCContentFilter
extension type SCContentFilter._(objc.ObjCObject object$)
    implements objc.ObjCObject, objc.NSObject {
  /// Constructs a [SCContentFilter] that points to the same underlying object as [other].
  SCContentFilter.as(objc.ObjCObject other) : object$ = other {
    objc.checkOsVersionInternal('SCContentFilter', macOS: (false, (12, 3, 0)));
    assert(isA(object$));
  }

  /// Constructs a [SCContentFilter] that wraps the given raw object pointer.
  SCContentFilter.fromPointer(
    ffi.Pointer<objc.ObjCObjectImpl> other, {
    bool retain = false,
    bool release = false,
  }) : object$ = objc.ObjCObject(other, retain: retain, release: release) {
    objc.checkOsVersionInternal('SCContentFilter', macOS: (false, (12, 3, 0)));
    assert(isA(object$));
  }

  /// Returns whether [obj] is an instance of [SCContentFilter].
  static bool isA(objc.ObjCObject obj) => _objc_msgSend_19nvye5(
    obj.ref.pointer,
    _sel_isKindOfClass_,
    _class_SCContentFilter,
  );

  /// alloc
  static SCContentFilter alloc() {
    final $ret = _objc_msgSend_151sglz(_class_SCContentFilter, _sel_alloc);
    return SCContentFilter.fromPointer($ret, retain: false, release: true);
  }

  /// allocWithZone:
  static SCContentFilter allocWithZone(ffi.Pointer<objc.NSZone> zone) {
    final $ret = _objc_msgSend_1cwp428(
      _class_SCContentFilter,
      _sel_allocWithZone_,
      zone,
    );
    return SCContentFilter.fromPointer($ret, retain: false, release: true);
  }

  /// new
  static SCContentFilter new$() {
    final $ret = _objc_msgSend_151sglz(_class_SCContentFilter, _sel_new);
    return SCContentFilter.fromPointer($ret, retain: false, release: true);
  }

  /// Returns a new instance of SCContentFilter constructed with the default `new` method.
  SCContentFilter() : this.as(new$().object$);
}

extension SCContentFilter$Methods on SCContentFilter {
  /// contentRect
  objc.CGRect get contentRect {
    objc.checkOsVersionInternal(
      'SCContentFilter.contentRect',
      macOS: (false, (14, 0, 0)),
    );
    final $ptr = pkg_ffi.calloc<objc.CGRect>();
    objc.useMsgSendVariants
        ? _objc_msgSend_bu1hbwStret($ptr, object$.ref.pointer, _sel_contentRect)
        : $ptr.ref = _objc_msgSend_bu1hbw(
            object$.ref.pointer,
            _sel_contentRect,
          );
    final $finalizable = $ptr.cast<ffi.Uint8>().asTypedList(
      ffi.sizeOf<objc.CGRect>(),
      finalizer: pkg_ffi.calloc.nativeFree,
    );
    return ffi.Struct.create<objc.CGRect>($finalizable);
  }

  /// includeMenuBar
  bool get includeMenuBar {
    objc.checkOsVersionInternal(
      'SCContentFilter.includeMenuBar',
      macOS: (false, (14, 2, 0)),
    );
    return _objc_msgSend_91o635(object$.ref.pointer, _sel_includeMenuBar);
  }

  /// includedApplications
  objc.NSArray get includedApplications {
    objc.checkOsVersionInternal(
      'SCContentFilter.includedApplications',
      macOS: (false, (15, 2, 0)),
    );
    final $ret = _objc_msgSend_151sglz(
      object$.ref.pointer,
      _sel_includedApplications,
    );
    return objc.NSArray.fromPointer($ret, retain: true, release: true);
  }

  /// includedDisplays
  objc.NSArray get includedDisplays {
    objc.checkOsVersionInternal(
      'SCContentFilter.includedDisplays',
      macOS: (false, (15, 2, 0)),
    );
    final $ret = _objc_msgSend_151sglz(
      object$.ref.pointer,
      _sel_includedDisplays,
    );
    return objc.NSArray.fromPointer($ret, retain: true, release: true);
  }

  /// includedWindows
  objc.NSArray get includedWindows {
    objc.checkOsVersionInternal(
      'SCContentFilter.includedWindows',
      macOS: (false, (15, 2, 0)),
    );
    final $ret = _objc_msgSend_151sglz(
      object$.ref.pointer,
      _sel_includedWindows,
    );
    return objc.NSArray.fromPointer($ret, retain: true, release: true);
  }

  /// init
  SCContentFilter init() {
    objc.checkOsVersionInternal(
      'SCContentFilter.init',
      iOS: (false, (2, 0, 0)),
      macOS: (false, (10, 0, 0)),
    );
    final $ret = _objc_msgSend_151sglz(
      object$.ref.retainAndReturnPointer(),
      _sel_init,
    );
    return SCContentFilter.fromPointer($ret, retain: false, release: true);
  }

  /// initWithDesktopIndependentWindow:
  SCContentFilter initWithDesktopIndependentWindow(SCWindow window) {
    objc.checkOsVersionInternal(
      'SCContentFilter.initWithDesktopIndependentWindow:',
      macOS: (false, (12, 3, 0)),
    );
    final $ret = _objc_msgSend_1sotr3r(
      object$.ref.retainAndReturnPointer(),
      _sel_initWithDesktopIndependentWindow_,
      window.ref.pointer,
    );
    return SCContentFilter.fromPointer($ret, retain: false, release: true);
  }

  /// initWithDisplay:excludingApplications:exceptingWindows:
  SCContentFilter initWithDisplay(
    SCDisplay display, {
    required objc.NSArray excludingApplications,
    required objc.NSArray exceptingWindows,
  }) {
    objc.checkOsVersionInternal(
      'SCContentFilter.initWithDisplay:excludingApplications:exceptingWindows:',
      macOS: (false, (12, 3, 0)),
    );
    final $ret = _objc_msgSend_11spmsz(
      object$.ref.retainAndReturnPointer(),
      _sel_initWithDisplay_excludingApplications_exceptingWindows_,
      display.ref.pointer,
      excludingApplications.ref.pointer,
      exceptingWindows.ref.pointer,
    );
    return SCContentFilter.fromPointer($ret, retain: false, release: true);
  }

  /// initWithDisplay:excludingWindows:
  SCContentFilter initWithDisplay$1(
    SCDisplay display, {
    required objc.NSArray excludingWindows,
  }) {
    objc.checkOsVersionInternal(
      'SCContentFilter.initWithDisplay:excludingWindows:',
      macOS: (false, (12, 3, 0)),
    );
    final $ret = _objc_msgSend_15qeuct(
      object$.ref.retainAndReturnPointer(),
      _sel_initWithDisplay_excludingWindows_,
      display.ref.pointer,
      excludingWindows.ref.pointer,
    );
    return SCContentFilter.fromPointer($ret, retain: false, release: true);
  }

  /// initWithDisplay:includingApplications:exceptingWindows:
  SCContentFilter initWithDisplay$2(
    SCDisplay display, {
    required objc.NSArray includingApplications,
    required objc.NSArray exceptingWindows,
  }) {
    objc.checkOsVersionInternal(
      'SCContentFilter.initWithDisplay:includingApplications:exceptingWindows:',
      macOS: (false, (12, 3, 0)),
    );
    final $ret = _objc_msgSend_11spmsz(
      object$.ref.retainAndReturnPointer(),
      _sel_initWithDisplay_includingApplications_exceptingWindows_,
      display.ref.pointer,
      includingApplications.ref.pointer,
      exceptingWindows.ref.pointer,
    );
    return SCContentFilter.fromPointer($ret, retain: false, release: true);
  }

  /// initWithDisplay:includingWindows:
  SCContentFilter initWithDisplay$3(
    SCDisplay display, {
    required objc.NSArray includingWindows,
  }) {
    objc.checkOsVersionInternal(
      'SCContentFilter.initWithDisplay:includingWindows:',
      macOS: (false, (12, 3, 0)),
    );
    final $ret = _objc_msgSend_15qeuct(
      object$.ref.retainAndReturnPointer(),
      _sel_initWithDisplay_includingWindows_,
      display.ref.pointer,
      includingWindows.ref.pointer,
    );
    return SCContentFilter.fromPointer($ret, retain: false, release: true);
  }

  /// pointPixelScale
  double get pointPixelScale {
    objc.checkOsVersionInternal(
      'SCContentFilter.pointPixelScale',
      macOS: (false, (14, 0, 0)),
    );
    return objc.useMsgSendVariants
        ? _objc_msgSend_2cgrxlFpret(object$.ref.pointer, _sel_pointPixelScale)
        : _objc_msgSend_2cgrxl(object$.ref.pointer, _sel_pointPixelScale);
  }

  /// setIncludeMenuBar:
  set includeMenuBar(bool value) {
    objc.checkOsVersionInternal(
      'SCContentFilter.setIncludeMenuBar:',
      macOS: (false, (14, 2, 0)),
    );
    _objc_msgSend_1s56lr9(object$.ref.pointer, _sel_setIncludeMenuBar_, value);
  }

  /// streamType
  SCStreamType get streamType {
    objc.checkOsVersionInternal(
      'SCContentFilter.streamType',
      macOS: (false, (14, 0, 0)),
    );
    final $ret = _objc_msgSend_iwlyr3(object$.ref.pointer, _sel_streamType);
    return SCStreamType.fromValue($ret);
  }

  /// style
  SCShareableContentStyle get style {
    objc.checkOsVersionInternal(
      'SCContentFilter.style',
      macOS: (false, (14, 0, 0)),
    );
    final $ret = _objc_msgSend_1h6ewvo(object$.ref.pointer, _sel_style);
    return SCShareableContentStyle.fromValue($ret);
  }
}

late final _sel_infoForFilter_ = objc.registerName("infoForFilter:");
late final _sel_windows = objc.registerName("windows");
late final _sel_displays = objc.registerName("displays");
late final _sel_applications = objc.registerName("applications");

/// SCShareableContent
extension type SCShareableContent._(objc.ObjCObject object$)
    implements objc.ObjCObject, objc.NSObject {
  /// Constructs a [SCShareableContent] that points to the same underlying object as [other].
  SCShareableContent.as(objc.ObjCObject other) : object$ = other {
    objc.checkOsVersionInternal(
      'SCShareableContent',
      macOS: (false, (12, 3, 0)),
    );
    assert(isA(object$));
  }

  /// Constructs a [SCShareableContent] that wraps the given raw object pointer.
  SCShareableContent.fromPointer(
    ffi.Pointer<objc.ObjCObjectImpl> other, {
    bool retain = false,
    bool release = false,
  }) : object$ = objc.ObjCObject(other, retain: retain, release: release) {
    objc.checkOsVersionInternal(
      'SCShareableContent',
      macOS: (false, (12, 3, 0)),
    );
    assert(isA(object$));
  }

  /// Returns whether [obj] is an instance of [SCShareableContent].
  static bool isA(objc.ObjCObject obj) => _objc_msgSend_19nvye5(
    obj.ref.pointer,
    _sel_isKindOfClass_,
    _class_SCShareableContent,
  );

  /// alloc
  static SCShareableContent alloc() {
    final $ret = _objc_msgSend_151sglz(_class_SCShareableContent, _sel_alloc);
    return SCShareableContent.fromPointer($ret, retain: false, release: true);
  }

  /// allocWithZone:
  static SCShareableContent allocWithZone(ffi.Pointer<objc.NSZone> zone) {
    final $ret = _objc_msgSend_1cwp428(
      _class_SCShareableContent,
      _sel_allocWithZone_,
      zone,
    );
    return SCShareableContent.fromPointer($ret, retain: false, release: true);
  }

  /// getCurrentProcessShareableContentWithCompletionHandler:
  static void getCurrentProcessShareableContentWithCompletionHandler(
    objc.ObjCBlock<ffi.Void Function(SCShareableContent?, objc.NSError?)>
    completionHandler,
  ) {
    objc.checkOsVersionInternal(
      'SCShareableContent.getCurrentProcessShareableContentWithCompletionHandler:',
      macOS: (false, (14, 4, 0)),
    );
    _objc_msgSend_f167m6(
      _class_SCShareableContent,
      _sel_getCurrentProcessShareableContentWithCompletionHandler_,
      completionHandler.ref.pointer,
    );
  }

  /// getShareableContentExcludingDesktopWindows:onScreenWindowsOnly:completionHandler:
  static void getShareableContentExcludingDesktopWindows(
    bool excludeDesktopWindows, {
    required bool onScreenWindowsOnly,
    required objc.ObjCBlock<
      ffi.Void Function(SCShareableContent?, objc.NSError?)
    >
    completionHandler,
  }) {
    objc.checkOsVersionInternal(
      'SCShareableContent.getShareableContentExcludingDesktopWindows:onScreenWindowsOnly:completionHandler:',
      macOS: (false, (12, 3, 0)),
    );
    _objc_msgSend_1dik3tq(
      _class_SCShareableContent,
      _sel_getShareableContentExcludingDesktopWindows_onScreenWindowsOnly_completionHandler_,
      excludeDesktopWindows,
      onScreenWindowsOnly,
      completionHandler.ref.pointer,
    );
  }

  /// getShareableContentExcludingDesktopWindows:onScreenWindowsOnlyAboveWindow:completionHandler:
  static void getShareableContentExcludingDesktopWindows$1(
    bool excludeDesktopWindows, {
    required SCWindow onScreenWindowsOnlyAboveWindow,
    required objc.ObjCBlock<
      ffi.Void Function(SCShareableContent?, objc.NSError?)
    >
    completionHandler,
  }) {
    objc.checkOsVersionInternal(
      'SCShareableContent.getShareableContentExcludingDesktopWindows:onScreenWindowsOnlyAboveWindow:completionHandler:',
      macOS: (false, (12, 3, 0)),
    );
    _objc_msgSend_1oby3xk(
      _class_SCShareableContent,
      _sel_getShareableContentExcludingDesktopWindows_onScreenWindowsOnlyAboveWindow_completionHandler_,
      excludeDesktopWindows,
      onScreenWindowsOnlyAboveWindow.ref.pointer,
      completionHandler.ref.pointer,
    );
  }

  /// getShareableContentExcludingDesktopWindows:onScreenWindowsOnlyBelowWindow:completionHandler:
  static void getShareableContentExcludingDesktopWindows$2(
    bool excludeDesktopWindows, {
    required SCWindow onScreenWindowsOnlyBelowWindow,
    required objc.ObjCBlock<
      ffi.Void Function(SCShareableContent?, objc.NSError?)
    >
    completionHandler,
  }) {
    objc.checkOsVersionInternal(
      'SCShareableContent.getShareableContentExcludingDesktopWindows:onScreenWindowsOnlyBelowWindow:completionHandler:',
      macOS: (false, (12, 3, 0)),
    );
    _objc_msgSend_1oby3xk(
      _class_SCShareableContent,
      _sel_getShareableContentExcludingDesktopWindows_onScreenWindowsOnlyBelowWindow_completionHandler_,
      excludeDesktopWindows,
      onScreenWindowsOnlyBelowWindow.ref.pointer,
      completionHandler.ref.pointer,
    );
  }

  /// getShareableContentWithCompletionHandler:
  static void getShareableContentWithCompletionHandler(
    objc.ObjCBlock<ffi.Void Function(SCShareableContent?, objc.NSError?)>
    completionHandler,
  ) {
    objc.checkOsVersionInternal(
      'SCShareableContent.getShareableContentWithCompletionHandler:',
      macOS: (false, (12, 3, 0)),
    );
    _objc_msgSend_f167m6(
      _class_SCShareableContent,
      _sel_getShareableContentWithCompletionHandler_,
      completionHandler.ref.pointer,
    );
  }

  /// infoForFilter:
  static SCShareableContentInfo infoForFilter(SCContentFilter filter) {
    objc.checkOsVersionInternal(
      'SCShareableContent.infoForFilter:',
      macOS: (false, (14, 0, 0)),
    );
    final $ret = _objc_msgSend_1sotr3r(
      _class_SCShareableContent,
      _sel_infoForFilter_,
      filter.ref.pointer,
    );
    return SCShareableContentInfo.fromPointer(
      $ret,
      retain: true,
      release: true,
    );
  }

  /// new
  static SCShareableContent new$() {
    final $ret = _objc_msgSend_151sglz(_class_SCShareableContent, _sel_new);
    return SCShareableContent.fromPointer($ret, retain: false, release: true);
  }

  /// Returns a new instance of SCShareableContent constructed with the default `new` method.
  SCShareableContent() : this.as(new$().object$);
}

extension SCShareableContent$Methods on SCShareableContent {
  /// applications
  objc.NSArray get applications {
    objc.checkOsVersionInternal(
      'SCShareableContent.applications',
      macOS: (false, (12, 3, 0)),
    );
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_applications);
    return objc.NSArray.fromPointer($ret, retain: true, release: true);
  }

  /// displays
  objc.NSArray get displays {
    objc.checkOsVersionInternal(
      'SCShareableContent.displays',
      macOS: (false, (12, 3, 0)),
    );
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_displays);
    return objc.NSArray.fromPointer($ret, retain: true, release: true);
  }

  /// init
  SCShareableContent init() {
    objc.checkOsVersionInternal(
      'SCShareableContent.init',
      iOS: (false, (2, 0, 0)),
      macOS: (false, (10, 0, 0)),
    );
    final $ret = _objc_msgSend_151sglz(
      object$.ref.retainAndReturnPointer(),
      _sel_init,
    );
    return SCShareableContent.fromPointer($ret, retain: false, release: true);
  }

  /// windows
  objc.NSArray get windows {
    objc.checkOsVersionInternal(
      'SCShareableContent.windows',
      macOS: (false, (12, 3, 0)),
    );
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_windows);
    return objc.NSArray.fromPointer($ret, retain: true, release: true);
  }
}

sealed class CMTimeFlags {
  static const kCMTimeFlags_Valid = 1;
  static const kCMTimeFlags_HasBeenRounded = 2;
  static const kCMTimeFlags_PositiveInfinity = 4;
  static const kCMTimeFlags_NegativeInfinity = 8;
  static const kCMTimeFlags_Indefinite = 16;
  static const kCMTimeFlags_ImpliedValueFlagsMask = 28;
}

@ffi.Packed(4)
final class CMTime extends ffi.Struct {
  @ffi.Int64()
  external int value;

  @ffi.Int32()
  external int timescale;

  @ffi.Uint32()
  external int flags;

  @ffi.Int64()
  external int epoch;
}

final class opaqueCMSampleBuffer extends ffi.Opaque {}

enum SCPresenterOverlayAlertSetting {
  SCPresenterOverlayAlertSettingSystem(0),
  SCPresenterOverlayAlertSettingNever(1),
  SCPresenterOverlayAlertSettingAlways(2);

  final int value;
  const SCPresenterOverlayAlertSetting(this.value);

  static SCPresenterOverlayAlertSetting fromValue(int value) => switch (value) {
    0 => SCPresenterOverlayAlertSettingSystem,
    1 => SCPresenterOverlayAlertSettingNever,
    2 => SCPresenterOverlayAlertSettingAlways,
    _ => throw ArgumentError(
      'Unknown value for SCPresenterOverlayAlertSetting: $value',
    ),
  };
}

enum SCCaptureResolutionType {
  SCCaptureResolutionAutomatic(0),
  SCCaptureResolutionBest(1),
  SCCaptureResolutionNominal(2);

  final int value;
  const SCCaptureResolutionType(this.value);

  static SCCaptureResolutionType fromValue(int value) => switch (value) {
    0 => SCCaptureResolutionAutomatic,
    1 => SCCaptureResolutionBest,
    2 => SCCaptureResolutionNominal,
    _ => throw ArgumentError(
      'Unknown value for SCCaptureResolutionType: $value',
    ),
  };
}

enum SCCaptureDynamicRange {
  SCCaptureDynamicRangeSDR(0),
  SCCaptureDynamicRangeHDRLocalDisplay(1),
  SCCaptureDynamicRangeHDRCanonicalDisplay(2);

  final int value;
  const SCCaptureDynamicRange(this.value);

  static SCCaptureDynamicRange fromValue(int value) => switch (value) {
    0 => SCCaptureDynamicRangeSDR,
    1 => SCCaptureDynamicRangeHDRLocalDisplay,
    2 => SCCaptureDynamicRangeHDRCanonicalDisplay,
    _ => throw ArgumentError('Unknown value for SCCaptureDynamicRange: $value'),
  };
}

/// WARNING: SCStreamConfiguration is a stub. To generate bindings for this class, include
/// SCStreamConfiguration in your config's objc-interfaces list.
///
/// SCStreamConfiguration
extension type SCStreamConfiguration._(objc.ObjCObject object$)
    implements objc.ObjCObject, objc.NSObject {
  /// Constructs a [SCStreamConfiguration] that points to the same underlying object as [other].
  SCStreamConfiguration.as(objc.ObjCObject other) : object$ = other {
    objc.checkOsVersionInternal(
      'SCStreamConfiguration',
      macOS: (false, (12, 3, 0)),
    );
  }

  /// Constructs a [SCStreamConfiguration] that wraps the given raw object pointer.
  SCStreamConfiguration.fromPointer(
    ffi.Pointer<objc.ObjCObjectImpl> other, {
    bool retain = false,
    bool release = false,
  }) : object$ = objc.ObjCObject(other, retain: retain, release: release) {
    objc.checkOsVersionInternal(
      'SCStreamConfiguration',
      macOS: (false, (12, 3, 0)),
    );
  }
}

enum SCStreamConfigurationPreset {
  SCStreamConfigurationPresetCaptureHDRStreamLocalDisplay(0),
  SCStreamConfigurationPresetCaptureHDRStreamCanonicalDisplay(1),
  SCStreamConfigurationPresetCaptureHDRScreenshotLocalDisplay(2),
  SCStreamConfigurationPresetCaptureHDRScreenshotCanonicalDisplay(3),
  SCStreamConfigurationPresetCaptureHDRRecordingPreservedSDRHDR10(4);

  final int value;
  const SCStreamConfigurationPreset(this.value);

  static SCStreamConfigurationPreset fromValue(int value) => switch (value) {
    0 => SCStreamConfigurationPresetCaptureHDRStreamLocalDisplay,
    1 => SCStreamConfigurationPresetCaptureHDRStreamCanonicalDisplay,
    2 => SCStreamConfigurationPresetCaptureHDRScreenshotLocalDisplay,
    3 => SCStreamConfigurationPresetCaptureHDRScreenshotCanonicalDisplay,
    4 => SCStreamConfigurationPresetCaptureHDRRecordingPreservedSDRHDR10,
    _ => throw ArgumentError(
      'Unknown value for SCStreamConfigurationPreset: $value',
    ),
  };
}

enum SCScreenshotDisplayIntent {
  SCScreenshotDisplayIntentCanonical(0),
  SCScreenshotDisplayIntentLocal(1);

  final int value;
  const SCScreenshotDisplayIntent(this.value);

  static SCScreenshotDisplayIntent fromValue(int value) => switch (value) {
    0 => SCScreenshotDisplayIntentCanonical,
    1 => SCScreenshotDisplayIntentLocal,
    _ => throw ArgumentError(
      'Unknown value for SCScreenshotDisplayIntent: $value',
    ),
  };
}

enum SCScreenshotDynamicRange {
  SCScreenshotDynamicRangeSDR(0),
  SCScreenshotDynamicRangeHDR(1),
  SCScreenshotDynamicRangeSDRAndHDR(2);

  final int value;
  const SCScreenshotDynamicRange(this.value);

  static SCScreenshotDynamicRange fromValue(int value) => switch (value) {
    0 => SCScreenshotDynamicRangeSDR,
    1 => SCScreenshotDynamicRangeHDR,
    2 => SCScreenshotDynamicRangeSDRAndHDR,
    _ => throw ArgumentError(
      'Unknown value for SCScreenshotDynamicRange: $value',
    ),
  };
}

late final _class_SCScreenshotConfiguration = objc.getClass(
  "SCScreenshotConfiguration",
);
late final _sel_setWidth_ = objc.registerName("setWidth:");
final _objc_msgSend_4sp4xj = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Long,
        )
      >
    >()
    .asFunction<
      void Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
        int,
      )
    >();
late final _sel_setHeight_ = objc.registerName("setHeight:");
late final _sel_showsCursor = objc.registerName("showsCursor");
late final _sel_setShowsCursor_ = objc.registerName("setShowsCursor:");
late final _sel_sourceRect = objc.registerName("sourceRect");
late final _sel_setSourceRect_ = objc.registerName("setSourceRect:");
final _objc_msgSend_1okkq16 = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
          objc.CGRect,
        )
      >
    >()
    .asFunction<
      void Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
        objc.CGRect,
      )
    >();
late final _sel_destinationRect = objc.registerName("destinationRect");
late final _sel_setDestinationRect_ = objc.registerName("setDestinationRect:");
late final _sel_ignoreShadows = objc.registerName("ignoreShadows");
late final _sel_setIgnoreShadows_ = objc.registerName("setIgnoreShadows:");
late final _sel_ignoreClipping = objc.registerName("ignoreClipping");
late final _sel_setIgnoreClipping_ = objc.registerName("setIgnoreClipping:");
late final _sel_includeChildWindows = objc.registerName("includeChildWindows");
late final _sel_setIncludeChildWindows_ = objc.registerName(
  "setIncludeChildWindows:",
);
late final _sel_displayIntent = objc.registerName("displayIntent");
final _objc_msgSend_1hd3foh = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Long Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
        )
      >
    >()
    .asFunction<
      int Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
      )
    >();
late final _sel_setDisplayIntent_ = objc.registerName("setDisplayIntent:");
final _objc_msgSend_1aipfm1 = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Long,
        )
      >
    >()
    .asFunction<
      void Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
        int,
      )
    >();
late final _sel_dynamicRange = objc.registerName("dynamicRange");
final _objc_msgSend_ibmwpx = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Long Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
        )
      >
    >()
    .asFunction<
      int Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
      )
    >();
late final _sel_setDynamicRange_ = objc.registerName("setDynamicRange:");
final _objc_msgSend_1wrfi5l = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Long,
        )
      >
    >()
    .asFunction<
      void Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
        int,
      )
    >();

/// WARNING: UTType is a stub. To generate bindings for this class, include
/// UTType in your config's objc-interfaces list.
///
/// UTType
extension type UTType._(objc.ObjCObject object$)
    implements
        objc.ObjCObject,
        objc.NSObject,
        objc.NSCopying,
        objc.NSSecureCoding {
  /// Constructs a [UTType] that points to the same underlying object as [other].
  UTType.as(objc.ObjCObject other) : object$ = other {}

  /// Constructs a [UTType] that wraps the given raw object pointer.
  UTType.fromPointer(
    ffi.Pointer<objc.ObjCObjectImpl> other, {
    bool retain = false,
    bool release = false,
  }) : object$ = objc.ObjCObject(other, retain: retain, release: release) {}
}

late final _sel_contentType = objc.registerName("contentType");
late final _sel_setContentType_ = objc.registerName("setContentType:");
final _objc_msgSend_xtuoz7 = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Pointer<objc.ObjCObjectImpl>,
        )
      >
    >()
    .asFunction<
      void Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
        ffi.Pointer<objc.ObjCObjectImpl>,
      )
    >();
late final _sel_fileURL = objc.registerName("fileURL");
late final _sel_setFileURL_ = objc.registerName("setFileURL:");
late final _sel_supportedContentTypes = objc.registerName(
  "supportedContentTypes",
);

/// SCScreenshotConfiguration
extension type SCScreenshotConfiguration._(objc.ObjCObject object$)
    implements objc.ObjCObject, objc.NSObject {
  /// Constructs a [SCScreenshotConfiguration] that points to the same underlying object as [other].
  SCScreenshotConfiguration.as(objc.ObjCObject other) : object$ = other {
    assert(isA(object$));
  }

  /// Constructs a [SCScreenshotConfiguration] that wraps the given raw object pointer.
  SCScreenshotConfiguration.fromPointer(
    ffi.Pointer<objc.ObjCObjectImpl> other, {
    bool retain = false,
    bool release = false,
  }) : object$ = objc.ObjCObject(other, retain: retain, release: release) {
    assert(isA(object$));
  }

  /// Returns whether [obj] is an instance of [SCScreenshotConfiguration].
  static bool isA(objc.ObjCObject obj) => _objc_msgSend_19nvye5(
    obj.ref.pointer,
    _sel_isKindOfClass_,
    _class_SCScreenshotConfiguration,
  );

  /// alloc
  static SCScreenshotConfiguration alloc() {
    final $ret = _objc_msgSend_151sglz(
      _class_SCScreenshotConfiguration,
      _sel_alloc,
    );
    return SCScreenshotConfiguration.fromPointer(
      $ret,
      retain: false,
      release: true,
    );
  }

  /// allocWithZone:
  static SCScreenshotConfiguration allocWithZone(
    ffi.Pointer<objc.NSZone> zone,
  ) {
    final $ret = _objc_msgSend_1cwp428(
      _class_SCScreenshotConfiguration,
      _sel_allocWithZone_,
      zone,
    );
    return SCScreenshotConfiguration.fromPointer(
      $ret,
      retain: false,
      release: true,
    );
  }

  /// new
  static SCScreenshotConfiguration new$() {
    final $ret = _objc_msgSend_151sglz(
      _class_SCScreenshotConfiguration,
      _sel_new,
    );
    return SCScreenshotConfiguration.fromPointer(
      $ret,
      retain: false,
      release: true,
    );
  }

  /// supportedContentTypes
  static objc.NSArray getSupportedContentTypes() {
    final $ret = _objc_msgSend_151sglz(
      _class_SCScreenshotConfiguration,
      _sel_supportedContentTypes,
    );
    return objc.NSArray.fromPointer($ret, retain: true, release: true);
  }

  /// Returns a new instance of SCScreenshotConfiguration constructed with the default `new` method.
  SCScreenshotConfiguration() : this.as(new$().object$);
}

extension SCScreenshotConfiguration$Methods on SCScreenshotConfiguration {
  /// contentType
  UTType get contentType {
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_contentType);
    return UTType.fromPointer($ret, retain: true, release: true);
  }

  /// destinationRect
  objc.CGRect get destinationRect {
    final $ptr = pkg_ffi.calloc<objc.CGRect>();
    objc.useMsgSendVariants
        ? _objc_msgSend_bu1hbwStret(
            $ptr,
            object$.ref.pointer,
            _sel_destinationRect,
          )
        : $ptr.ref = _objc_msgSend_bu1hbw(
            object$.ref.pointer,
            _sel_destinationRect,
          );
    final $finalizable = $ptr.cast<ffi.Uint8>().asTypedList(
      ffi.sizeOf<objc.CGRect>(),
      finalizer: pkg_ffi.calloc.nativeFree,
    );
    return ffi.Struct.create<objc.CGRect>($finalizable);
  }

  /// displayIntent
  SCScreenshotDisplayIntent get displayIntent {
    final $ret = _objc_msgSend_1hd3foh(object$.ref.pointer, _sel_displayIntent);
    return SCScreenshotDisplayIntent.fromValue($ret);
  }

  /// dynamicRange
  SCScreenshotDynamicRange get dynamicRange {
    final $ret = _objc_msgSend_ibmwpx(object$.ref.pointer, _sel_dynamicRange);
    return SCScreenshotDynamicRange.fromValue($ret);
  }

  /// fileURL
  objc.NSURL? get fileURL {
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_fileURL);
    return $ret.address == 0
        ? null
        : objc.NSURL.fromPointer($ret, retain: true, release: true);
  }

  /// height
  int get height {
    return _objc_msgSend_1hz7y9r(object$.ref.pointer, _sel_height);
  }

  /// ignoreClipping
  bool get ignoreClipping {
    return _objc_msgSend_91o635(object$.ref.pointer, _sel_ignoreClipping);
  }

  /// ignoreShadows
  bool get ignoreShadows {
    return _objc_msgSend_91o635(object$.ref.pointer, _sel_ignoreShadows);
  }

  /// includeChildWindows
  bool get includeChildWindows {
    return _objc_msgSend_91o635(object$.ref.pointer, _sel_includeChildWindows);
  }

  /// init
  SCScreenshotConfiguration init() {
    objc.checkOsVersionInternal(
      'SCScreenshotConfiguration.init',
      iOS: (false, (2, 0, 0)),
      macOS: (false, (10, 0, 0)),
    );
    final $ret = _objc_msgSend_151sglz(
      object$.ref.retainAndReturnPointer(),
      _sel_init,
    );
    return SCScreenshotConfiguration.fromPointer(
      $ret,
      retain: false,
      release: true,
    );
  }

  /// setContentType:
  set contentType(UTType value) {
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_setContentType_,
      value.ref.pointer,
    );
  }

  /// setDestinationRect:
  set destinationRect(objc.CGRect value) {
    _objc_msgSend_1okkq16(object$.ref.pointer, _sel_setDestinationRect_, value);
  }

  /// setDisplayIntent:
  set displayIntent(SCScreenshotDisplayIntent value) {
    _objc_msgSend_1aipfm1(
      object$.ref.pointer,
      _sel_setDisplayIntent_,
      value.value,
    );
  }

  /// setDynamicRange:
  set dynamicRange(SCScreenshotDynamicRange value) {
    _objc_msgSend_1wrfi5l(
      object$.ref.pointer,
      _sel_setDynamicRange_,
      value.value,
    );
  }

  /// setFileURL:
  set fileURL(objc.NSURL? value) {
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_setFileURL_,
      value?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// setHeight:
  set height(int value) {
    _objc_msgSend_4sp4xj(object$.ref.pointer, _sel_setHeight_, value);
  }

  /// setIgnoreClipping:
  set ignoreClipping(bool value) {
    _objc_msgSend_1s56lr9(object$.ref.pointer, _sel_setIgnoreClipping_, value);
  }

  /// setIgnoreShadows:
  set ignoreShadows(bool value) {
    _objc_msgSend_1s56lr9(object$.ref.pointer, _sel_setIgnoreShadows_, value);
  }

  /// setIncludeChildWindows:
  set includeChildWindows(bool value) {
    _objc_msgSend_1s56lr9(
      object$.ref.pointer,
      _sel_setIncludeChildWindows_,
      value,
    );
  }

  /// setShowsCursor:
  set showsCursor(bool value) {
    _objc_msgSend_1s56lr9(object$.ref.pointer, _sel_setShowsCursor_, value);
  }

  /// setSourceRect:
  set sourceRect(objc.CGRect value) {
    _objc_msgSend_1okkq16(object$.ref.pointer, _sel_setSourceRect_, value);
  }

  /// setWidth:
  set width(int value) {
    _objc_msgSend_4sp4xj(object$.ref.pointer, _sel_setWidth_, value);
  }

  /// showsCursor
  bool get showsCursor {
    return _objc_msgSend_91o635(object$.ref.pointer, _sel_showsCursor);
  }

  /// sourceRect
  objc.CGRect get sourceRect {
    final $ptr = pkg_ffi.calloc<objc.CGRect>();
    objc.useMsgSendVariants
        ? _objc_msgSend_bu1hbwStret($ptr, object$.ref.pointer, _sel_sourceRect)
        : $ptr.ref = _objc_msgSend_bu1hbw(object$.ref.pointer, _sel_sourceRect);
    final $finalizable = $ptr.cast<ffi.Uint8>().asTypedList(
      ffi.sizeOf<objc.CGRect>(),
      finalizer: pkg_ffi.calloc.nativeFree,
    );
    return ffi.Struct.create<objc.CGRect>($finalizable);
  }

  /// width
  int get width {
    return _objc_msgSend_1hz7y9r(object$.ref.pointer, _sel_width);
  }
}

late final _class_SCScreenshotOutput = objc.getClass("SCScreenshotOutput");
late final _sel_sdrImage = objc.registerName("sdrImage");
final _objc_msgSend_y1izi1 = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Pointer<CGImage> Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
        )
      >
    >()
    .asFunction<
      ffi.Pointer<CGImage> Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
      )
    >();
late final _sel_setSdrImage_ = objc.registerName("setSdrImage:");
final _objc_msgSend_1gs4jd1 = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Pointer<CGImage>,
        )
      >
    >()
    .asFunction<
      void Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
        ffi.Pointer<CGImage>,
      )
    >();
late final _sel_hdrImage = objc.registerName("hdrImage");
late final _sel_setHdrImage_ = objc.registerName("setHdrImage:");

/// SCScreenshotOutput
extension type SCScreenshotOutput._(objc.ObjCObject object$)
    implements objc.ObjCObject, objc.NSObject {
  /// Constructs a [SCScreenshotOutput] that points to the same underlying object as [other].
  SCScreenshotOutput.as(objc.ObjCObject other) : object$ = other {
    assert(isA(object$));
  }

  /// Constructs a [SCScreenshotOutput] that wraps the given raw object pointer.
  SCScreenshotOutput.fromPointer(
    ffi.Pointer<objc.ObjCObjectImpl> other, {
    bool retain = false,
    bool release = false,
  }) : object$ = objc.ObjCObject(other, retain: retain, release: release) {
    assert(isA(object$));
  }

  /// Returns whether [obj] is an instance of [SCScreenshotOutput].
  static bool isA(objc.ObjCObject obj) => _objc_msgSend_19nvye5(
    obj.ref.pointer,
    _sel_isKindOfClass_,
    _class_SCScreenshotOutput,
  );

  /// alloc
  static SCScreenshotOutput alloc() {
    final $ret = _objc_msgSend_151sglz(_class_SCScreenshotOutput, _sel_alloc);
    return SCScreenshotOutput.fromPointer($ret, retain: false, release: true);
  }

  /// allocWithZone:
  static SCScreenshotOutput allocWithZone(ffi.Pointer<objc.NSZone> zone) {
    final $ret = _objc_msgSend_1cwp428(
      _class_SCScreenshotOutput,
      _sel_allocWithZone_,
      zone,
    );
    return SCScreenshotOutput.fromPointer($ret, retain: false, release: true);
  }

  /// new
  static SCScreenshotOutput new$() {
    final $ret = _objc_msgSend_151sglz(_class_SCScreenshotOutput, _sel_new);
    return SCScreenshotOutput.fromPointer($ret, retain: false, release: true);
  }

  /// Returns a new instance of SCScreenshotOutput constructed with the default `new` method.
  SCScreenshotOutput() : this.as(new$().object$);
}

extension SCScreenshotOutput$Methods on SCScreenshotOutput {
  /// fileURL
  objc.NSURL? get fileURL {
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_fileURL);
    return $ret.address == 0
        ? null
        : objc.NSURL.fromPointer($ret, retain: true, release: true);
  }

  /// hdrImage
  ffi.Pointer<CGImage> get hdrImage {
    return _objc_msgSend_y1izi1(object$.ref.pointer, _sel_hdrImage);
  }

  /// init
  SCScreenshotOutput init() {
    objc.checkOsVersionInternal(
      'SCScreenshotOutput.init',
      iOS: (false, (2, 0, 0)),
      macOS: (false, (10, 0, 0)),
    );
    final $ret = _objc_msgSend_151sglz(
      object$.ref.retainAndReturnPointer(),
      _sel_init,
    );
    return SCScreenshotOutput.fromPointer($ret, retain: false, release: true);
  }

  /// sdrImage
  ffi.Pointer<CGImage> get sdrImage {
    return _objc_msgSend_y1izi1(object$.ref.pointer, _sel_sdrImage);
  }

  /// setFileURL:
  set fileURL(objc.NSURL? value) {
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_setFileURL_,
      value?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// setHdrImage:
  set hdrImage(ffi.Pointer<CGImage> value) {
    _objc_msgSend_1gs4jd1(object$.ref.pointer, _sel_setHdrImage_, value);
  }

  /// setSdrImage:
  set sdrImage(ffi.Pointer<CGImage> value) {
    _objc_msgSend_1gs4jd1(object$.ref.pointer, _sel_setSdrImage_, value);
  }
}

late final _class_SCScreenshotManager = objc.getClass("SCScreenshotManager");

/// Construction methods for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<opaqueCMSampleBuffer>, objc.NSError?)>`.
abstract final class ObjCBlock_ffiVoid_CMSampleBufferRef_NSError {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<
    ffi.Void Function(ffi.Pointer<opaqueCMSampleBuffer>, objc.NSError?)
  >
  fromPointer(
    ffi.Pointer<objc.ObjCBlockImpl> pointer, {
    bool retain = false,
    bool release = false,
  }) =>
      objc.ObjCBlock<
        ffi.Void Function(ffi.Pointer<opaqueCMSampleBuffer>, objc.NSError?)
      >(pointer, retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<
    ffi.Void Function(ffi.Pointer<opaqueCMSampleBuffer>, objc.NSError?)
  >
  fromFunctionPointer(
    ffi.Pointer<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<opaqueCMSampleBuffer> arg0,
          ffi.Pointer<objc.ObjCObjectImpl> arg1,
        )
      >
    >
    ptr,
  ) =>
      objc.ObjCBlock<
        ffi.Void Function(ffi.Pointer<opaqueCMSampleBuffer>, objc.NSError?)
      >(
        objc.newPointerBlock(_fnPtrCallable, ptr.cast()),
        retain: false,
        release: true,
      );

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<
    ffi.Void Function(ffi.Pointer<opaqueCMSampleBuffer>, objc.NSError?)
  >
  fromFunction(
    void Function(ffi.Pointer<opaqueCMSampleBuffer>, objc.NSError?) fn, {
    bool keepIsolateAlive = true,
  }) =>
      objc.ObjCBlock<
        ffi.Void Function(ffi.Pointer<opaqueCMSampleBuffer>, objc.NSError?)
      >(
        objc.newClosureBlock(
          _closureCallable,
          (
            ffi.Pointer<opaqueCMSampleBuffer> arg0,
            ffi.Pointer<objc.ObjCObjectImpl> arg1,
          ) => fn(
            arg0,
            arg1.address == 0
                ? null
                : objc.NSError.fromPointer(arg1, retain: true, release: true),
          ),
          keepIsolateAlive,
        ),
        retain: false,
        release: true,
      );

  /// Creates a listener block from a Dart function.
  ///
  /// This is based on FFI's NativeCallable.listener, and has the same
  /// capabilities and limitations. This block can be invoked from any thread,
  /// but only supports void functions, and is not run synchronously. See
  /// NativeCallable.listener for more details.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<
    ffi.Void Function(ffi.Pointer<opaqueCMSampleBuffer>, objc.NSError?)
  >
  listener(
    void Function(ffi.Pointer<opaqueCMSampleBuffer>, objc.NSError?) fn, {
    bool keepIsolateAlive = true,
  }) {
    final raw = objc.newClosureBlock(
      _listenerCallable.nativeFunction.cast(),
      (
        ffi.Pointer<opaqueCMSampleBuffer> arg0,
        ffi.Pointer<objc.ObjCObjectImpl> arg1,
      ) => fn(
        arg0,
        arg1.address == 0
            ? null
            : objc.NSError.fromPointer(arg1, retain: false, release: true),
      ),
      keepIsolateAlive,
    );
    final wrapper = _NativeLibrary_wrapListenerBlock_ro4zln(raw);
    objc.objectRelease(raw.cast());
    return objc.ObjCBlock<
      ffi.Void Function(ffi.Pointer<opaqueCMSampleBuffer>, objc.NSError?)
    >(wrapper, retain: false, release: true);
  }

  /// Creates a blocking block from a Dart function.
  ///
  /// This callback can be invoked from any native thread, and will block the
  /// caller until the callback is handled by the Dart isolate that created
  /// the block. Async functions are not supported.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC. If the owner isolate
  /// has shut down, and the block is invoked by native code, it may block
  /// indefinitely, or have other undefined behavior.
  static objc.ObjCBlock<
    ffi.Void Function(ffi.Pointer<opaqueCMSampleBuffer>, objc.NSError?)
  >
  blocking(
    void Function(ffi.Pointer<opaqueCMSampleBuffer>, objc.NSError?) fn, {
    bool keepIsolateAlive = true,
  }) {
    final raw = objc.newClosureBlock(
      _blockingCallable.nativeFunction.cast(),
      (
        ffi.Pointer<opaqueCMSampleBuffer> arg0,
        ffi.Pointer<objc.ObjCObjectImpl> arg1,
      ) => fn(
        arg0,
        arg1.address == 0
            ? null
            : objc.NSError.fromPointer(arg1, retain: false, release: true),
      ),
      keepIsolateAlive,
    );
    final rawListener = objc.newClosureBlock(
      _blockingListenerCallable.nativeFunction.cast(),
      (
        ffi.Pointer<opaqueCMSampleBuffer> arg0,
        ffi.Pointer<objc.ObjCObjectImpl> arg1,
      ) => fn(
        arg0,
        arg1.address == 0
            ? null
            : objc.NSError.fromPointer(arg1, retain: false, release: true),
      ),
      keepIsolateAlive,
    );
    final wrapper = _NativeLibrary_wrapBlockingBlock_ro4zln(
      raw,
      rawListener,
      objc.objCContext,
    );
    objc.objectRelease(raw.cast());
    objc.objectRelease(rawListener.cast());
    return objc.ObjCBlock<
      ffi.Void Function(ffi.Pointer<opaqueCMSampleBuffer>, objc.NSError?)
    >(wrapper, retain: false, release: true);
  }

  static void _listenerTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<opaqueCMSampleBuffer> arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
  ) {
    (objc.getBlockClosure(block)
        as void Function(
          ffi.Pointer<opaqueCMSampleBuffer>,
          ffi.Pointer<objc.ObjCObjectImpl>,
        ))(arg0, arg1);
    objc.objectRelease(block.cast());
  }

  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<opaqueCMSampleBuffer>,
      ffi.Pointer<objc.ObjCObjectImpl>,
    )
  >
  _listenerCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<opaqueCMSampleBuffer>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          )
        >.listener(_listenerTrampoline)
        ..keepIsolateAlive = false;
  static void _blockingTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> waiter,
    ffi.Pointer<opaqueCMSampleBuffer> arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
  ) {
    try {
      (objc.getBlockClosure(block)
          as void Function(
            ffi.Pointer<opaqueCMSampleBuffer>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          ))(arg0, arg1);
    } catch (e) {
    } finally {
      objc.signalWaiter(waiter);
      objc.objectRelease(block.cast());
    }
  }

  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<opaqueCMSampleBuffer>,
      ffi.Pointer<objc.ObjCObjectImpl>,
    )
  >
  _blockingCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<opaqueCMSampleBuffer>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          )
        >.isolateLocal(_blockingTrampoline)
        ..keepIsolateAlive = false;
  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<opaqueCMSampleBuffer>,
      ffi.Pointer<objc.ObjCObjectImpl>,
    )
  >
  _blockingListenerCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<opaqueCMSampleBuffer>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          )
        >.listener(_blockingTrampoline)
        ..keepIsolateAlive = false;
  static void _fnPtrTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<opaqueCMSampleBuffer> arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
  ) => block.ref.target
      .cast<
        ffi.NativeFunction<
          ffi.Void Function(
            ffi.Pointer<opaqueCMSampleBuffer> arg0,
            ffi.Pointer<objc.ObjCObjectImpl> arg1,
          )
        >
      >()
      .asFunction<
        void Function(
          ffi.Pointer<opaqueCMSampleBuffer>,
          ffi.Pointer<objc.ObjCObjectImpl>,
        )
      >()(arg0, arg1);
  static ffi.Pointer<ffi.Void> _fnPtrCallable =
      ffi.Pointer.fromFunction<
            ffi.Void Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<opaqueCMSampleBuffer>,
              ffi.Pointer<objc.ObjCObjectImpl>,
            )
          >(_fnPtrTrampoline)
          .cast();
  static void _closureTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<opaqueCMSampleBuffer> arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
  ) =>
      (objc.getBlockClosure(block)
          as void Function(
            ffi.Pointer<opaqueCMSampleBuffer>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          ))(arg0, arg1);
  static ffi.Pointer<ffi.Void> _closureCallable =
      ffi.Pointer.fromFunction<
            ffi.Void Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<opaqueCMSampleBuffer>,
              ffi.Pointer<objc.ObjCObjectImpl>,
            )
          >(_closureTrampoline)
          .cast();
}

/// Call operator for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<opaqueCMSampleBuffer>, objc.NSError?)>`.
extension ObjCBlock_ffiVoid_CMSampleBufferRef_NSError$CallExtension
    on
        objc.ObjCBlock<
          ffi.Void Function(ffi.Pointer<opaqueCMSampleBuffer>, objc.NSError?)
        > {
  void call(ffi.Pointer<opaqueCMSampleBuffer> arg0, objc.NSError? arg1) => ref
      .pointer
      .ref
      .invoke
      .cast<
        ffi.NativeFunction<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl> block,
            ffi.Pointer<opaqueCMSampleBuffer> arg0,
            ffi.Pointer<objc.ObjCObjectImpl> arg1,
          )
        >
      >()
      .asFunction<
        void Function(
          ffi.Pointer<objc.ObjCBlockImpl>,
          ffi.Pointer<opaqueCMSampleBuffer>,
          ffi.Pointer<objc.ObjCObjectImpl>,
        )
      >()(ref.pointer, arg0, arg1?.ref.pointer ?? ffi.nullptr);
}

late final _sel_captureSampleBufferWithFilter_configuration_completionHandler_ =
    objc.registerName(
      "captureSampleBufferWithFilter:configuration:completionHandler:",
    );
final _objc_msgSend_18qun1e = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCBlockImpl>,
        )
      >
    >()
    .asFunction<
      void Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCBlockImpl>,
      )
    >();

/// Construction methods for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<CGImage>, objc.NSError?)>`.
abstract final class ObjCBlock_ffiVoid_CGImageRef_NSError {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<CGImage>, objc.NSError?)>
  fromPointer(
    ffi.Pointer<objc.ObjCBlockImpl> pointer, {
    bool retain = false,
    bool release = false,
  }) => objc.ObjCBlock<ffi.Void Function(ffi.Pointer<CGImage>, objc.NSError?)>(
    pointer,
    retain: retain,
    release: release,
  );

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<CGImage>, objc.NSError?)>
  fromFunctionPointer(
    ffi.Pointer<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<CGImage> arg0,
          ffi.Pointer<objc.ObjCObjectImpl> arg1,
        )
      >
    >
    ptr,
  ) => objc.ObjCBlock<ffi.Void Function(ffi.Pointer<CGImage>, objc.NSError?)>(
    objc.newPointerBlock(_fnPtrCallable, ptr.cast()),
    retain: false,
    release: true,
  );

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<CGImage>, objc.NSError?)>
  fromFunction(
    void Function(ffi.Pointer<CGImage>, objc.NSError?) fn, {
    bool keepIsolateAlive = true,
  }) => objc.ObjCBlock<ffi.Void Function(ffi.Pointer<CGImage>, objc.NSError?)>(
    objc.newClosureBlock(
      _closureCallable,
      (ffi.Pointer<CGImage> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1) => fn(
        arg0,
        arg1.address == 0
            ? null
            : objc.NSError.fromPointer(arg1, retain: true, release: true),
      ),
      keepIsolateAlive,
    ),
    retain: false,
    release: true,
  );

  /// Creates a listener block from a Dart function.
  ///
  /// This is based on FFI's NativeCallable.listener, and has the same
  /// capabilities and limitations. This block can be invoked from any thread,
  /// but only supports void functions, and is not run synchronously. See
  /// NativeCallable.listener for more details.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<CGImage>, objc.NSError?)>
  listener(
    void Function(ffi.Pointer<CGImage>, objc.NSError?) fn, {
    bool keepIsolateAlive = true,
  }) {
    final raw = objc.newClosureBlock(
      _listenerCallable.nativeFunction.cast(),
      (ffi.Pointer<CGImage> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1) => fn(
        arg0,
        arg1.address == 0
            ? null
            : objc.NSError.fromPointer(arg1, retain: false, release: true),
      ),
      keepIsolateAlive,
    );
    final wrapper = _NativeLibrary_wrapListenerBlock_19ugjh7(raw);
    objc.objectRelease(raw.cast());
    return objc.ObjCBlock<
      ffi.Void Function(ffi.Pointer<CGImage>, objc.NSError?)
    >(wrapper, retain: false, release: true);
  }

  /// Creates a blocking block from a Dart function.
  ///
  /// This callback can be invoked from any native thread, and will block the
  /// caller until the callback is handled by the Dart isolate that created
  /// the block. Async functions are not supported.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC. If the owner isolate
  /// has shut down, and the block is invoked by native code, it may block
  /// indefinitely, or have other undefined behavior.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<CGImage>, objc.NSError?)>
  blocking(
    void Function(ffi.Pointer<CGImage>, objc.NSError?) fn, {
    bool keepIsolateAlive = true,
  }) {
    final raw = objc.newClosureBlock(
      _blockingCallable.nativeFunction.cast(),
      (ffi.Pointer<CGImage> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1) => fn(
        arg0,
        arg1.address == 0
            ? null
            : objc.NSError.fromPointer(arg1, retain: false, release: true),
      ),
      keepIsolateAlive,
    );
    final rawListener = objc.newClosureBlock(
      _blockingListenerCallable.nativeFunction.cast(),
      (ffi.Pointer<CGImage> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1) => fn(
        arg0,
        arg1.address == 0
            ? null
            : objc.NSError.fromPointer(arg1, retain: false, release: true),
      ),
      keepIsolateAlive,
    );
    final wrapper = _NativeLibrary_wrapBlockingBlock_19ugjh7(
      raw,
      rawListener,
      objc.objCContext,
    );
    objc.objectRelease(raw.cast());
    objc.objectRelease(rawListener.cast());
    return objc.ObjCBlock<
      ffi.Void Function(ffi.Pointer<CGImage>, objc.NSError?)
    >(wrapper, retain: false, release: true);
  }

  static void _listenerTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<CGImage> arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
  ) {
    (objc.getBlockClosure(block)
        as void Function(
          ffi.Pointer<CGImage>,
          ffi.Pointer<objc.ObjCObjectImpl>,
        ))(arg0, arg1);
    objc.objectRelease(block.cast());
  }

  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<CGImage>,
      ffi.Pointer<objc.ObjCObjectImpl>,
    )
  >
  _listenerCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<CGImage>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          )
        >.listener(_listenerTrampoline)
        ..keepIsolateAlive = false;
  static void _blockingTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> waiter,
    ffi.Pointer<CGImage> arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
  ) {
    try {
      (objc.getBlockClosure(block)
          as void Function(
            ffi.Pointer<CGImage>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          ))(arg0, arg1);
    } catch (e) {
    } finally {
      objc.signalWaiter(waiter);
      objc.objectRelease(block.cast());
    }
  }

  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<CGImage>,
      ffi.Pointer<objc.ObjCObjectImpl>,
    )
  >
  _blockingCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<CGImage>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          )
        >.isolateLocal(_blockingTrampoline)
        ..keepIsolateAlive = false;
  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<CGImage>,
      ffi.Pointer<objc.ObjCObjectImpl>,
    )
  >
  _blockingListenerCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<CGImage>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          )
        >.listener(_blockingTrampoline)
        ..keepIsolateAlive = false;
  static void _fnPtrTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<CGImage> arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
  ) => block.ref.target
      .cast<
        ffi.NativeFunction<
          ffi.Void Function(
            ffi.Pointer<CGImage> arg0,
            ffi.Pointer<objc.ObjCObjectImpl> arg1,
          )
        >
      >()
      .asFunction<
        void Function(ffi.Pointer<CGImage>, ffi.Pointer<objc.ObjCObjectImpl>)
      >()(arg0, arg1);
  static ffi.Pointer<ffi.Void> _fnPtrCallable =
      ffi.Pointer.fromFunction<
            ffi.Void Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<CGImage>,
              ffi.Pointer<objc.ObjCObjectImpl>,
            )
          >(_fnPtrTrampoline)
          .cast();
  static void _closureTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<CGImage> arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
  ) =>
      (objc.getBlockClosure(block)
          as void Function(
            ffi.Pointer<CGImage>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          ))(arg0, arg1);
  static ffi.Pointer<ffi.Void> _closureCallable =
      ffi.Pointer.fromFunction<
            ffi.Void Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<CGImage>,
              ffi.Pointer<objc.ObjCObjectImpl>,
            )
          >(_closureTrampoline)
          .cast();
}

/// Call operator for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<CGImage>, objc.NSError?)>`.
extension ObjCBlock_ffiVoid_CGImageRef_NSError$CallExtension
    on objc.ObjCBlock<ffi.Void Function(ffi.Pointer<CGImage>, objc.NSError?)> {
  void call(ffi.Pointer<CGImage> arg0, objc.NSError? arg1) => ref
      .pointer
      .ref
      .invoke
      .cast<
        ffi.NativeFunction<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl> block,
            ffi.Pointer<CGImage> arg0,
            ffi.Pointer<objc.ObjCObjectImpl> arg1,
          )
        >
      >()
      .asFunction<
        void Function(
          ffi.Pointer<objc.ObjCBlockImpl>,
          ffi.Pointer<CGImage>,
          ffi.Pointer<objc.ObjCObjectImpl>,
        )
      >()(ref.pointer, arg0, arg1?.ref.pointer ?? ffi.nullptr);
}

late final _sel_captureImageWithFilter_configuration_completionHandler_ = objc
    .registerName("captureImageWithFilter:configuration:completionHandler:");
late final _sel_captureImageInRect_completionHandler_ = objc.registerName(
  "captureImageInRect:completionHandler:",
);
final _objc_msgSend_1ekrzmp = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
          objc.CGRect,
          ffi.Pointer<objc.ObjCBlockImpl>,
        )
      >
    >()
    .asFunction<
      void Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
        objc.CGRect,
        ffi.Pointer<objc.ObjCBlockImpl>,
      )
    >();

/// Construction methods for `objc.ObjCBlock<ffi.Void Function(SCScreenshotOutput?, objc.NSError?)>`.
abstract final class ObjCBlock_ffiVoid_SCScreenshotOutput_NSError {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<ffi.Void Function(SCScreenshotOutput?, objc.NSError?)>
  fromPointer(
    ffi.Pointer<objc.ObjCBlockImpl> pointer, {
    bool retain = false,
    bool release = false,
  }) => objc.ObjCBlock<ffi.Void Function(SCScreenshotOutput?, objc.NSError?)>(
    pointer,
    retain: retain,
    release: release,
  );

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<ffi.Void Function(SCScreenshotOutput?, objc.NSError?)>
  fromFunctionPointer(
    ffi.Pointer<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<objc.ObjCObjectImpl> arg0,
          ffi.Pointer<objc.ObjCObjectImpl> arg1,
        )
      >
    >
    ptr,
  ) => objc.ObjCBlock<ffi.Void Function(SCScreenshotOutput?, objc.NSError?)>(
    objc.newPointerBlock(_fnPtrCallable, ptr.cast()),
    retain: false,
    release: true,
  );

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Void Function(SCScreenshotOutput?, objc.NSError?)>
  fromFunction(
    void Function(SCScreenshotOutput?, objc.NSError?) fn, {
    bool keepIsolateAlive = true,
  }) => objc.ObjCBlock<ffi.Void Function(SCScreenshotOutput?, objc.NSError?)>(
    objc.newClosureBlock(
      _closureCallable,
      (
        ffi.Pointer<objc.ObjCObjectImpl> arg0,
        ffi.Pointer<objc.ObjCObjectImpl> arg1,
      ) => fn(
        arg0.address == 0
            ? null
            : SCScreenshotOutput.fromPointer(arg0, retain: true, release: true),
        arg1.address == 0
            ? null
            : objc.NSError.fromPointer(arg1, retain: true, release: true),
      ),
      keepIsolateAlive,
    ),
    retain: false,
    release: true,
  );

  /// Creates a listener block from a Dart function.
  ///
  /// This is based on FFI's NativeCallable.listener, and has the same
  /// capabilities and limitations. This block can be invoked from any thread,
  /// but only supports void functions, and is not run synchronously. See
  /// NativeCallable.listener for more details.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Void Function(SCScreenshotOutput?, objc.NSError?)>
  listener(
    void Function(SCScreenshotOutput?, objc.NSError?) fn, {
    bool keepIsolateAlive = true,
  }) {
    final raw = objc.newClosureBlock(
      _listenerCallable.nativeFunction.cast(),
      (
        ffi.Pointer<objc.ObjCObjectImpl> arg0,
        ffi.Pointer<objc.ObjCObjectImpl> arg1,
      ) => fn(
        arg0.address == 0
            ? null
            : SCScreenshotOutput.fromPointer(
                arg0,
                retain: false,
                release: true,
              ),
        arg1.address == 0
            ? null
            : objc.NSError.fromPointer(arg1, retain: false, release: true),
      ),
      keepIsolateAlive,
    );
    final wrapper = _NativeLibrary_wrapListenerBlock_pfv6jd(raw);
    objc.objectRelease(raw.cast());
    return objc.ObjCBlock<
      ffi.Void Function(SCScreenshotOutput?, objc.NSError?)
    >(wrapper, retain: false, release: true);
  }

  /// Creates a blocking block from a Dart function.
  ///
  /// This callback can be invoked from any native thread, and will block the
  /// caller until the callback is handled by the Dart isolate that created
  /// the block. Async functions are not supported.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC. If the owner isolate
  /// has shut down, and the block is invoked by native code, it may block
  /// indefinitely, or have other undefined behavior.
  static objc.ObjCBlock<ffi.Void Function(SCScreenshotOutput?, objc.NSError?)>
  blocking(
    void Function(SCScreenshotOutput?, objc.NSError?) fn, {
    bool keepIsolateAlive = true,
  }) {
    final raw = objc.newClosureBlock(
      _blockingCallable.nativeFunction.cast(),
      (
        ffi.Pointer<objc.ObjCObjectImpl> arg0,
        ffi.Pointer<objc.ObjCObjectImpl> arg1,
      ) => fn(
        arg0.address == 0
            ? null
            : SCScreenshotOutput.fromPointer(
                arg0,
                retain: false,
                release: true,
              ),
        arg1.address == 0
            ? null
            : objc.NSError.fromPointer(arg1, retain: false, release: true),
      ),
      keepIsolateAlive,
    );
    final rawListener = objc.newClosureBlock(
      _blockingListenerCallable.nativeFunction.cast(),
      (
        ffi.Pointer<objc.ObjCObjectImpl> arg0,
        ffi.Pointer<objc.ObjCObjectImpl> arg1,
      ) => fn(
        arg0.address == 0
            ? null
            : SCScreenshotOutput.fromPointer(
                arg0,
                retain: false,
                release: true,
              ),
        arg1.address == 0
            ? null
            : objc.NSError.fromPointer(arg1, retain: false, release: true),
      ),
      keepIsolateAlive,
    );
    final wrapper = _NativeLibrary_wrapBlockingBlock_pfv6jd(
      raw,
      rawListener,
      objc.objCContext,
    );
    objc.objectRelease(raw.cast());
    objc.objectRelease(rawListener.cast());
    return objc.ObjCBlock<
      ffi.Void Function(SCScreenshotOutput?, objc.NSError?)
    >(wrapper, retain: false, release: true);
  }

  static void _listenerTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<objc.ObjCObjectImpl> arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
  ) {
    (objc.getBlockClosure(block)
        as void Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCObjectImpl>,
        ))(arg0, arg1);
    objc.objectRelease(block.cast());
  }

  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<objc.ObjCObjectImpl>,
      ffi.Pointer<objc.ObjCObjectImpl>,
    )
  >
  _listenerCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          )
        >.listener(_listenerTrampoline)
        ..keepIsolateAlive = false;
  static void _blockingTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> waiter,
    ffi.Pointer<objc.ObjCObjectImpl> arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
  ) {
    try {
      (objc.getBlockClosure(block)
          as void Function(
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          ))(arg0, arg1);
    } catch (e) {
    } finally {
      objc.signalWaiter(waiter);
      objc.objectRelease(block.cast());
    }
  }

  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<objc.ObjCObjectImpl>,
      ffi.Pointer<objc.ObjCObjectImpl>,
    )
  >
  _blockingCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          )
        >.isolateLocal(_blockingTrampoline)
        ..keepIsolateAlive = false;
  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<objc.ObjCObjectImpl>,
      ffi.Pointer<objc.ObjCObjectImpl>,
    )
  >
  _blockingListenerCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          )
        >.listener(_blockingTrampoline)
        ..keepIsolateAlive = false;
  static void _fnPtrTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<objc.ObjCObjectImpl> arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
  ) => block.ref.target
      .cast<
        ffi.NativeFunction<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCObjectImpl> arg0,
            ffi.Pointer<objc.ObjCObjectImpl> arg1,
          )
        >
      >()
      .asFunction<
        void Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCObjectImpl>,
        )
      >()(arg0, arg1);
  static ffi.Pointer<ffi.Void> _fnPtrCallable =
      ffi.Pointer.fromFunction<
            ffi.Void Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<objc.ObjCObjectImpl>,
              ffi.Pointer<objc.ObjCObjectImpl>,
            )
          >(_fnPtrTrampoline)
          .cast();
  static void _closureTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<objc.ObjCObjectImpl> arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
  ) =>
      (objc.getBlockClosure(block)
          as void Function(
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          ))(arg0, arg1);
  static ffi.Pointer<ffi.Void> _closureCallable =
      ffi.Pointer.fromFunction<
            ffi.Void Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<objc.ObjCObjectImpl>,
              ffi.Pointer<objc.ObjCObjectImpl>,
            )
          >(_closureTrampoline)
          .cast();
}

/// Call operator for `objc.ObjCBlock<ffi.Void Function(SCScreenshotOutput?, objc.NSError?)>`.
extension ObjCBlock_ffiVoid_SCScreenshotOutput_NSError$CallExtension
    on objc.ObjCBlock<ffi.Void Function(SCScreenshotOutput?, objc.NSError?)> {
  void call(SCScreenshotOutput? arg0, objc.NSError? arg1) =>
      ref.pointer.ref.invoke
          .cast<
            ffi.NativeFunction<
              ffi.Void Function(
                ffi.Pointer<objc.ObjCBlockImpl> block,
                ffi.Pointer<objc.ObjCObjectImpl> arg0,
                ffi.Pointer<objc.ObjCObjectImpl> arg1,
              )
            >
          >()
          .asFunction<
            void Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<objc.ObjCObjectImpl>,
              ffi.Pointer<objc.ObjCObjectImpl>,
            )
          >()(
        ref.pointer,
        arg0?.ref.pointer ?? ffi.nullptr,
        arg1?.ref.pointer ?? ffi.nullptr,
      );
}

late final _sel_captureScreenshotWithFilter_configuration_completionHandler_ =
    objc.registerName(
      "captureScreenshotWithFilter:configuration:completionHandler:",
    );
late final _sel_captureScreenshotWithRect_configuration_completionHandler_ =
    objc.registerName(
      "captureScreenshotWithRect:configuration:completionHandler:",
    );
final _objc_msgSend_4u48uz = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
          objc.CGRect,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCBlockImpl>,
        )
      >
    >()
    .asFunction<
      void Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
        objc.CGRect,
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCBlockImpl>,
      )
    >();

/// SCScreenshotManager
extension type SCScreenshotManager._(objc.ObjCObject object$)
    implements objc.ObjCObject, objc.NSObject {
  /// Constructs a [SCScreenshotManager] that points to the same underlying object as [other].
  SCScreenshotManager.as(objc.ObjCObject other) : object$ = other {
    objc.checkOsVersionInternal(
      'SCScreenshotManager',
      macOS: (false, (14, 0, 0)),
    );
    assert(isA(object$));
  }

  /// Constructs a [SCScreenshotManager] that wraps the given raw object pointer.
  SCScreenshotManager.fromPointer(
    ffi.Pointer<objc.ObjCObjectImpl> other, {
    bool retain = false,
    bool release = false,
  }) : object$ = objc.ObjCObject(other, retain: retain, release: release) {
    objc.checkOsVersionInternal(
      'SCScreenshotManager',
      macOS: (false, (14, 0, 0)),
    );
    assert(isA(object$));
  }

  /// Returns whether [obj] is an instance of [SCScreenshotManager].
  static bool isA(objc.ObjCObject obj) => _objc_msgSend_19nvye5(
    obj.ref.pointer,
    _sel_isKindOfClass_,
    _class_SCScreenshotManager,
  );

  /// alloc
  static SCScreenshotManager alloc() {
    final $ret = _objc_msgSend_151sglz(_class_SCScreenshotManager, _sel_alloc);
    return SCScreenshotManager.fromPointer($ret, retain: false, release: true);
  }

  /// allocWithZone:
  static SCScreenshotManager allocWithZone(ffi.Pointer<objc.NSZone> zone) {
    final $ret = _objc_msgSend_1cwp428(
      _class_SCScreenshotManager,
      _sel_allocWithZone_,
      zone,
    );
    return SCScreenshotManager.fromPointer($ret, retain: false, release: true);
  }

  /// captureImageInRect:completionHandler:
  static void captureImageInRect(
    objc.CGRect rect, {
    objc.ObjCBlock<ffi.Void Function(ffi.Pointer<CGImage>, objc.NSError?)>?
    completionHandler,
  }) {
    objc.checkOsVersionInternal(
      'SCScreenshotManager.captureImageInRect:completionHandler:',
      macOS: (false, (15, 2, 0)),
    );
    _objc_msgSend_1ekrzmp(
      _class_SCScreenshotManager,
      _sel_captureImageInRect_completionHandler_,
      rect,
      completionHandler?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// captureImageWithFilter:configuration:completionHandler:
  static void captureImageWithFilter(
    SCContentFilter contentFilter, {
    required SCStreamConfiguration configuration,
    objc.ObjCBlock<ffi.Void Function(ffi.Pointer<CGImage>, objc.NSError?)>?
    completionHandler,
  }) {
    objc.checkOsVersionInternal(
      'SCScreenshotManager.captureImageWithFilter:configuration:completionHandler:',
      macOS: (false, (14, 0, 0)),
    );
    _objc_msgSend_18qun1e(
      _class_SCScreenshotManager,
      _sel_captureImageWithFilter_configuration_completionHandler_,
      contentFilter.ref.pointer,
      configuration.ref.pointer,
      completionHandler?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// captureSampleBufferWithFilter:configuration:completionHandler:
  static void captureSampleBufferWithFilter(
    SCContentFilter contentFilter, {
    required SCStreamConfiguration configuration,
    objc.ObjCBlock<
      ffi.Void Function(ffi.Pointer<opaqueCMSampleBuffer>, objc.NSError?)
    >?
    completionHandler,
  }) {
    objc.checkOsVersionInternal(
      'SCScreenshotManager.captureSampleBufferWithFilter:configuration:completionHandler:',
      macOS: (false, (14, 0, 0)),
    );
    _objc_msgSend_18qun1e(
      _class_SCScreenshotManager,
      _sel_captureSampleBufferWithFilter_configuration_completionHandler_,
      contentFilter.ref.pointer,
      configuration.ref.pointer,
      completionHandler?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// captureScreenshotWithFilter:configuration:completionHandler:
  static void captureScreenshotWithFilter(
    SCContentFilter contentFilter, {
    required SCScreenshotConfiguration configuration,
    objc.ObjCBlock<ffi.Void Function(SCScreenshotOutput?, objc.NSError?)>?
    completionHandler,
  }) {
    objc.checkOsVersionInternal(
      'SCScreenshotManager.captureScreenshotWithFilter:configuration:completionHandler:',
      macOS: (false, (26, 0, 0)),
    );
    _objc_msgSend_18qun1e(
      _class_SCScreenshotManager,
      _sel_captureScreenshotWithFilter_configuration_completionHandler_,
      contentFilter.ref.pointer,
      configuration.ref.pointer,
      completionHandler?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// captureScreenshotWithRect:configuration:completionHandler:
  static void captureScreenshotWithRect(
    objc.CGRect rect, {
    required SCScreenshotConfiguration configuration,
    objc.ObjCBlock<ffi.Void Function(SCScreenshotOutput?, objc.NSError?)>?
    completionHandler,
  }) {
    objc.checkOsVersionInternal(
      'SCScreenshotManager.captureScreenshotWithRect:configuration:completionHandler:',
      macOS: (false, (26, 0, 0)),
    );
    _objc_msgSend_4u48uz(
      _class_SCScreenshotManager,
      _sel_captureScreenshotWithRect_configuration_completionHandler_,
      rect,
      configuration.ref.pointer,
      completionHandler?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// new
  static SCScreenshotManager new$() {
    final $ret = _objc_msgSend_151sglz(_class_SCScreenshotManager, _sel_new);
    return SCScreenshotManager.fromPointer($ret, retain: false, release: true);
  }

  /// Returns a new instance of SCScreenshotManager constructed with the default `new` method.
  SCScreenshotManager() : this.as(new$().object$);
}

extension SCScreenshotManager$Methods on SCScreenshotManager {
  /// init
  SCScreenshotManager init() {
    objc.checkOsVersionInternal(
      'SCScreenshotManager.init',
      iOS: (false, (2, 0, 0)),
      macOS: (false, (10, 0, 0)),
    );
    final $ret = _objc_msgSend_151sglz(
      object$.ref.retainAndReturnPointer(),
      _sel_init,
    );
    return SCScreenshotManager.fromPointer($ret, retain: false, release: true);
  }
}
