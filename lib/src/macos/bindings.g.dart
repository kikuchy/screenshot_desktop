// AUTO GENERATED FILE, DO NOT EDIT.
//
// Generated by `package:ffigen`.
// ignore_for_file: type=lint, unused_import
import 'dart:ffi' as ffi;
import 'package:objective_c/objective_c.dart' as objc;
import 'package:ffi/ffi.dart' as pkg_ffi;

@ffi.Native<ffi.Void Function(ffi.Pointer<ffi.Void>)>()
external void CFRelease(ffi.Pointer<ffi.Void> cf);

@ffi.Native<
  ffi.Pointer<__CFData> Function(ffi.Pointer<__CFAllocator>, ffi.Long)
>()
external ffi.Pointer<__CFData> CFDataCreateMutable(
  ffi.Pointer<__CFAllocator> allocator,
  int capacity,
);

@ffi.Native<ffi.Long Function(ffi.Pointer<__CFData>)>()
external int CFDataGetLength(ffi.Pointer<__CFData> theData);

@ffi.Native<ffi.Pointer<ffi.UnsignedChar> Function(ffi.Pointer<__CFData>)>()
external ffi.Pointer<ffi.UnsignedChar> CFDataGetBytePtr(
  ffi.Pointer<__CFData> theData,
);

@ffi.Native<ffi.Pointer<objc.CFString>>()
external ffi.Pointer<objc.CFString> kUTTypePNG;

@ffi.Native<ffi.Size Function(ffi.Pointer<CGImage>)>()
external int CGImageGetWidth(ffi.Pointer<CGImage> image);

@ffi.Native<ffi.Size Function(ffi.Pointer<CGImage>)>()
external int CGImageGetHeight(ffi.Pointer<CGImage> image);

@ffi.Native<ffi.Bool Function()>()
external bool CGPreflightScreenCaptureAccess();

@ffi.Native<ffi.Bool Function()>()
external bool CGRequestScreenCaptureAccess();

@ffi.Native<
  ffi.Pointer<CGImageDestination> Function(
    ffi.Pointer<__CFData>,
    ffi.Pointer<objc.CFString>,
    ffi.Size,
    ffi.Pointer<__CFDictionary>,
  )
>()
external ffi.Pointer<CGImageDestination> CGImageDestinationCreateWithData(
  ffi.Pointer<__CFData> data,
  ffi.Pointer<objc.CFString> type,
  int count,
  ffi.Pointer<__CFDictionary> options,
);

@ffi.Native<
  ffi.Void Function(
    ffi.Pointer<CGImageDestination>,
    ffi.Pointer<CGImage>,
    ffi.Pointer<__CFDictionary>,
  )
>()
external void CGImageDestinationAddImage(
  ffi.Pointer<CGImageDestination> idst,
  ffi.Pointer<CGImage> image,
  ffi.Pointer<__CFDictionary> properties,
);

@ffi.Native<ffi.Bool Function(ffi.Pointer<CGImageDestination>)>()
external bool CGImageDestinationFinalize(ffi.Pointer<CGImageDestination> idst);

@ffi.Native<
  ffi.Pointer<objc.ObjCBlockImpl> Function(ffi.Pointer<objc.ObjCBlockImpl>)
>(isLeaf: true)
external ffi.Pointer<objc.ObjCBlockImpl>
_NativeLibrary_wrapListenerBlock_pfv6jd(ffi.Pointer<objc.ObjCBlockImpl> block);

@ffi.Native<
  ffi.Pointer<objc.ObjCBlockImpl> Function(
    ffi.Pointer<objc.ObjCBlockImpl>,
    ffi.Pointer<objc.ObjCBlockImpl>,
    ffi.Pointer<objc.DOBJC_Context>,
  )
>(isLeaf: true)
external ffi.Pointer<objc.ObjCBlockImpl>
_NativeLibrary_wrapBlockingBlock_pfv6jd(
  ffi.Pointer<objc.ObjCBlockImpl> block,
  ffi.Pointer<objc.ObjCBlockImpl> listnerBlock,
  ffi.Pointer<objc.DOBJC_Context> context,
);

@ffi.Native<
  ffi.Bool Function(ffi.Pointer<objc.ObjCObjectImpl>, ffi.Pointer<ffi.Void>)
>()
external bool _NativeLibrary_protocolTrampoline_e3qsqz(
  ffi.Pointer<objc.ObjCObjectImpl> target,
  ffi.Pointer<ffi.Void> arg0,
);

@ffi.Native<
  ffi.Pointer<objc.ObjCBlockImpl> Function(ffi.Pointer<objc.ObjCBlockImpl>)
>(isLeaf: true)
external ffi.Pointer<objc.ObjCBlockImpl>
_NativeLibrary_wrapListenerBlock_18v1jvf(ffi.Pointer<objc.ObjCBlockImpl> block);

@ffi.Native<
  ffi.Pointer<objc.ObjCBlockImpl> Function(
    ffi.Pointer<objc.ObjCBlockImpl>,
    ffi.Pointer<objc.ObjCBlockImpl>,
    ffi.Pointer<objc.DOBJC_Context>,
  )
>(isLeaf: true)
external ffi.Pointer<objc.ObjCBlockImpl>
_NativeLibrary_wrapBlockingBlock_18v1jvf(
  ffi.Pointer<objc.ObjCBlockImpl> block,
  ffi.Pointer<objc.ObjCBlockImpl> listnerBlock,
  ffi.Pointer<objc.DOBJC_Context> context,
);

@ffi.Native<
  ffi.Void Function(
    ffi.Pointer<objc.ObjCObjectImpl>,
    ffi.Pointer<ffi.Void>,
    ffi.Pointer<objc.ObjCObjectImpl>,
  )
>()
external void _NativeLibrary_protocolTrampoline_18v1jvf(
  ffi.Pointer<objc.ObjCObjectImpl> target,
  ffi.Pointer<ffi.Void> arg0,
  ffi.Pointer<objc.ObjCObjectImpl> arg1,
);

@ffi.Native<
  instancetype Function(
    ffi.Pointer<objc.ObjCObjectImpl>,
    ffi.Pointer<ffi.Void>,
    ffi.Pointer<objc.ObjCObjectImpl>,
  )
>()
external instancetype _NativeLibrary_protocolTrampoline_xr62hr(
  ffi.Pointer<objc.ObjCObjectImpl> target,
  ffi.Pointer<ffi.Void> arg0,
  ffi.Pointer<objc.ObjCObjectImpl> arg1,
);

@ffi.Native<
  ffi.Pointer<objc.ObjCBlockImpl> Function(ffi.Pointer<objc.ObjCBlockImpl>)
>(isLeaf: true)
external ffi.Pointer<objc.ObjCBlockImpl>
_NativeLibrary_wrapListenerBlock_ro4zln(ffi.Pointer<objc.ObjCBlockImpl> block);

@ffi.Native<
  ffi.Pointer<objc.ObjCBlockImpl> Function(
    ffi.Pointer<objc.ObjCBlockImpl>,
    ffi.Pointer<objc.ObjCBlockImpl>,
    ffi.Pointer<objc.DOBJC_Context>,
  )
>(isLeaf: true)
external ffi.Pointer<objc.ObjCBlockImpl>
_NativeLibrary_wrapBlockingBlock_ro4zln(
  ffi.Pointer<objc.ObjCBlockImpl> block,
  ffi.Pointer<objc.ObjCBlockImpl> listnerBlock,
  ffi.Pointer<objc.DOBJC_Context> context,
);

@ffi.Native<
  ffi.Pointer<objc.ObjCBlockImpl> Function(ffi.Pointer<objc.ObjCBlockImpl>)
>(isLeaf: true)
external ffi.Pointer<objc.ObjCBlockImpl>
_NativeLibrary_wrapListenerBlock_19ugjh7(ffi.Pointer<objc.ObjCBlockImpl> block);

@ffi.Native<
  ffi.Pointer<objc.ObjCBlockImpl> Function(
    ffi.Pointer<objc.ObjCBlockImpl>,
    ffi.Pointer<objc.ObjCBlockImpl>,
    ffi.Pointer<objc.DOBJC_Context>,
  )
>(isLeaf: true)
external ffi.Pointer<objc.ObjCBlockImpl>
_NativeLibrary_wrapBlockingBlock_19ugjh7(
  ffi.Pointer<objc.ObjCBlockImpl> block,
  ffi.Pointer<objc.ObjCBlockImpl> listnerBlock,
  ffi.Pointer<objc.DOBJC_Context> context,
);

@ffi.Native<ffi.Pointer<objc.ObjCObjectImpl>>(symbol: 'UTTypePNG')
external ffi.Pointer<objc.ObjCObjectImpl> _UTTypePNG;

UTType get UTTypePNG =>
    UTType.fromPointer(_UTTypePNG, retain: true, release: true);

set UTTypePNG(UTType value) {
  UTType.fromPointer(_UTTypePNG, retain: false, release: true).ref.release();
  _UTTypePNG = value.ref.retainAndReturnPointer();
}

final class __CFAllocator extends ffi.Opaque {}

final class __CFDictionary extends ffi.Opaque {}

final class __CFData extends ffi.Opaque {}

late final _class_NSArray = objc.getClass("NSArray");
typedef instancetype = ffi.Pointer<objc.ObjCObjectImpl>;
typedef Dartinstancetype = objc.ObjCObject;
late final _sel_array = objc.registerName("array");
final _objc_msgSend_151sglz = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Pointer<objc.ObjCObjectImpl> Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
        )
      >
    >()
    .asFunction<
      ffi.Pointer<objc.ObjCObjectImpl> Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
      )
    >();
late final _sel_arrayWithObject_ = objc.registerName("arrayWithObject:");
final _objc_msgSend_1sotr3r = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Pointer<objc.ObjCObjectImpl> Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Pointer<objc.ObjCObjectImpl>,
        )
      >
    >()
    .asFunction<
      ffi.Pointer<objc.ObjCObjectImpl> Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
        ffi.Pointer<objc.ObjCObjectImpl>,
      )
    >();
late final _sel_arrayWithObjects_count_ = objc.registerName(
  "arrayWithObjects:count:",
);
final _objc_msgSend_zmbtbd = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Pointer<objc.ObjCObjectImpl> Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Pointer<ffi.Pointer<objc.ObjCObjectImpl>>,
          ffi.UnsignedLong,
        )
      >
    >()
    .asFunction<
      ffi.Pointer<objc.ObjCObjectImpl> Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
        ffi.Pointer<ffi.Pointer<objc.ObjCObjectImpl>>,
        int,
      )
    >();
late final _sel_arrayWithObjects_ = objc.registerName("arrayWithObjects:");
late final _sel_arrayWithArray_ = objc.registerName("arrayWithArray:");
late final _sel_initWithObjects_ = objc.registerName("initWithObjects:");
late final _sel_initWithArray_ = objc.registerName("initWithArray:");
late final _sel_initWithArray_copyItems_ = objc.registerName(
  "initWithArray:copyItems:",
);
final _objc_msgSend_17amj0z = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Pointer<objc.ObjCObjectImpl> Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Bool,
        )
      >
    >()
    .asFunction<
      ffi.Pointer<objc.ObjCObjectImpl> Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
        ffi.Pointer<objc.ObjCObjectImpl>,
        bool,
      )
    >();
late final _sel_initWithContentsOfURL_error_ = objc.registerName(
  "initWithContentsOfURL:error:",
);
final _objc_msgSend_1lhpu4m = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Pointer<objc.ObjCObjectImpl> Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<ffi.Pointer<objc.ObjCObjectImpl>>,
        )
      >
    >()
    .asFunction<
      ffi.Pointer<objc.ObjCObjectImpl> Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<ffi.Pointer<objc.ObjCObjectImpl>>,
      )
    >();
late final _sel_arrayWithContentsOfURL_error_ = objc.registerName(
  "arrayWithContentsOfURL:error:",
);

/// NSArrayCreation
extension NSArrayCreation on objc.NSArray {
  /// initWithArray:
  objc.NSArray initWithArray(objc.NSArray array) {
    final $ret = _objc_msgSend_1sotr3r(
      object$.ref.retainAndReturnPointer(),
      _sel_initWithArray_,
      array.ref.pointer,
    );
    return objc.NSArray.fromPointer($ret, retain: false, release: true);
  }

  /// initWithArray:copyItems:
  objc.NSArray initWithArray$1(objc.NSArray array, {required bool copyItems}) {
    final $ret = _objc_msgSend_17amj0z(
      object$.ref.retainAndReturnPointer(),
      _sel_initWithArray_copyItems_,
      array.ref.pointer,
      copyItems,
    );
    return objc.NSArray.fromPointer($ret, retain: false, release: true);
  }

  /// initWithContentsOfURL:error:
  objc.NSArray? initWithContentsOfURL(objc.NSURL url) {
    objc.checkOsVersionInternal(
      'NSArray.initWithContentsOfURL:error:',
      iOS: (false, (11, 0, 0)),
      macOS: (false, (10, 13, 0)),
    );
    final $err = pkg_ffi.calloc<ffi.Pointer<objc.ObjCObjectImpl>>();
    try {
      final $ret = _objc_msgSend_1lhpu4m(
        object$.ref.retainAndReturnPointer(),
        _sel_initWithContentsOfURL_error_,
        url.ref.pointer,
        $err,
      );
      objc.NSErrorException.checkErrorPointer($err.value);
      return $ret.address == 0
          ? null
          : objc.NSArray.fromPointer($ret, retain: false, release: true);
    } finally {
      pkg_ffi.calloc.free($err);
    }
  }

  /// initWithObjects:
  objc.NSArray initWithObjects$1(objc.ObjCObject firstObj) {
    final $ret = _objc_msgSend_1sotr3r(
      object$.ref.retainAndReturnPointer(),
      _sel_initWithObjects_,
      firstObj.ref.pointer,
    );
    return objc.NSArray.fromPointer($ret, retain: false, release: true);
  }

  /// array
  static objc.NSArray array() {
    final $ret = _objc_msgSend_151sglz(_class_NSArray, _sel_array);
    return objc.NSArray.fromPointer($ret, retain: true, release: true);
  }

  /// arrayWithArray:
  static objc.NSArray arrayWithArray(objc.NSArray array) {
    final $ret = _objc_msgSend_1sotr3r(
      _class_NSArray,
      _sel_arrayWithArray_,
      array.ref.pointer,
    );
    return objc.NSArray.fromPointer($ret, retain: true, release: true);
  }

  /// arrayWithContentsOfURL:error:
  static objc.NSArray? arrayWithContentsOfURL(objc.NSURL url) {
    objc.checkOsVersionInternal(
      'NSArray.arrayWithContentsOfURL:error:',
      iOS: (false, (11, 0, 0)),
      macOS: (false, (10, 13, 0)),
    );
    final $err = pkg_ffi.calloc<ffi.Pointer<objc.ObjCObjectImpl>>();
    try {
      final $ret = _objc_msgSend_1lhpu4m(
        _class_NSArray,
        _sel_arrayWithContentsOfURL_error_,
        url.ref.pointer,
        $err,
      );
      objc.NSErrorException.checkErrorPointer($err.value);
      return $ret.address == 0
          ? null
          : objc.NSArray.fromPointer($ret, retain: true, release: true);
    } finally {
      pkg_ffi.calloc.free($err);
    }
  }

  /// arrayWithObject:
  static objc.NSArray arrayWithObject(objc.ObjCObject anObject) {
    final $ret = _objc_msgSend_1sotr3r(
      _class_NSArray,
      _sel_arrayWithObject_,
      anObject.ref.pointer,
    );
    return objc.NSArray.fromPointer($ret, retain: true, release: true);
  }

  /// arrayWithObjects:
  static objc.NSArray arrayWithObjects(objc.ObjCObject firstObj) {
    final $ret = _objc_msgSend_1sotr3r(
      _class_NSArray,
      _sel_arrayWithObjects_,
      firstObj.ref.pointer,
    );
    return objc.NSArray.fromPointer($ret, retain: true, release: true);
  }

  /// arrayWithObjects:count:
  static objc.NSArray arrayWithObjects$1(
    ffi.Pointer<ffi.Pointer<objc.ObjCObjectImpl>> objects, {
    required int count,
  }) {
    final $ret = _objc_msgSend_zmbtbd(
      _class_NSArray,
      _sel_arrayWithObjects_count_,
      objects,
      count,
    );
    return objc.NSArray.fromPointer($ret, retain: true, release: true);
  }
}

/// Construction methods for `objc.ObjCBlock<ffi.Bool Function(ffi.Pointer<objc.ObjCObjectImpl>, ffi.Pointer<objc.ObjCObjectImpl>)>`.
abstract final class ObjCBlock_bool_ObjectType_ObjectType {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<
    ffi.Bool Function(
      ffi.Pointer<objc.ObjCObjectImpl>,
      ffi.Pointer<objc.ObjCObjectImpl>,
    )
  >
  fromPointer(
    ffi.Pointer<objc.ObjCBlockImpl> pointer, {
    bool retain = false,
    bool release = false,
  }) =>
      objc.ObjCBlock<
        ffi.Bool Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCObjectImpl>,
        )
      >(pointer, retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<
    ffi.Bool Function(
      ffi.Pointer<objc.ObjCObjectImpl>,
      ffi.Pointer<objc.ObjCObjectImpl>,
    )
  >
  fromFunctionPointer(
    ffi.Pointer<
      ffi.NativeFunction<
        ffi.Bool Function(
          ffi.Pointer<objc.ObjCObjectImpl> arg0,
          ffi.Pointer<objc.ObjCObjectImpl> arg1,
        )
      >
    >
    ptr,
  ) =>
      objc.ObjCBlock<
        ffi.Bool Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCObjectImpl>,
        )
      >(
        objc.newPointerBlock(_fnPtrCallable, ptr.cast()),
        retain: false,
        release: true,
      );

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<
    ffi.Bool Function(
      ffi.Pointer<objc.ObjCObjectImpl>,
      ffi.Pointer<objc.ObjCObjectImpl>,
    )
  >
  fromFunction(
    bool Function(objc.ObjCObject, objc.ObjCObject) fn, {
    bool keepIsolateAlive = true,
  }) =>
      objc.ObjCBlock<
        ffi.Bool Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCObjectImpl>,
        )
      >(
        objc.newClosureBlock(
          _closureCallable,
          (
            ffi.Pointer<objc.ObjCObjectImpl> arg0,
            ffi.Pointer<objc.ObjCObjectImpl> arg1,
          ) => fn(
            objc.ObjCObject(arg0, retain: true, release: true),
            objc.ObjCObject(arg1, retain: true, release: true),
          ),
          keepIsolateAlive,
        ),
        retain: false,
        release: true,
      );

  static bool _fnPtrTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<objc.ObjCObjectImpl> arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
  ) => block.ref.target
      .cast<
        ffi.NativeFunction<
          ffi.Bool Function(
            ffi.Pointer<objc.ObjCObjectImpl> arg0,
            ffi.Pointer<objc.ObjCObjectImpl> arg1,
          )
        >
      >()
      .asFunction<
        bool Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCObjectImpl>,
        )
      >()(arg0, arg1);
  static ffi.Pointer<ffi.Void> _fnPtrCallable =
      ffi.Pointer.fromFunction<
            ffi.Bool Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<objc.ObjCObjectImpl>,
              ffi.Pointer<objc.ObjCObjectImpl>,
            )
          >(_fnPtrTrampoline, false)
          .cast();
  static bool _closureTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<objc.ObjCObjectImpl> arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
  ) =>
      (objc.getBlockClosure(block)
          as bool Function(
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          ))(arg0, arg1);
  static ffi.Pointer<ffi.Void> _closureCallable =
      ffi.Pointer.fromFunction<
            ffi.Bool Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<objc.ObjCObjectImpl>,
              ffi.Pointer<objc.ObjCObjectImpl>,
            )
          >(_closureTrampoline, false)
          .cast();
}

/// Call operator for `objc.ObjCBlock<ffi.Bool Function(ffi.Pointer<objc.ObjCObjectImpl>, ffi.Pointer<objc.ObjCObjectImpl>)>`.
extension ObjCBlock_bool_ObjectType_ObjectType$CallExtension
    on
        objc.ObjCBlock<
          ffi.Bool Function(
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          )
        > {
  bool call(objc.ObjCObject arg0, objc.ObjCObject arg1) => ref
      .pointer
      .ref
      .invoke
      .cast<
        ffi.NativeFunction<
          ffi.Bool Function(
            ffi.Pointer<objc.ObjCBlockImpl> block,
            ffi.Pointer<objc.ObjCObjectImpl> arg0,
            ffi.Pointer<objc.ObjCObjectImpl> arg1,
          )
        >
      >()
      .asFunction<
        bool Function(
          ffi.Pointer<objc.ObjCBlockImpl>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCObjectImpl>,
        )
      >()(ref.pointer, arg0.ref.pointer, arg1.ref.pointer);
}

late final _sel_differenceFromArray_withOptions_usingEquivalenceTest_ = objc
    .registerName("differenceFromArray:withOptions:usingEquivalenceTest:");
final _objc_msgSend_1415lvo = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Pointer<objc.ObjCObjectImpl> Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.UnsignedLong,
          ffi.Pointer<objc.ObjCBlockImpl>,
        )
      >
    >()
    .asFunction<
      ffi.Pointer<objc.ObjCObjectImpl> Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
        ffi.Pointer<objc.ObjCObjectImpl>,
        int,
        ffi.Pointer<objc.ObjCBlockImpl>,
      )
    >();
late final _sel_differenceFromArray_withOptions_ = objc.registerName(
  "differenceFromArray:withOptions:",
);
final _objc_msgSend_1wtpmu7 = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Pointer<objc.ObjCObjectImpl> Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.UnsignedLong,
        )
      >
    >()
    .asFunction<
      ffi.Pointer<objc.ObjCObjectImpl> Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
        ffi.Pointer<objc.ObjCObjectImpl>,
        int,
      )
    >();
late final _sel_differenceFromArray_ = objc.registerName(
  "differenceFromArray:",
);
late final _sel_arrayByApplyingDifference_ = objc.registerName(
  "arrayByApplyingDifference:",
);

/// NSArrayDiffing
extension NSArrayDiffing on objc.NSArray {
  /// arrayByApplyingDifference:
  objc.NSArray? arrayByApplyingDifference(
    objc.NSOrderedCollectionDifference difference,
  ) {
    objc.checkOsVersionInternal(
      'NSArray.arrayByApplyingDifference:',
      iOS: (false, (13, 0, 0)),
      macOS: (false, (10, 15, 0)),
    );
    final $ret = _objc_msgSend_1sotr3r(
      object$.ref.pointer,
      _sel_arrayByApplyingDifference_,
      difference.ref.pointer,
    );
    return $ret.address == 0
        ? null
        : objc.NSArray.fromPointer($ret, retain: true, release: true);
  }

  /// differenceFromArray:
  objc.NSOrderedCollectionDifference differenceFromArray(objc.NSArray other) {
    objc.checkOsVersionInternal(
      'NSArray.differenceFromArray:',
      iOS: (false, (13, 0, 0)),
      macOS: (false, (10, 15, 0)),
    );
    final $ret = _objc_msgSend_1sotr3r(
      object$.ref.pointer,
      _sel_differenceFromArray_,
      other.ref.pointer,
    );
    return objc.NSOrderedCollectionDifference.fromPointer(
      $ret,
      retain: true,
      release: true,
    );
  }

  /// differenceFromArray:withOptions:
  objc.NSOrderedCollectionDifference differenceFromArray$1(
    objc.NSArray other, {
    required int withOptions,
  }) {
    objc.checkOsVersionInternal(
      'NSArray.differenceFromArray:withOptions:',
      iOS: (false, (13, 0, 0)),
      macOS: (false, (10, 15, 0)),
    );
    final $ret = _objc_msgSend_1wtpmu7(
      object$.ref.pointer,
      _sel_differenceFromArray_withOptions_,
      other.ref.pointer,
      withOptions,
    );
    return objc.NSOrderedCollectionDifference.fromPointer(
      $ret,
      retain: true,
      release: true,
    );
  }

  /// differenceFromArray:withOptions:usingEquivalenceTest:
  objc.NSOrderedCollectionDifference differenceFromArray$2(
    objc.NSArray other, {
    required int withOptions,
    required objc.ObjCBlock<
      ffi.Bool Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCObjectImpl>,
      )
    >
    usingEquivalenceTest,
  }) {
    objc.checkOsVersionInternal(
      'NSArray.differenceFromArray:withOptions:usingEquivalenceTest:',
      iOS: (false, (13, 0, 0)),
      macOS: (false, (10, 15, 0)),
    );
    final $ret = _objc_msgSend_1415lvo(
      object$.ref.pointer,
      _sel_differenceFromArray_withOptions_usingEquivalenceTest_,
      other.ref.pointer,
      withOptions,
      usingEquivalenceTest.ref.pointer,
    );
    return objc.NSOrderedCollectionDifference.fromPointer(
      $ret,
      retain: true,
      release: true,
    );
  }
}

late final _sel_getObjects_ = objc.registerName("getObjects:");
final _objc_msgSend_1dau4w = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Pointer<ffi.Pointer<objc.ObjCObjectImpl>>,
        )
      >
    >()
    .asFunction<
      void Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
        ffi.Pointer<ffi.Pointer<objc.ObjCObjectImpl>>,
      )
    >();
late final _sel_arrayWithContentsOfFile_ = objc.registerName(
  "arrayWithContentsOfFile:",
);
late final _sel_arrayWithContentsOfURL_ = objc.registerName(
  "arrayWithContentsOfURL:",
);
late final _sel_initWithContentsOfFile_ = objc.registerName(
  "initWithContentsOfFile:",
);
late final _sel_initWithContentsOfURL_ = objc.registerName(
  "initWithContentsOfURL:",
);
late final _sel_writeToFile_atomically_ = objc.registerName(
  "writeToFile:atomically:",
);
final _objc_msgSend_1iyq28l = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Bool Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Bool,
        )
      >
    >()
    .asFunction<
      bool Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
        ffi.Pointer<objc.ObjCObjectImpl>,
        bool,
      )
    >();
late final _sel_writeToURL_atomically_ = objc.registerName(
  "writeToURL:atomically:",
);

/// NSDeprecated
extension NSDeprecated on objc.NSArray {
  /// getObjects:
  void getObjects(ffi.Pointer<ffi.Pointer<objc.ObjCObjectImpl>> objects) {
    objc.checkOsVersionInternal(
      'NSArray.getObjects:',
      iOS: (false, (2, 0, 0)),
      macOS: (false, (10, 0, 0)),
    );
    _objc_msgSend_1dau4w(object$.ref.pointer, _sel_getObjects_, objects);
  }

  /// initWithContentsOfFile:
  objc.NSArray? initWithContentsOfFile(objc.NSString path) {
    objc.checkOsVersionInternal(
      'NSArray.initWithContentsOfFile:',
      iOS: (false, (2, 0, 0)),
      macOS: (false, (10, 0, 0)),
    );
    final $ret = _objc_msgSend_1sotr3r(
      object$.ref.retainAndReturnPointer(),
      _sel_initWithContentsOfFile_,
      path.ref.pointer,
    );
    return $ret.address == 0
        ? null
        : objc.NSArray.fromPointer($ret, retain: false, release: true);
  }

  /// initWithContentsOfURL:
  objc.NSArray? initWithContentsOfURL(objc.NSURL url) {
    objc.checkOsVersionInternal(
      'NSArray.initWithContentsOfURL:',
      iOS: (false, (2, 0, 0)),
      macOS: (false, (10, 0, 0)),
    );
    final $ret = _objc_msgSend_1sotr3r(
      object$.ref.retainAndReturnPointer(),
      _sel_initWithContentsOfURL_,
      url.ref.pointer,
    );
    return $ret.address == 0
        ? null
        : objc.NSArray.fromPointer($ret, retain: false, release: true);
  }

  /// writeToFile:atomically:
  bool writeToFile(objc.NSString path, {required bool atomically}) {
    objc.checkOsVersionInternal(
      'NSArray.writeToFile:atomically:',
      iOS: (false, (2, 0, 0)),
      macOS: (false, (10, 0, 0)),
    );
    return _objc_msgSend_1iyq28l(
      object$.ref.pointer,
      _sel_writeToFile_atomically_,
      path.ref.pointer,
      atomically,
    );
  }

  /// writeToURL:atomically:
  bool writeToURL(objc.NSURL url, {required bool atomically}) {
    objc.checkOsVersionInternal(
      'NSArray.writeToURL:atomically:',
      iOS: (false, (2, 0, 0)),
      macOS: (false, (10, 0, 0)),
    );
    return _objc_msgSend_1iyq28l(
      object$.ref.pointer,
      _sel_writeToURL_atomically_,
      url.ref.pointer,
      atomically,
    );
  }

  /// arrayWithContentsOfFile:
  static objc.NSArray? arrayWithContentsOfFile(objc.NSString path) {
    objc.checkOsVersionInternal(
      'NSArray.arrayWithContentsOfFile:',
      iOS: (false, (2, 0, 0)),
      macOS: (false, (10, 0, 0)),
    );
    final $ret = _objc_msgSend_1sotr3r(
      _class_NSArray,
      _sel_arrayWithContentsOfFile_,
      path.ref.pointer,
    );
    return $ret.address == 0
        ? null
        : objc.NSArray.fromPointer($ret, retain: true, release: true);
  }

  /// arrayWithContentsOfURL:
  static objc.NSArray? arrayWithContentsOfURL(objc.NSURL url) {
    objc.checkOsVersionInternal(
      'NSArray.arrayWithContentsOfURL:',
      iOS: (false, (2, 0, 0)),
      macOS: (false, (10, 0, 0)),
    );
    final $ret = _objc_msgSend_1sotr3r(
      _class_NSArray,
      _sel_arrayWithContentsOfURL_,
      url.ref.pointer,
    );
    return $ret.address == 0
        ? null
        : objc.NSArray.fromPointer($ret, retain: true, release: true);
  }
}

late final _class_NSData = objc.getClass("NSData");
late final _sel_initWithBase64EncodedString_options_ = objc.registerName(
  "initWithBase64EncodedString:options:",
);
final _objc_msgSend_7kpg7m = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Pointer<objc.ObjCObjectImpl> Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.UnsignedLong,
        )
      >
    >()
    .asFunction<
      ffi.Pointer<objc.ObjCObjectImpl> Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
        ffi.Pointer<objc.ObjCObjectImpl>,
        int,
      )
    >();
late final _sel_base64EncodedStringWithOptions_ = objc.registerName(
  "base64EncodedStringWithOptions:",
);
final _objc_msgSend_ylninc = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Pointer<objc.ObjCObjectImpl> Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.UnsignedLong,
        )
      >
    >()
    .asFunction<
      ffi.Pointer<objc.ObjCObjectImpl> Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
        int,
      )
    >();
late final _sel_initWithBase64EncodedData_options_ = objc.registerName(
  "initWithBase64EncodedData:options:",
);
late final _sel_base64EncodedDataWithOptions_ = objc.registerName(
  "base64EncodedDataWithOptions:",
);

/// NSDataBase64Encoding
extension NSDataBase64Encoding on objc.NSData {
  /// base64EncodedDataWithOptions:
  objc.NSData base64EncodedDataWithOptions(int options) {
    objc.checkOsVersionInternal(
      'NSData.base64EncodedDataWithOptions:',
      iOS: (false, (7, 0, 0)),
      macOS: (false, (10, 9, 0)),
    );
    final $ret = _objc_msgSend_ylninc(
      object$.ref.pointer,
      _sel_base64EncodedDataWithOptions_,
      options,
    );
    return objc.NSData.fromPointer($ret, retain: true, release: true);
  }

  /// base64EncodedStringWithOptions:
  objc.NSString base64EncodedStringWithOptions(int options) {
    objc.checkOsVersionInternal(
      'NSData.base64EncodedStringWithOptions:',
      iOS: (false, (7, 0, 0)),
      macOS: (false, (10, 9, 0)),
    );
    final $ret = _objc_msgSend_ylninc(
      object$.ref.pointer,
      _sel_base64EncodedStringWithOptions_,
      options,
    );
    return objc.NSString.fromPointer($ret, retain: true, release: true);
  }

  /// initWithBase64EncodedData:options:
  objc.NSData? initWithBase64EncodedData(
    objc.NSData base64Data, {
    required int options,
  }) {
    objc.checkOsVersionInternal(
      'NSData.initWithBase64EncodedData:options:',
      iOS: (false, (7, 0, 0)),
      macOS: (false, (10, 9, 0)),
    );
    final $ret = _objc_msgSend_7kpg7m(
      object$.ref.retainAndReturnPointer(),
      _sel_initWithBase64EncodedData_options_,
      base64Data.ref.pointer,
      options,
    );
    return $ret.address == 0
        ? null
        : objc.NSData.fromPointer($ret, retain: false, release: true);
  }

  /// initWithBase64EncodedString:options:
  objc.NSData? initWithBase64EncodedString(
    objc.NSString base64String, {
    required int options,
  }) {
    objc.checkOsVersionInternal(
      'NSData.initWithBase64EncodedString:options:',
      iOS: (false, (7, 0, 0)),
      macOS: (false, (10, 9, 0)),
    );
    final $ret = _objc_msgSend_7kpg7m(
      object$.ref.retainAndReturnPointer(),
      _sel_initWithBase64EncodedString_options_,
      base64String.ref.pointer,
      options,
    );
    return $ret.address == 0
        ? null
        : objc.NSData.fromPointer($ret, retain: false, release: true);
  }
}

late final _sel_decompressedDataUsingAlgorithm_error_ = objc.registerName(
  "decompressedDataUsingAlgorithm:error:",
);
final _objc_msgSend_1vnlaqg = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Pointer<objc.ObjCObjectImpl> Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Long,
          ffi.Pointer<ffi.Pointer<objc.ObjCObjectImpl>>,
        )
      >
    >()
    .asFunction<
      ffi.Pointer<objc.ObjCObjectImpl> Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
        int,
        ffi.Pointer<ffi.Pointer<objc.ObjCObjectImpl>>,
      )
    >();
late final _sel_compressedDataUsingAlgorithm_error_ = objc.registerName(
  "compressedDataUsingAlgorithm:error:",
);

/// NSDataCompression
extension NSDataCompression on objc.NSData {
  /// compressedDataUsingAlgorithm:error:
  objc.NSData? compressedDataUsingAlgorithm(
    objc.NSDataCompressionAlgorithm algorithm,
  ) {
    objc.checkOsVersionInternal(
      'NSData.compressedDataUsingAlgorithm:error:',
      iOS: (false, (13, 0, 0)),
      macOS: (false, (10, 15, 0)),
    );
    final $err = pkg_ffi.calloc<ffi.Pointer<objc.ObjCObjectImpl>>();
    try {
      final $ret = _objc_msgSend_1vnlaqg(
        object$.ref.pointer,
        _sel_compressedDataUsingAlgorithm_error_,
        algorithm.value,
        $err,
      );
      objc.NSErrorException.checkErrorPointer($err.value);
      return $ret.address == 0
          ? null
          : objc.NSData.fromPointer($ret, retain: true, release: true);
    } finally {
      pkg_ffi.calloc.free($err);
    }
  }

  /// decompressedDataUsingAlgorithm:error:
  objc.NSData? decompressedDataUsingAlgorithm(
    objc.NSDataCompressionAlgorithm algorithm,
  ) {
    objc.checkOsVersionInternal(
      'NSData.decompressedDataUsingAlgorithm:error:',
      iOS: (false, (13, 0, 0)),
      macOS: (false, (10, 15, 0)),
    );
    final $err = pkg_ffi.calloc<ffi.Pointer<objc.ObjCObjectImpl>>();
    try {
      final $ret = _objc_msgSend_1vnlaqg(
        object$.ref.pointer,
        _sel_decompressedDataUsingAlgorithm_error_,
        algorithm.value,
        $err,
      );
      objc.NSErrorException.checkErrorPointer($err.value);
      return $ret.address == 0
          ? null
          : objc.NSData.fromPointer($ret, retain: true, release: true);
    } finally {
      pkg_ffi.calloc.free($err);
    }
  }
}

late final _sel_getBytes_ = objc.registerName("getBytes:");
final _objc_msgSend_ovsamd = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Pointer<ffi.Void>,
        )
      >
    >()
    .asFunction<
      void Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
        ffi.Pointer<ffi.Void>,
      )
    >();
late final _sel_dataWithContentsOfMappedFile_ = objc.registerName(
  "dataWithContentsOfMappedFile:",
);
late final _sel_initWithContentsOfMappedFile_ = objc.registerName(
  "initWithContentsOfMappedFile:",
);
late final _sel_initWithBase64Encoding_ = objc.registerName(
  "initWithBase64Encoding:",
);
late final _sel_base64Encoding = objc.registerName("base64Encoding");

/// NSDeprecated
extension NSDeprecated$1 on objc.NSData {
  /// base64Encoding
  objc.NSString base64Encoding() {
    objc.checkOsVersionInternal(
      'NSData.base64Encoding',
      iOS: (false, (4, 0, 0)),
      macOS: (false, (10, 6, 0)),
    );
    final $ret = _objc_msgSend_151sglz(
      object$.ref.pointer,
      _sel_base64Encoding,
    );
    return objc.NSString.fromPointer($ret, retain: true, release: true);
  }

  /// getBytes:
  void getBytes(ffi.Pointer<ffi.Void> buffer) {
    objc.checkOsVersionInternal(
      'NSData.getBytes:',
      iOS: (false, (2, 0, 0)),
      macOS: (false, (10, 0, 0)),
    );
    _objc_msgSend_ovsamd(object$.ref.pointer, _sel_getBytes_, buffer);
  }

  /// initWithBase64Encoding:
  objc.ObjCObject? initWithBase64Encoding(objc.NSString base64String) {
    objc.checkOsVersionInternal(
      'NSData.initWithBase64Encoding:',
      iOS: (false, (4, 0, 0)),
      macOS: (false, (10, 6, 0)),
    );
    final $ret = _objc_msgSend_1sotr3r(
      object$.ref.retainAndReturnPointer(),
      _sel_initWithBase64Encoding_,
      base64String.ref.pointer,
    );
    return $ret.address == 0
        ? null
        : objc.ObjCObject($ret, retain: false, release: true);
  }

  /// initWithContentsOfMappedFile:
  objc.ObjCObject? initWithContentsOfMappedFile(objc.NSString path) {
    objc.checkOsVersionInternal(
      'NSData.initWithContentsOfMappedFile:',
      iOS: (false, (2, 0, 0)),
      macOS: (false, (10, 0, 0)),
    );
    final $ret = _objc_msgSend_1sotr3r(
      object$.ref.retainAndReturnPointer(),
      _sel_initWithContentsOfMappedFile_,
      path.ref.pointer,
    );
    return $ret.address == 0
        ? null
        : objc.ObjCObject($ret, retain: false, release: true);
  }

  /// dataWithContentsOfMappedFile:
  static objc.ObjCObject? dataWithContentsOfMappedFile(objc.NSString path) {
    objc.checkOsVersionInternal(
      'NSData.dataWithContentsOfMappedFile:',
      iOS: (false, (2, 0, 0)),
      macOS: (false, (10, 0, 0)),
    );
    final $ret = _objc_msgSend_1sotr3r(
      _class_NSData,
      _sel_dataWithContentsOfMappedFile_,
      path.ref.pointer,
    );
    return $ret.address == 0
        ? null
        : objc.ObjCObject($ret, retain: true, release: true);
  }
}

late final _class_NSMutableData = objc.getClass("NSMutableData");
late final _sel_dataWithCapacity_ = objc.registerName("dataWithCapacity:");
final _objc_msgSend_14hpxwa = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Pointer<objc.ObjCObjectImpl> Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.UnsignedLong,
        )
      >
    >()
    .asFunction<
      ffi.Pointer<objc.ObjCObjectImpl> Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
        int,
      )
    >();
late final _sel_dataWithLength_ = objc.registerName("dataWithLength:");
late final _sel_initWithCapacity_ = objc.registerName("initWithCapacity:");
late final _sel_initWithLength_ = objc.registerName("initWithLength:");

/// NSMutableDataCreation
extension NSMutableDataCreation on objc.NSMutableData {
  /// initWithCapacity:
  objc.NSMutableData? initWithCapacity(int capacity) {
    final $ret = _objc_msgSend_14hpxwa(
      object$.ref.retainAndReturnPointer(),
      _sel_initWithCapacity_,
      capacity,
    );
    return $ret.address == 0
        ? null
        : objc.NSMutableData.fromPointer($ret, retain: false, release: true);
  }

  /// initWithLength:
  objc.NSMutableData? initWithLength(int length) {
    final $ret = _objc_msgSend_14hpxwa(
      object$.ref.retainAndReturnPointer(),
      _sel_initWithLength_,
      length,
    );
    return $ret.address == 0
        ? null
        : objc.NSMutableData.fromPointer($ret, retain: false, release: true);
  }

  /// dataWithCapacity:
  static objc.NSMutableData? dataWithCapacity(int aNumItems) {
    final $ret = _objc_msgSend_14hpxwa(
      _class_NSMutableData,
      _sel_dataWithCapacity_,
      aNumItems,
    );
    return $ret.address == 0
        ? null
        : objc.NSMutableData.fromPointer($ret, retain: true, release: true);
  }

  /// dataWithLength:
  static objc.NSMutableData? dataWithLength(int length) {
    final $ret = _objc_msgSend_14hpxwa(
      _class_NSMutableData,
      _sel_dataWithLength_,
      length,
    );
    return $ret.address == 0
        ? null
        : objc.NSMutableData.fromPointer($ret, retain: true, release: true);
  }
}

late final _sel_decompressUsingAlgorithm_error_ = objc.registerName(
  "decompressUsingAlgorithm:error:",
);
final _objc_msgSend_15v716q = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Bool Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Long,
          ffi.Pointer<ffi.Pointer<objc.ObjCObjectImpl>>,
        )
      >
    >()
    .asFunction<
      bool Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
        int,
        ffi.Pointer<ffi.Pointer<objc.ObjCObjectImpl>>,
      )
    >();
late final _sel_compressUsingAlgorithm_error_ = objc.registerName(
  "compressUsingAlgorithm:error:",
);

/// NSMutableDataCompression
extension NSMutableDataCompression on objc.NSMutableData {
  /// compressUsingAlgorithm:error:
  bool compressUsingAlgorithm(objc.NSDataCompressionAlgorithm algorithm) {
    objc.checkOsVersionInternal(
      'NSMutableData.compressUsingAlgorithm:error:',
      iOS: (false, (13, 0, 0)),
      macOS: (false, (10, 15, 0)),
    );
    final $err = pkg_ffi.calloc<ffi.Pointer<objc.ObjCObjectImpl>>();
    try {
      final $ret = _objc_msgSend_15v716q(
        object$.ref.pointer,
        _sel_compressUsingAlgorithm_error_,
        algorithm.value,
        $err,
      );
      objc.NSErrorException.checkErrorPointer($err.value);
      return $ret;
    } finally {
      pkg_ffi.calloc.free($err);
    }
  }

  /// decompressUsingAlgorithm:error:
  bool decompressUsingAlgorithm(objc.NSDataCompressionAlgorithm algorithm) {
    objc.checkOsVersionInternal(
      'NSMutableData.decompressUsingAlgorithm:error:',
      iOS: (false, (13, 0, 0)),
      macOS: (false, (10, 15, 0)),
    );
    final $err = pkg_ffi.calloc<ffi.Pointer<objc.ObjCObjectImpl>>();
    try {
      final $ret = _objc_msgSend_15v716q(
        object$.ref.pointer,
        _sel_decompressUsingAlgorithm_error_,
        algorithm.value,
        $err,
      );
      objc.NSErrorException.checkErrorPointer($err.value);
      return $ret;
    } finally {
      pkg_ffi.calloc.free($err);
    }
  }
}

late final _sel_pathsMatchingExtensions_ = objc.registerName(
  "pathsMatchingExtensions:",
);

/// NSArrayPathExtensions
extension NSArrayPathExtensions on objc.NSArray {
  /// pathsMatchingExtensions:
  objc.NSArray pathsMatchingExtensions(objc.NSArray filterTypes) {
    final $ret = _objc_msgSend_1sotr3r(
      object$.ref.pointer,
      _sel_pathsMatchingExtensions_,
      filterTypes.ref.pointer,
    );
    return objc.NSArray.fromPointer($ret, retain: true, release: true);
  }
}

late final _sel_valueForKey_ = objc.registerName("valueForKey:");
late final _sel_setValue_forKey_ = objc.registerName("setValue:forKey:");
final _objc_msgSend_pfv6jd = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCObjectImpl>,
        )
      >
    >()
    .asFunction<
      void Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCObjectImpl>,
      )
    >();

/// NSKeyValueCoding
extension NSKeyValueCoding on objc.NSArray {
  /// setValue:forKey:
  void setValue(objc.ObjCObject? value, {required objc.NSString forKey}) {
    _objc_msgSend_pfv6jd(
      object$.ref.pointer,
      _sel_setValue_forKey_,
      value?.ref.pointer ?? ffi.nullptr,
      forKey.ref.pointer,
    );
  }

  /// valueForKey:
  objc.ObjCObject valueForKey(objc.NSString key) {
    final $ret = _objc_msgSend_1sotr3r(
      object$.ref.pointer,
      _sel_valueForKey_,
      key.ref.pointer,
    );
    return objc.ObjCObject($ret, retain: true, release: true);
  }
}

late final _sel_addObserver_toObjectsAtIndexes_forKeyPath_options_context_ =
    objc.registerName(
      "addObserver:toObjectsAtIndexes:forKeyPath:options:context:",
    );
final _objc_msgSend_1vfgg7v = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.UnsignedLong,
          ffi.Pointer<ffi.Void>,
        )
      >
    >()
    .asFunction<
      void Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCObjectImpl>,
        int,
        ffi.Pointer<ffi.Void>,
      )
    >();
late final _sel_removeObserver_fromObjectsAtIndexes_forKeyPath_context_ = objc
    .registerName("removeObserver:fromObjectsAtIndexes:forKeyPath:context:");
final _objc_msgSend_1pl4k3n = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<ffi.Void>,
        )
      >
    >()
    .asFunction<
      void Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<ffi.Void>,
      )
    >();
late final _sel_removeObserver_fromObjectsAtIndexes_forKeyPath_ = objc
    .registerName("removeObserver:fromObjectsAtIndexes:forKeyPath:");
final _objc_msgSend_r8gdi7 = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCObjectImpl>,
        )
      >
    >()
    .asFunction<
      void Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCObjectImpl>,
      )
    >();
late final _sel_addObserver_forKeyPath_options_context_ = objc.registerName(
  "addObserver:forKeyPath:options:context:",
);
final _objc_msgSend_akk2cd = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.UnsignedLong,
          ffi.Pointer<ffi.Void>,
        )
      >
    >()
    .asFunction<
      void Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCObjectImpl>,
        int,
        ffi.Pointer<ffi.Void>,
      )
    >();
late final _sel_removeObserver_forKeyPath_context_ = objc.registerName(
  "removeObserver:forKeyPath:context:",
);
final _objc_msgSend_1jed5jl = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<ffi.Void>,
        )
      >
    >()
    .asFunction<
      void Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<ffi.Void>,
      )
    >();
late final _sel_removeObserver_forKeyPath_ = objc.registerName(
  "removeObserver:forKeyPath:",
);

/// NSKeyValueObserverRegistration
extension NSKeyValueObserverRegistration on objc.NSArray {
  /// addObserver:forKeyPath:options:context:
  void addObserver(
    objc.NSObject observer, {
    required objc.NSString forKeyPath,
    required int options,
    required ffi.Pointer<ffi.Void> context,
  }) {
    _objc_msgSend_akk2cd(
      object$.ref.pointer,
      _sel_addObserver_forKeyPath_options_context_,
      observer.ref.pointer,
      forKeyPath.ref.pointer,
      options,
      context,
    );
  }

  /// addObserver:toObjectsAtIndexes:forKeyPath:options:context:
  void addObserver$1(
    objc.NSObject observer, {
    required objc.NSIndexSet toObjectsAtIndexes,
    required objc.NSString forKeyPath,
    required int options,
    required ffi.Pointer<ffi.Void> context,
  }) {
    _objc_msgSend_1vfgg7v(
      object$.ref.pointer,
      _sel_addObserver_toObjectsAtIndexes_forKeyPath_options_context_,
      observer.ref.pointer,
      toObjectsAtIndexes.ref.pointer,
      forKeyPath.ref.pointer,
      options,
      context,
    );
  }

  /// removeObserver:forKeyPath:
  void removeObserver(
    objc.NSObject observer, {
    required objc.NSString forKeyPath,
  }) {
    _objc_msgSend_pfv6jd(
      object$.ref.pointer,
      _sel_removeObserver_forKeyPath_,
      observer.ref.pointer,
      forKeyPath.ref.pointer,
    );
  }

  /// removeObserver:forKeyPath:context:
  void removeObserver$1(
    objc.NSObject observer, {
    required objc.NSString forKeyPath,
    required ffi.Pointer<ffi.Void> context,
  }) {
    objc.checkOsVersionInternal(
      'NSArray.removeObserver:forKeyPath:context:',
      iOS: (false, (5, 0, 0)),
      macOS: (false, (10, 7, 0)),
    );
    _objc_msgSend_1jed5jl(
      object$.ref.pointer,
      _sel_removeObserver_forKeyPath_context_,
      observer.ref.pointer,
      forKeyPath.ref.pointer,
      context,
    );
  }

  /// removeObserver:fromObjectsAtIndexes:forKeyPath:
  void removeObserver$2(
    objc.NSObject observer, {
    required objc.NSIndexSet fromObjectsAtIndexes,
    required objc.NSString forKeyPath,
  }) {
    _objc_msgSend_r8gdi7(
      object$.ref.pointer,
      _sel_removeObserver_fromObjectsAtIndexes_forKeyPath_,
      observer.ref.pointer,
      fromObjectsAtIndexes.ref.pointer,
      forKeyPath.ref.pointer,
    );
  }

  /// removeObserver:fromObjectsAtIndexes:forKeyPath:context:
  void removeObserver$3(
    objc.NSObject observer, {
    required objc.NSIndexSet fromObjectsAtIndexes,
    required objc.NSString forKeyPath,
    required ffi.Pointer<ffi.Void> context,
  }) {
    objc.checkOsVersionInternal(
      'NSArray.removeObserver:fromObjectsAtIndexes:forKeyPath:context:',
      iOS: (false, (5, 0, 0)),
      macOS: (false, (10, 7, 0)),
    );
    _objc_msgSend_1pl4k3n(
      object$.ref.pointer,
      _sel_removeObserver_fromObjectsAtIndexes_forKeyPath_context_,
      observer.ref.pointer,
      fromObjectsAtIndexes.ref.pointer,
      forKeyPath.ref.pointer,
      context,
    );
  }
}

late final _sel_sortedArrayUsingDescriptors_ = objc.registerName(
  "sortedArrayUsingDescriptors:",
);

/// NSSortDescriptorSorting
extension NSSortDescriptorSorting on objc.NSArray {
  /// sortedArrayUsingDescriptors:
  objc.NSArray sortedArrayUsingDescriptors(objc.NSArray sortDescriptors) {
    final $ret = _objc_msgSend_1sotr3r(
      object$.ref.pointer,
      _sel_sortedArrayUsingDescriptors_,
      sortDescriptors.ref.pointer,
    );
    return objc.NSArray.fromPointer($ret, retain: true, release: true);
  }
}

/// WARNING: NSPredicate is a stub. To generate bindings for this class, include
/// NSPredicate in your config's objc-interfaces list.
///
/// NSPredicate
extension type NSPredicate._(objc.ObjCObject object$)
    implements
        objc.ObjCObject,
        objc.NSObject,
        objc.NSSecureCoding,
        objc.NSCopying {
  /// Constructs a [NSPredicate] that points to the same underlying object as [other].
  NSPredicate.as(objc.ObjCObject other) : object$ = other {
    objc.checkOsVersionInternal(
      'NSPredicate',
      iOS: (false, (3, 0, 0)),
      macOS: (false, (10, 4, 0)),
    );
  }

  /// Constructs a [NSPredicate] that wraps the given raw object pointer.
  NSPredicate.fromPointer(
    ffi.Pointer<objc.ObjCObjectImpl> other, {
    bool retain = false,
    bool release = false,
  }) : object$ = objc.ObjCObject(other, retain: retain, release: release) {
    objc.checkOsVersionInternal(
      'NSPredicate',
      iOS: (false, (3, 0, 0)),
      macOS: (false, (10, 4, 0)),
    );
  }
}

late final _sel_filteredArrayUsingPredicate_ = objc.registerName(
  "filteredArrayUsingPredicate:",
);

/// NSPredicateSupport
extension NSPredicateSupport on objc.NSArray {
  /// filteredArrayUsingPredicate:
  objc.NSArray filteredArrayUsingPredicate(NSPredicate predicate) {
    final $ret = _objc_msgSend_1sotr3r(
      object$.ref.pointer,
      _sel_filteredArrayUsingPredicate_,
      predicate.ref.pointer,
    );
    return objc.NSArray.fromPointer($ret, retain: true, release: true);
  }
}

final class CGColor extends ffi.Opaque {}

final class CGImage extends ffi.Opaque {}

final class CGImageDestination extends ffi.Opaque {}

enum SCShareableContentStyle {
  SCShareableContentStyleNone(0),
  SCShareableContentStyleWindow(1),
  SCShareableContentStyleDisplay(2),
  SCShareableContentStyleApplication(3);

  final int value;
  const SCShareableContentStyle(this.value);

  static SCShareableContentStyle fromValue(int value) => switch (value) {
    0 => SCShareableContentStyleNone,
    1 => SCShareableContentStyleWindow,
    2 => SCShareableContentStyleDisplay,
    3 => SCShareableContentStyleApplication,
    _ => throw ArgumentError(
      'Unknown value for SCShareableContentStyle: $value',
    ),
  };
}

late final _class_SCRunningApplication = objc.getClass("SCRunningApplication");
late final _sel_isKindOfClass_ = objc.registerName("isKindOfClass:");
final _objc_msgSend_19nvye5 = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Bool Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Pointer<objc.ObjCObjectImpl>,
        )
      >
    >()
    .asFunction<
      bool Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
        ffi.Pointer<objc.ObjCObjectImpl>,
      )
    >();
late final _sel_bundleIdentifier = objc.registerName("bundleIdentifier");
late final _sel_applicationName = objc.registerName("applicationName");
late final _sel_processID = objc.registerName("processID");
final _objc_msgSend_13yqbb6 = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Int Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
        )
      >
    >()
    .asFunction<
      int Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
      )
    >();
late final _sel_init = objc.registerName("init");
late final _sel_new = objc.registerName("new");
late final _sel_allocWithZone_ = objc.registerName("allocWithZone:");
final _objc_msgSend_1cwp428 = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Pointer<objc.ObjCObjectImpl> Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Pointer<objc.NSZone>,
        )
      >
    >()
    .asFunction<
      ffi.Pointer<objc.ObjCObjectImpl> Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
        ffi.Pointer<objc.NSZone>,
      )
    >();
late final _sel_alloc = objc.registerName("alloc");

/// SCRunningApplication
extension type SCRunningApplication._(objc.ObjCObject object$)
    implements objc.ObjCObject, objc.NSObject {
  /// Constructs a [SCRunningApplication] that points to the same underlying object as [other].
  SCRunningApplication.as(objc.ObjCObject other) : object$ = other {
    objc.checkOsVersionInternal(
      'SCRunningApplication',
      macOS: (false, (12, 3, 0)),
    );
    assert(isA(object$));
  }

  /// Constructs a [SCRunningApplication] that wraps the given raw object pointer.
  SCRunningApplication.fromPointer(
    ffi.Pointer<objc.ObjCObjectImpl> other, {
    bool retain = false,
    bool release = false,
  }) : object$ = objc.ObjCObject(other, retain: retain, release: release) {
    objc.checkOsVersionInternal(
      'SCRunningApplication',
      macOS: (false, (12, 3, 0)),
    );
    assert(isA(object$));
  }

  /// Returns whether [obj] is an instance of [SCRunningApplication].
  static bool isA(objc.ObjCObject obj) => _objc_msgSend_19nvye5(
    obj.ref.pointer,
    _sel_isKindOfClass_,
    _class_SCRunningApplication,
  );

  /// alloc
  static SCRunningApplication alloc() {
    final $ret = _objc_msgSend_151sglz(_class_SCRunningApplication, _sel_alloc);
    return SCRunningApplication.fromPointer($ret, retain: false, release: true);
  }

  /// allocWithZone:
  static SCRunningApplication allocWithZone(ffi.Pointer<objc.NSZone> zone) {
    final $ret = _objc_msgSend_1cwp428(
      _class_SCRunningApplication,
      _sel_allocWithZone_,
      zone,
    );
    return SCRunningApplication.fromPointer($ret, retain: false, release: true);
  }

  /// new
  static SCRunningApplication new$() {
    final $ret = _objc_msgSend_151sglz(_class_SCRunningApplication, _sel_new);
    return SCRunningApplication.fromPointer($ret, retain: false, release: true);
  }

  /// Returns a new instance of SCRunningApplication constructed with the default `new` method.
  SCRunningApplication() : this.as(new$().object$);
}

extension SCRunningApplication$Methods on SCRunningApplication {
  /// applicationName
  objc.NSString get applicationName {
    objc.checkOsVersionInternal(
      'SCRunningApplication.applicationName',
      macOS: (false, (12, 3, 0)),
    );
    final $ret = _objc_msgSend_151sglz(
      object$.ref.pointer,
      _sel_applicationName,
    );
    return objc.NSString.fromPointer($ret, retain: true, release: true);
  }

  /// bundleIdentifier
  objc.NSString get bundleIdentifier {
    objc.checkOsVersionInternal(
      'SCRunningApplication.bundleIdentifier',
      macOS: (false, (12, 3, 0)),
    );
    final $ret = _objc_msgSend_151sglz(
      object$.ref.pointer,
      _sel_bundleIdentifier,
    );
    return objc.NSString.fromPointer($ret, retain: true, release: true);
  }

  /// init
  SCRunningApplication init() {
    objc.checkOsVersionInternal(
      'SCRunningApplication.init',
      iOS: (false, (2, 0, 0)),
      macOS: (false, (10, 0, 0)),
    );
    final $ret = _objc_msgSend_151sglz(
      object$.ref.retainAndReturnPointer(),
      _sel_init,
    );
    return SCRunningApplication.fromPointer($ret, retain: false, release: true);
  }

  /// processID
  int get processID {
    objc.checkOsVersionInternal(
      'SCRunningApplication.processID',
      macOS: (false, (12, 3, 0)),
    );
    return _objc_msgSend_13yqbb6(object$.ref.pointer, _sel_processID);
  }
}

late final _class_SCWindow = objc.getClass("SCWindow");
late final _sel_windowID = objc.registerName("windowID");
final _objc_msgSend_usggvf = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Uint32 Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
        )
      >
    >()
    .asFunction<
      int Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
      )
    >();
late final _sel_frame = objc.registerName("frame");
final _objc_msgSend_bu1hbw = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        objc.CGRect Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
        )
      >
    >()
    .asFunction<
      objc.CGRect Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
      )
    >();
final _objc_msgSend_bu1hbwStret = objc.msgSendStretPointer
    .cast<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<objc.CGRect>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
        )
      >
    >()
    .asFunction<
      void Function(
        ffi.Pointer<objc.CGRect>,
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
      )
    >();
late final _sel_title = objc.registerName("title");
late final _sel_windowLayer = objc.registerName("windowLayer");
final _objc_msgSend_1hz7y9r = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Long Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
        )
      >
    >()
    .asFunction<
      int Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
      )
    >();
late final _sel_owningApplication = objc.registerName("owningApplication");
late final _sel_isOnScreen = objc.registerName("isOnScreen");
final _objc_msgSend_91o635 = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Bool Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
        )
      >
    >()
    .asFunction<
      bool Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
      )
    >();
late final _sel_isActive = objc.registerName("isActive");

/// SCWindow
extension type SCWindow._(objc.ObjCObject object$)
    implements objc.ObjCObject, objc.NSObject {
  /// Constructs a [SCWindow] that points to the same underlying object as [other].
  SCWindow.as(objc.ObjCObject other) : object$ = other {
    objc.checkOsVersionInternal('SCWindow', macOS: (false, (12, 3, 0)));
    assert(isA(object$));
  }

  /// Constructs a [SCWindow] that wraps the given raw object pointer.
  SCWindow.fromPointer(
    ffi.Pointer<objc.ObjCObjectImpl> other, {
    bool retain = false,
    bool release = false,
  }) : object$ = objc.ObjCObject(other, retain: retain, release: release) {
    objc.checkOsVersionInternal('SCWindow', macOS: (false, (12, 3, 0)));
    assert(isA(object$));
  }

  /// Returns whether [obj] is an instance of [SCWindow].
  static bool isA(objc.ObjCObject obj) => _objc_msgSend_19nvye5(
    obj.ref.pointer,
    _sel_isKindOfClass_,
    _class_SCWindow,
  );

  /// alloc
  static SCWindow alloc() {
    final $ret = _objc_msgSend_151sglz(_class_SCWindow, _sel_alloc);
    return SCWindow.fromPointer($ret, retain: false, release: true);
  }

  /// allocWithZone:
  static SCWindow allocWithZone(ffi.Pointer<objc.NSZone> zone) {
    final $ret = _objc_msgSend_1cwp428(
      _class_SCWindow,
      _sel_allocWithZone_,
      zone,
    );
    return SCWindow.fromPointer($ret, retain: false, release: true);
  }

  /// new
  static SCWindow new$() {
    final $ret = _objc_msgSend_151sglz(_class_SCWindow, _sel_new);
    return SCWindow.fromPointer($ret, retain: false, release: true);
  }

  /// Returns a new instance of SCWindow constructed with the default `new` method.
  SCWindow() : this.as(new$().object$);
}

extension SCWindow$Methods on SCWindow {
  /// frame
  objc.CGRect get frame {
    objc.checkOsVersionInternal('SCWindow.frame', macOS: (false, (12, 3, 0)));
    final $ptr = pkg_ffi.calloc<objc.CGRect>();
    objc.useMsgSendVariants
        ? _objc_msgSend_bu1hbwStret($ptr, object$.ref.pointer, _sel_frame)
        : $ptr.ref = _objc_msgSend_bu1hbw(object$.ref.pointer, _sel_frame);
    final $finalizable = $ptr.cast<ffi.Uint8>().asTypedList(
      ffi.sizeOf<objc.CGRect>(),
      finalizer: pkg_ffi.calloc.nativeFree,
    );
    return ffi.Struct.create<objc.CGRect>($finalizable);
  }

  /// init
  SCWindow init() {
    objc.checkOsVersionInternal(
      'SCWindow.init',
      iOS: (false, (2, 0, 0)),
      macOS: (false, (10, 0, 0)),
    );
    final $ret = _objc_msgSend_151sglz(
      object$.ref.retainAndReturnPointer(),
      _sel_init,
    );
    return SCWindow.fromPointer($ret, retain: false, release: true);
  }

  /// isActive
  bool get isActive {
    objc.checkOsVersionInternal(
      'SCWindow.isActive',
      macOS: (false, (13, 1, 0)),
    );
    return _objc_msgSend_91o635(object$.ref.pointer, _sel_isActive);
  }

  /// isOnScreen
  bool get isOnScreen {
    objc.checkOsVersionInternal(
      'SCWindow.isOnScreen',
      macOS: (false, (12, 3, 0)),
    );
    return _objc_msgSend_91o635(object$.ref.pointer, _sel_isOnScreen);
  }

  /// owningApplication
  SCRunningApplication? get owningApplication {
    objc.checkOsVersionInternal(
      'SCWindow.owningApplication',
      macOS: (false, (12, 3, 0)),
    );
    final $ret = _objc_msgSend_151sglz(
      object$.ref.pointer,
      _sel_owningApplication,
    );
    return $ret.address == 0
        ? null
        : SCRunningApplication.fromPointer($ret, retain: true, release: true);
  }

  /// title
  objc.NSString? get title {
    objc.checkOsVersionInternal('SCWindow.title', macOS: (false, (12, 3, 0)));
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_title);
    return $ret.address == 0
        ? null
        : objc.NSString.fromPointer($ret, retain: true, release: true);
  }

  /// windowID
  int get windowID {
    objc.checkOsVersionInternal(
      'SCWindow.windowID',
      macOS: (false, (12, 3, 0)),
    );
    return _objc_msgSend_usggvf(object$.ref.pointer, _sel_windowID);
  }

  /// windowLayer
  int get windowLayer {
    objc.checkOsVersionInternal(
      'SCWindow.windowLayer',
      macOS: (false, (12, 3, 0)),
    );
    return _objc_msgSend_1hz7y9r(object$.ref.pointer, _sel_windowLayer);
  }
}

late final _class_SCDisplay = objc.getClass("SCDisplay");
late final _sel_displayID = objc.registerName("displayID");
late final _sel_width = objc.registerName("width");
late final _sel_height = objc.registerName("height");

/// SCDisplay
extension type SCDisplay._(objc.ObjCObject object$)
    implements objc.ObjCObject, objc.NSObject {
  /// Constructs a [SCDisplay] that points to the same underlying object as [other].
  SCDisplay.as(objc.ObjCObject other) : object$ = other {
    objc.checkOsVersionInternal('SCDisplay', macOS: (false, (12, 3, 0)));
    assert(isA(object$));
  }

  /// Constructs a [SCDisplay] that wraps the given raw object pointer.
  SCDisplay.fromPointer(
    ffi.Pointer<objc.ObjCObjectImpl> other, {
    bool retain = false,
    bool release = false,
  }) : object$ = objc.ObjCObject(other, retain: retain, release: release) {
    objc.checkOsVersionInternal('SCDisplay', macOS: (false, (12, 3, 0)));
    assert(isA(object$));
  }

  /// Returns whether [obj] is an instance of [SCDisplay].
  static bool isA(objc.ObjCObject obj) => _objc_msgSend_19nvye5(
    obj.ref.pointer,
    _sel_isKindOfClass_,
    _class_SCDisplay,
  );

  /// alloc
  static SCDisplay alloc() {
    final $ret = _objc_msgSend_151sglz(_class_SCDisplay, _sel_alloc);
    return SCDisplay.fromPointer($ret, retain: false, release: true);
  }

  /// allocWithZone:
  static SCDisplay allocWithZone(ffi.Pointer<objc.NSZone> zone) {
    final $ret = _objc_msgSend_1cwp428(
      _class_SCDisplay,
      _sel_allocWithZone_,
      zone,
    );
    return SCDisplay.fromPointer($ret, retain: false, release: true);
  }

  /// new
  static SCDisplay new$() {
    final $ret = _objc_msgSend_151sglz(_class_SCDisplay, _sel_new);
    return SCDisplay.fromPointer($ret, retain: false, release: true);
  }

  /// Returns a new instance of SCDisplay constructed with the default `new` method.
  SCDisplay() : this.as(new$().object$);
}

extension SCDisplay$Methods on SCDisplay {
  /// displayID
  int get displayID {
    objc.checkOsVersionInternal(
      'SCDisplay.displayID',
      macOS: (false, (12, 3, 0)),
    );
    return _objc_msgSend_usggvf(object$.ref.pointer, _sel_displayID);
  }

  /// frame
  objc.CGRect get frame {
    objc.checkOsVersionInternal('SCDisplay.frame', macOS: (false, (12, 3, 0)));
    final $ptr = pkg_ffi.calloc<objc.CGRect>();
    objc.useMsgSendVariants
        ? _objc_msgSend_bu1hbwStret($ptr, object$.ref.pointer, _sel_frame)
        : $ptr.ref = _objc_msgSend_bu1hbw(object$.ref.pointer, _sel_frame);
    final $finalizable = $ptr.cast<ffi.Uint8>().asTypedList(
      ffi.sizeOf<objc.CGRect>(),
      finalizer: pkg_ffi.calloc.nativeFree,
    );
    return ffi.Struct.create<objc.CGRect>($finalizable);
  }

  /// height
  int get height {
    objc.checkOsVersionInternal('SCDisplay.height', macOS: (false, (12, 3, 0)));
    return _objc_msgSend_1hz7y9r(object$.ref.pointer, _sel_height);
  }

  /// init
  SCDisplay init() {
    objc.checkOsVersionInternal(
      'SCDisplay.init',
      iOS: (false, (2, 0, 0)),
      macOS: (false, (10, 0, 0)),
    );
    final $ret = _objc_msgSend_151sglz(
      object$.ref.retainAndReturnPointer(),
      _sel_init,
    );
    return SCDisplay.fromPointer($ret, retain: false, release: true);
  }

  /// width
  int get width {
    objc.checkOsVersionInternal('SCDisplay.width', macOS: (false, (12, 3, 0)));
    return _objc_msgSend_1hz7y9r(object$.ref.pointer, _sel_width);
  }
}

/// WARNING: SCShareableContentInfo is a stub. To generate bindings for this class, include
/// SCShareableContentInfo in your config's objc-interfaces list.
///
/// SCShareableContentInfo
extension type SCShareableContentInfo._(objc.ObjCObject object$)
    implements objc.ObjCObject, objc.NSObject {
  /// Constructs a [SCShareableContentInfo] that points to the same underlying object as [other].
  SCShareableContentInfo.as(objc.ObjCObject other) : object$ = other {
    objc.checkOsVersionInternal(
      'SCShareableContentInfo',
      macOS: (false, (14, 0, 0)),
    );
  }

  /// Constructs a [SCShareableContentInfo] that wraps the given raw object pointer.
  SCShareableContentInfo.fromPointer(
    ffi.Pointer<objc.ObjCObjectImpl> other, {
    bool retain = false,
    bool release = false,
  }) : object$ = objc.ObjCObject(other, retain: retain, release: release) {
    objc.checkOsVersionInternal(
      'SCShareableContentInfo',
      macOS: (false, (14, 0, 0)),
    );
  }
}

late final _class_SCShareableContent = objc.getClass("SCShareableContent");

/// Construction methods for `objc.ObjCBlock<ffi.Void Function(SCShareableContent?, objc.NSError?)>`.
abstract final class ObjCBlock_ffiVoid_SCShareableContent_NSError {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<ffi.Void Function(SCShareableContent?, objc.NSError?)>
  fromPointer(
    ffi.Pointer<objc.ObjCBlockImpl> pointer, {
    bool retain = false,
    bool release = false,
  }) => objc.ObjCBlock<ffi.Void Function(SCShareableContent?, objc.NSError?)>(
    pointer,
    retain: retain,
    release: release,
  );

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<ffi.Void Function(SCShareableContent?, objc.NSError?)>
  fromFunctionPointer(
    ffi.Pointer<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<objc.ObjCObjectImpl> arg0,
          ffi.Pointer<objc.ObjCObjectImpl> arg1,
        )
      >
    >
    ptr,
  ) => objc.ObjCBlock<ffi.Void Function(SCShareableContent?, objc.NSError?)>(
    objc.newPointerBlock(_fnPtrCallable, ptr.cast()),
    retain: false,
    release: true,
  );

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Void Function(SCShareableContent?, objc.NSError?)>
  fromFunction(
    void Function(SCShareableContent?, objc.NSError?) fn, {
    bool keepIsolateAlive = true,
  }) => objc.ObjCBlock<ffi.Void Function(SCShareableContent?, objc.NSError?)>(
    objc.newClosureBlock(
      _closureCallable,
      (
        ffi.Pointer<objc.ObjCObjectImpl> arg0,
        ffi.Pointer<objc.ObjCObjectImpl> arg1,
      ) => fn(
        arg0.address == 0
            ? null
            : SCShareableContent.fromPointer(arg0, retain: true, release: true),
        arg1.address == 0
            ? null
            : objc.NSError.fromPointer(arg1, retain: true, release: true),
      ),
      keepIsolateAlive,
    ),
    retain: false,
    release: true,
  );

  /// Creates a listener block from a Dart function.
  ///
  /// This is based on FFI's NativeCallable.listener, and has the same
  /// capabilities and limitations. This block can be invoked from any thread,
  /// but only supports void functions, and is not run synchronously. See
  /// NativeCallable.listener for more details.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Void Function(SCShareableContent?, objc.NSError?)>
  listener(
    void Function(SCShareableContent?, objc.NSError?) fn, {
    bool keepIsolateAlive = true,
  }) {
    final raw = objc.newClosureBlock(
      _listenerCallable.nativeFunction.cast(),
      (
        ffi.Pointer<objc.ObjCObjectImpl> arg0,
        ffi.Pointer<objc.ObjCObjectImpl> arg1,
      ) => fn(
        arg0.address == 0
            ? null
            : SCShareableContent.fromPointer(
                arg0,
                retain: false,
                release: true,
              ),
        arg1.address == 0
            ? null
            : objc.NSError.fromPointer(arg1, retain: false, release: true),
      ),
      keepIsolateAlive,
    );
    final wrapper = _NativeLibrary_wrapListenerBlock_pfv6jd(raw);
    objc.objectRelease(raw.cast());
    return objc.ObjCBlock<
      ffi.Void Function(SCShareableContent?, objc.NSError?)
    >(wrapper, retain: false, release: true);
  }

  /// Creates a blocking block from a Dart function.
  ///
  /// This callback can be invoked from any native thread, and will block the
  /// caller until the callback is handled by the Dart isolate that created
  /// the block. Async functions are not supported.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC. If the owner isolate
  /// has shut down, and the block is invoked by native code, it may block
  /// indefinitely, or have other undefined behavior.
  static objc.ObjCBlock<ffi.Void Function(SCShareableContent?, objc.NSError?)>
  blocking(
    void Function(SCShareableContent?, objc.NSError?) fn, {
    bool keepIsolateAlive = true,
  }) {
    final raw = objc.newClosureBlock(
      _blockingCallable.nativeFunction.cast(),
      (
        ffi.Pointer<objc.ObjCObjectImpl> arg0,
        ffi.Pointer<objc.ObjCObjectImpl> arg1,
      ) => fn(
        arg0.address == 0
            ? null
            : SCShareableContent.fromPointer(
                arg0,
                retain: false,
                release: true,
              ),
        arg1.address == 0
            ? null
            : objc.NSError.fromPointer(arg1, retain: false, release: true),
      ),
      keepIsolateAlive,
    );
    final rawListener = objc.newClosureBlock(
      _blockingListenerCallable.nativeFunction.cast(),
      (
        ffi.Pointer<objc.ObjCObjectImpl> arg0,
        ffi.Pointer<objc.ObjCObjectImpl> arg1,
      ) => fn(
        arg0.address == 0
            ? null
            : SCShareableContent.fromPointer(
                arg0,
                retain: false,
                release: true,
              ),
        arg1.address == 0
            ? null
            : objc.NSError.fromPointer(arg1, retain: false, release: true),
      ),
      keepIsolateAlive,
    );
    final wrapper = _NativeLibrary_wrapBlockingBlock_pfv6jd(
      raw,
      rawListener,
      objc.objCContext,
    );
    objc.objectRelease(raw.cast());
    objc.objectRelease(rawListener.cast());
    return objc.ObjCBlock<
      ffi.Void Function(SCShareableContent?, objc.NSError?)
    >(wrapper, retain: false, release: true);
  }

  static void _listenerTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<objc.ObjCObjectImpl> arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
  ) {
    (objc.getBlockClosure(block)
        as void Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCObjectImpl>,
        ))(arg0, arg1);
    objc.objectRelease(block.cast());
  }

  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<objc.ObjCObjectImpl>,
      ffi.Pointer<objc.ObjCObjectImpl>,
    )
  >
  _listenerCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          )
        >.listener(_listenerTrampoline)
        ..keepIsolateAlive = false;
  static void _blockingTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> waiter,
    ffi.Pointer<objc.ObjCObjectImpl> arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
  ) {
    try {
      (objc.getBlockClosure(block)
          as void Function(
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          ))(arg0, arg1);
    } catch (e) {
    } finally {
      objc.signalWaiter(waiter);
      objc.objectRelease(block.cast());
    }
  }

  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<objc.ObjCObjectImpl>,
      ffi.Pointer<objc.ObjCObjectImpl>,
    )
  >
  _blockingCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          )
        >.isolateLocal(_blockingTrampoline)
        ..keepIsolateAlive = false;
  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<objc.ObjCObjectImpl>,
      ffi.Pointer<objc.ObjCObjectImpl>,
    )
  >
  _blockingListenerCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          )
        >.listener(_blockingTrampoline)
        ..keepIsolateAlive = false;
  static void _fnPtrTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<objc.ObjCObjectImpl> arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
  ) => block.ref.target
      .cast<
        ffi.NativeFunction<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCObjectImpl> arg0,
            ffi.Pointer<objc.ObjCObjectImpl> arg1,
          )
        >
      >()
      .asFunction<
        void Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCObjectImpl>,
        )
      >()(arg0, arg1);
  static ffi.Pointer<ffi.Void> _fnPtrCallable =
      ffi.Pointer.fromFunction<
            ffi.Void Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<objc.ObjCObjectImpl>,
              ffi.Pointer<objc.ObjCObjectImpl>,
            )
          >(_fnPtrTrampoline)
          .cast();
  static void _closureTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<objc.ObjCObjectImpl> arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
  ) =>
      (objc.getBlockClosure(block)
          as void Function(
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          ))(arg0, arg1);
  static ffi.Pointer<ffi.Void> _closureCallable =
      ffi.Pointer.fromFunction<
            ffi.Void Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<objc.ObjCObjectImpl>,
              ffi.Pointer<objc.ObjCObjectImpl>,
            )
          >(_closureTrampoline)
          .cast();
}

/// Call operator for `objc.ObjCBlock<ffi.Void Function(SCShareableContent?, objc.NSError?)>`.
extension ObjCBlock_ffiVoid_SCShareableContent_NSError$CallExtension
    on objc.ObjCBlock<ffi.Void Function(SCShareableContent?, objc.NSError?)> {
  void call(SCShareableContent? arg0, objc.NSError? arg1) =>
      ref.pointer.ref.invoke
          .cast<
            ffi.NativeFunction<
              ffi.Void Function(
                ffi.Pointer<objc.ObjCBlockImpl> block,
                ffi.Pointer<objc.ObjCObjectImpl> arg0,
                ffi.Pointer<objc.ObjCObjectImpl> arg1,
              )
            >
          >()
          .asFunction<
            void Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<objc.ObjCObjectImpl>,
              ffi.Pointer<objc.ObjCObjectImpl>,
            )
          >()(
        ref.pointer,
        arg0?.ref.pointer ?? ffi.nullptr,
        arg1?.ref.pointer ?? ffi.nullptr,
      );
}

late final _sel_getShareableContentWithCompletionHandler_ = objc.registerName(
  "getShareableContentWithCompletionHandler:",
);
final _objc_msgSend_f167m6 = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Pointer<objc.ObjCBlockImpl>,
        )
      >
    >()
    .asFunction<
      void Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
        ffi.Pointer<objc.ObjCBlockImpl>,
      )
    >();
late final _sel_getCurrentProcessShareableContentWithCompletionHandler_ = objc
    .registerName("getCurrentProcessShareableContentWithCompletionHandler:");
late final _sel_getShareableContentExcludingDesktopWindows_onScreenWindowsOnly_completionHandler_ =
    objc.registerName(
      "getShareableContentExcludingDesktopWindows:onScreenWindowsOnly:completionHandler:",
    );
final _objc_msgSend_1dik3tq = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Bool,
          ffi.Bool,
          ffi.Pointer<objc.ObjCBlockImpl>,
        )
      >
    >()
    .asFunction<
      void Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
        bool,
        bool,
        ffi.Pointer<objc.ObjCBlockImpl>,
      )
    >();
late final _sel_getShareableContentExcludingDesktopWindows_onScreenWindowsOnlyBelowWindow_completionHandler_ =
    objc.registerName(
      "getShareableContentExcludingDesktopWindows:onScreenWindowsOnlyBelowWindow:completionHandler:",
    );
final _objc_msgSend_1oby3xk = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Bool,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCBlockImpl>,
        )
      >
    >()
    .asFunction<
      void Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
        bool,
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCBlockImpl>,
      )
    >();
late final _sel_getShareableContentExcludingDesktopWindows_onScreenWindowsOnlyAboveWindow_completionHandler_ =
    objc.registerName(
      "getShareableContentExcludingDesktopWindows:onScreenWindowsOnlyAboveWindow:completionHandler:",
    );
late final _class_SCContentFilter = objc.getClass("SCContentFilter");

enum SCStreamType {
  SCStreamTypeWindow(0),
  SCStreamTypeDisplay(1);

  final int value;
  const SCStreamType(this.value);

  static SCStreamType fromValue(int value) => switch (value) {
    0 => SCStreamTypeWindow,
    1 => SCStreamTypeDisplay,
    _ => throw ArgumentError('Unknown value for SCStreamType: $value'),
  };
}

late final _sel_streamType = objc.registerName("streamType");
final _objc_msgSend_iwlyr3 = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Long Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
        )
      >
    >()
    .asFunction<
      int Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
      )
    >();
late final _sel_style = objc.registerName("style");
final _objc_msgSend_1h6ewvo = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Long Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
        )
      >
    >()
    .asFunction<
      int Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
      )
    >();
late final _sel_pointPixelScale = objc.registerName("pointPixelScale");
final _objc_msgSend_2cgrxl = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Float Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
        )
      >
    >()
    .asFunction<
      double Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
      )
    >();
final _objc_msgSend_2cgrxlFpret = objc.msgSendFpretPointer
    .cast<
      ffi.NativeFunction<
        ffi.Float Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
        )
      >
    >()
    .asFunction<
      double Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
      )
    >();
late final _sel_contentRect = objc.registerName("contentRect");
late final _sel_includeMenuBar = objc.registerName("includeMenuBar");
late final _sel_setIncludeMenuBar_ = objc.registerName("setIncludeMenuBar:");
final _objc_msgSend_1s56lr9 = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Bool,
        )
      >
    >()
    .asFunction<
      void Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
        bool,
      )
    >();
late final _sel_includedDisplays = objc.registerName("includedDisplays");
late final _sel_includedApplications = objc.registerName(
  "includedApplications",
);
late final _sel_includedWindows = objc.registerName("includedWindows");
late final _sel_initWithDesktopIndependentWindow_ = objc.registerName(
  "initWithDesktopIndependentWindow:",
);
late final _sel_initWithDisplay_excludingWindows_ = objc.registerName(
  "initWithDisplay:excludingWindows:",
);
final _objc_msgSend_15qeuct = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Pointer<objc.ObjCObjectImpl> Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCObjectImpl>,
        )
      >
    >()
    .asFunction<
      ffi.Pointer<objc.ObjCObjectImpl> Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCObjectImpl>,
      )
    >();
late final _sel_initWithDisplay_includingWindows_ = objc.registerName(
  "initWithDisplay:includingWindows:",
);
late final _sel_initWithDisplay_includingApplications_exceptingWindows_ = objc
    .registerName("initWithDisplay:includingApplications:exceptingWindows:");
final _objc_msgSend_11spmsz = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Pointer<objc.ObjCObjectImpl> Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCObjectImpl>,
        )
      >
    >()
    .asFunction<
      ffi.Pointer<objc.ObjCObjectImpl> Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCObjectImpl>,
      )
    >();
late final _sel_initWithDisplay_excludingApplications_exceptingWindows_ = objc
    .registerName("initWithDisplay:excludingApplications:exceptingWindows:");

/// SCContentFilter
extension type SCContentFilter._(objc.ObjCObject object$)
    implements objc.ObjCObject, objc.NSObject {
  /// Constructs a [SCContentFilter] that points to the same underlying object as [other].
  SCContentFilter.as(objc.ObjCObject other) : object$ = other {
    objc.checkOsVersionInternal('SCContentFilter', macOS: (false, (12, 3, 0)));
    assert(isA(object$));
  }

  /// Constructs a [SCContentFilter] that wraps the given raw object pointer.
  SCContentFilter.fromPointer(
    ffi.Pointer<objc.ObjCObjectImpl> other, {
    bool retain = false,
    bool release = false,
  }) : object$ = objc.ObjCObject(other, retain: retain, release: release) {
    objc.checkOsVersionInternal('SCContentFilter', macOS: (false, (12, 3, 0)));
    assert(isA(object$));
  }

  /// Returns whether [obj] is an instance of [SCContentFilter].
  static bool isA(objc.ObjCObject obj) => _objc_msgSend_19nvye5(
    obj.ref.pointer,
    _sel_isKindOfClass_,
    _class_SCContentFilter,
  );

  /// alloc
  static SCContentFilter alloc() {
    final $ret = _objc_msgSend_151sglz(_class_SCContentFilter, _sel_alloc);
    return SCContentFilter.fromPointer($ret, retain: false, release: true);
  }

  /// allocWithZone:
  static SCContentFilter allocWithZone(ffi.Pointer<objc.NSZone> zone) {
    final $ret = _objc_msgSend_1cwp428(
      _class_SCContentFilter,
      _sel_allocWithZone_,
      zone,
    );
    return SCContentFilter.fromPointer($ret, retain: false, release: true);
  }

  /// new
  static SCContentFilter new$() {
    final $ret = _objc_msgSend_151sglz(_class_SCContentFilter, _sel_new);
    return SCContentFilter.fromPointer($ret, retain: false, release: true);
  }

  /// Returns a new instance of SCContentFilter constructed with the default `new` method.
  SCContentFilter() : this.as(new$().object$);
}

extension SCContentFilter$Methods on SCContentFilter {
  /// contentRect
  objc.CGRect get contentRect {
    objc.checkOsVersionInternal(
      'SCContentFilter.contentRect',
      macOS: (false, (14, 0, 0)),
    );
    final $ptr = pkg_ffi.calloc<objc.CGRect>();
    objc.useMsgSendVariants
        ? _objc_msgSend_bu1hbwStret($ptr, object$.ref.pointer, _sel_contentRect)
        : $ptr.ref = _objc_msgSend_bu1hbw(
            object$.ref.pointer,
            _sel_contentRect,
          );
    final $finalizable = $ptr.cast<ffi.Uint8>().asTypedList(
      ffi.sizeOf<objc.CGRect>(),
      finalizer: pkg_ffi.calloc.nativeFree,
    );
    return ffi.Struct.create<objc.CGRect>($finalizable);
  }

  /// includeMenuBar
  bool get includeMenuBar {
    objc.checkOsVersionInternal(
      'SCContentFilter.includeMenuBar',
      macOS: (false, (14, 2, 0)),
    );
    return _objc_msgSend_91o635(object$.ref.pointer, _sel_includeMenuBar);
  }

  /// includedApplications
  objc.NSArray get includedApplications {
    objc.checkOsVersionInternal(
      'SCContentFilter.includedApplications',
      macOS: (false, (15, 2, 0)),
    );
    final $ret = _objc_msgSend_151sglz(
      object$.ref.pointer,
      _sel_includedApplications,
    );
    return objc.NSArray.fromPointer($ret, retain: true, release: true);
  }

  /// includedDisplays
  objc.NSArray get includedDisplays {
    objc.checkOsVersionInternal(
      'SCContentFilter.includedDisplays',
      macOS: (false, (15, 2, 0)),
    );
    final $ret = _objc_msgSend_151sglz(
      object$.ref.pointer,
      _sel_includedDisplays,
    );
    return objc.NSArray.fromPointer($ret, retain: true, release: true);
  }

  /// includedWindows
  objc.NSArray get includedWindows {
    objc.checkOsVersionInternal(
      'SCContentFilter.includedWindows',
      macOS: (false, (15, 2, 0)),
    );
    final $ret = _objc_msgSend_151sglz(
      object$.ref.pointer,
      _sel_includedWindows,
    );
    return objc.NSArray.fromPointer($ret, retain: true, release: true);
  }

  /// init
  SCContentFilter init() {
    objc.checkOsVersionInternal(
      'SCContentFilter.init',
      iOS: (false, (2, 0, 0)),
      macOS: (false, (10, 0, 0)),
    );
    final $ret = _objc_msgSend_151sglz(
      object$.ref.retainAndReturnPointer(),
      _sel_init,
    );
    return SCContentFilter.fromPointer($ret, retain: false, release: true);
  }

  /// initWithDesktopIndependentWindow:
  SCContentFilter initWithDesktopIndependentWindow(SCWindow window) {
    objc.checkOsVersionInternal(
      'SCContentFilter.initWithDesktopIndependentWindow:',
      macOS: (false, (12, 3, 0)),
    );
    final $ret = _objc_msgSend_1sotr3r(
      object$.ref.retainAndReturnPointer(),
      _sel_initWithDesktopIndependentWindow_,
      window.ref.pointer,
    );
    return SCContentFilter.fromPointer($ret, retain: false, release: true);
  }

  /// initWithDisplay:excludingApplications:exceptingWindows:
  SCContentFilter initWithDisplay(
    SCDisplay display, {
    required objc.NSArray excludingApplications,
    required objc.NSArray exceptingWindows,
  }) {
    objc.checkOsVersionInternal(
      'SCContentFilter.initWithDisplay:excludingApplications:exceptingWindows:',
      macOS: (false, (12, 3, 0)),
    );
    final $ret = _objc_msgSend_11spmsz(
      object$.ref.retainAndReturnPointer(),
      _sel_initWithDisplay_excludingApplications_exceptingWindows_,
      display.ref.pointer,
      excludingApplications.ref.pointer,
      exceptingWindows.ref.pointer,
    );
    return SCContentFilter.fromPointer($ret, retain: false, release: true);
  }

  /// initWithDisplay:excludingWindows:
  SCContentFilter initWithDisplay$1(
    SCDisplay display, {
    required objc.NSArray excludingWindows,
  }) {
    objc.checkOsVersionInternal(
      'SCContentFilter.initWithDisplay:excludingWindows:',
      macOS: (false, (12, 3, 0)),
    );
    final $ret = _objc_msgSend_15qeuct(
      object$.ref.retainAndReturnPointer(),
      _sel_initWithDisplay_excludingWindows_,
      display.ref.pointer,
      excludingWindows.ref.pointer,
    );
    return SCContentFilter.fromPointer($ret, retain: false, release: true);
  }

  /// initWithDisplay:includingApplications:exceptingWindows:
  SCContentFilter initWithDisplay$2(
    SCDisplay display, {
    required objc.NSArray includingApplications,
    required objc.NSArray exceptingWindows,
  }) {
    objc.checkOsVersionInternal(
      'SCContentFilter.initWithDisplay:includingApplications:exceptingWindows:',
      macOS: (false, (12, 3, 0)),
    );
    final $ret = _objc_msgSend_11spmsz(
      object$.ref.retainAndReturnPointer(),
      _sel_initWithDisplay_includingApplications_exceptingWindows_,
      display.ref.pointer,
      includingApplications.ref.pointer,
      exceptingWindows.ref.pointer,
    );
    return SCContentFilter.fromPointer($ret, retain: false, release: true);
  }

  /// initWithDisplay:includingWindows:
  SCContentFilter initWithDisplay$3(
    SCDisplay display, {
    required objc.NSArray includingWindows,
  }) {
    objc.checkOsVersionInternal(
      'SCContentFilter.initWithDisplay:includingWindows:',
      macOS: (false, (12, 3, 0)),
    );
    final $ret = _objc_msgSend_15qeuct(
      object$.ref.retainAndReturnPointer(),
      _sel_initWithDisplay_includingWindows_,
      display.ref.pointer,
      includingWindows.ref.pointer,
    );
    return SCContentFilter.fromPointer($ret, retain: false, release: true);
  }

  /// pointPixelScale
  double get pointPixelScale {
    objc.checkOsVersionInternal(
      'SCContentFilter.pointPixelScale',
      macOS: (false, (14, 0, 0)),
    );
    return objc.useMsgSendVariants
        ? _objc_msgSend_2cgrxlFpret(object$.ref.pointer, _sel_pointPixelScale)
        : _objc_msgSend_2cgrxl(object$.ref.pointer, _sel_pointPixelScale);
  }

  /// setIncludeMenuBar:
  set includeMenuBar(bool value) {
    objc.checkOsVersionInternal(
      'SCContentFilter.setIncludeMenuBar:',
      macOS: (false, (14, 2, 0)),
    );
    _objc_msgSend_1s56lr9(object$.ref.pointer, _sel_setIncludeMenuBar_, value);
  }

  /// streamType
  SCStreamType get streamType {
    objc.checkOsVersionInternal(
      'SCContentFilter.streamType',
      macOS: (false, (14, 0, 0)),
    );
    final $ret = _objc_msgSend_iwlyr3(object$.ref.pointer, _sel_streamType);
    return SCStreamType.fromValue($ret);
  }

  /// style
  SCShareableContentStyle get style {
    objc.checkOsVersionInternal(
      'SCContentFilter.style',
      macOS: (false, (14, 0, 0)),
    );
    final $ret = _objc_msgSend_1h6ewvo(object$.ref.pointer, _sel_style);
    return SCShareableContentStyle.fromValue($ret);
  }
}

late final _sel_infoForFilter_ = objc.registerName("infoForFilter:");
late final _sel_windows = objc.registerName("windows");
late final _sel_displays = objc.registerName("displays");
late final _sel_applications = objc.registerName("applications");

/// SCShareableContent
extension type SCShareableContent._(objc.ObjCObject object$)
    implements objc.ObjCObject, objc.NSObject {
  /// Constructs a [SCShareableContent] that points to the same underlying object as [other].
  SCShareableContent.as(objc.ObjCObject other) : object$ = other {
    objc.checkOsVersionInternal(
      'SCShareableContent',
      macOS: (false, (12, 3, 0)),
    );
    assert(isA(object$));
  }

  /// Constructs a [SCShareableContent] that wraps the given raw object pointer.
  SCShareableContent.fromPointer(
    ffi.Pointer<objc.ObjCObjectImpl> other, {
    bool retain = false,
    bool release = false,
  }) : object$ = objc.ObjCObject(other, retain: retain, release: release) {
    objc.checkOsVersionInternal(
      'SCShareableContent',
      macOS: (false, (12, 3, 0)),
    );
    assert(isA(object$));
  }

  /// Returns whether [obj] is an instance of [SCShareableContent].
  static bool isA(objc.ObjCObject obj) => _objc_msgSend_19nvye5(
    obj.ref.pointer,
    _sel_isKindOfClass_,
    _class_SCShareableContent,
  );

  /// alloc
  static SCShareableContent alloc() {
    final $ret = _objc_msgSend_151sglz(_class_SCShareableContent, _sel_alloc);
    return SCShareableContent.fromPointer($ret, retain: false, release: true);
  }

  /// allocWithZone:
  static SCShareableContent allocWithZone(ffi.Pointer<objc.NSZone> zone) {
    final $ret = _objc_msgSend_1cwp428(
      _class_SCShareableContent,
      _sel_allocWithZone_,
      zone,
    );
    return SCShareableContent.fromPointer($ret, retain: false, release: true);
  }

  /// getCurrentProcessShareableContentWithCompletionHandler:
  static void getCurrentProcessShareableContentWithCompletionHandler(
    objc.ObjCBlock<ffi.Void Function(SCShareableContent?, objc.NSError?)>
    completionHandler,
  ) {
    objc.checkOsVersionInternal(
      'SCShareableContent.getCurrentProcessShareableContentWithCompletionHandler:',
      macOS: (false, (14, 4, 0)),
    );
    _objc_msgSend_f167m6(
      _class_SCShareableContent,
      _sel_getCurrentProcessShareableContentWithCompletionHandler_,
      completionHandler.ref.pointer,
    );
  }

  /// getShareableContentExcludingDesktopWindows:onScreenWindowsOnly:completionHandler:
  static void getShareableContentExcludingDesktopWindows(
    bool excludeDesktopWindows, {
    required bool onScreenWindowsOnly,
    required objc.ObjCBlock<
      ffi.Void Function(SCShareableContent?, objc.NSError?)
    >
    completionHandler,
  }) {
    objc.checkOsVersionInternal(
      'SCShareableContent.getShareableContentExcludingDesktopWindows:onScreenWindowsOnly:completionHandler:',
      macOS: (false, (12, 3, 0)),
    );
    _objc_msgSend_1dik3tq(
      _class_SCShareableContent,
      _sel_getShareableContentExcludingDesktopWindows_onScreenWindowsOnly_completionHandler_,
      excludeDesktopWindows,
      onScreenWindowsOnly,
      completionHandler.ref.pointer,
    );
  }

  /// getShareableContentExcludingDesktopWindows:onScreenWindowsOnlyAboveWindow:completionHandler:
  static void getShareableContentExcludingDesktopWindows$1(
    bool excludeDesktopWindows, {
    required SCWindow onScreenWindowsOnlyAboveWindow,
    required objc.ObjCBlock<
      ffi.Void Function(SCShareableContent?, objc.NSError?)
    >
    completionHandler,
  }) {
    objc.checkOsVersionInternal(
      'SCShareableContent.getShareableContentExcludingDesktopWindows:onScreenWindowsOnlyAboveWindow:completionHandler:',
      macOS: (false, (12, 3, 0)),
    );
    _objc_msgSend_1oby3xk(
      _class_SCShareableContent,
      _sel_getShareableContentExcludingDesktopWindows_onScreenWindowsOnlyAboveWindow_completionHandler_,
      excludeDesktopWindows,
      onScreenWindowsOnlyAboveWindow.ref.pointer,
      completionHandler.ref.pointer,
    );
  }

  /// getShareableContentExcludingDesktopWindows:onScreenWindowsOnlyBelowWindow:completionHandler:
  static void getShareableContentExcludingDesktopWindows$2(
    bool excludeDesktopWindows, {
    required SCWindow onScreenWindowsOnlyBelowWindow,
    required objc.ObjCBlock<
      ffi.Void Function(SCShareableContent?, objc.NSError?)
    >
    completionHandler,
  }) {
    objc.checkOsVersionInternal(
      'SCShareableContent.getShareableContentExcludingDesktopWindows:onScreenWindowsOnlyBelowWindow:completionHandler:',
      macOS: (false, (12, 3, 0)),
    );
    _objc_msgSend_1oby3xk(
      _class_SCShareableContent,
      _sel_getShareableContentExcludingDesktopWindows_onScreenWindowsOnlyBelowWindow_completionHandler_,
      excludeDesktopWindows,
      onScreenWindowsOnlyBelowWindow.ref.pointer,
      completionHandler.ref.pointer,
    );
  }

  /// getShareableContentWithCompletionHandler:
  static void getShareableContentWithCompletionHandler(
    objc.ObjCBlock<ffi.Void Function(SCShareableContent?, objc.NSError?)>
    completionHandler,
  ) {
    objc.checkOsVersionInternal(
      'SCShareableContent.getShareableContentWithCompletionHandler:',
      macOS: (false, (12, 3, 0)),
    );
    _objc_msgSend_f167m6(
      _class_SCShareableContent,
      _sel_getShareableContentWithCompletionHandler_,
      completionHandler.ref.pointer,
    );
  }

  /// infoForFilter:
  static SCShareableContentInfo infoForFilter(SCContentFilter filter) {
    objc.checkOsVersionInternal(
      'SCShareableContent.infoForFilter:',
      macOS: (false, (14, 0, 0)),
    );
    final $ret = _objc_msgSend_1sotr3r(
      _class_SCShareableContent,
      _sel_infoForFilter_,
      filter.ref.pointer,
    );
    return SCShareableContentInfo.fromPointer(
      $ret,
      retain: true,
      release: true,
    );
  }

  /// new
  static SCShareableContent new$() {
    final $ret = _objc_msgSend_151sglz(_class_SCShareableContent, _sel_new);
    return SCShareableContent.fromPointer($ret, retain: false, release: true);
  }

  /// Returns a new instance of SCShareableContent constructed with the default `new` method.
  SCShareableContent() : this.as(new$().object$);
}

extension SCShareableContent$Methods on SCShareableContent {
  /// applications
  objc.NSArray get applications {
    objc.checkOsVersionInternal(
      'SCShareableContent.applications',
      macOS: (false, (12, 3, 0)),
    );
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_applications);
    return objc.NSArray.fromPointer($ret, retain: true, release: true);
  }

  /// displays
  objc.NSArray get displays {
    objc.checkOsVersionInternal(
      'SCShareableContent.displays',
      macOS: (false, (12, 3, 0)),
    );
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_displays);
    return objc.NSArray.fromPointer($ret, retain: true, release: true);
  }

  /// init
  SCShareableContent init() {
    objc.checkOsVersionInternal(
      'SCShareableContent.init',
      iOS: (false, (2, 0, 0)),
      macOS: (false, (10, 0, 0)),
    );
    final $ret = _objc_msgSend_151sglz(
      object$.ref.retainAndReturnPointer(),
      _sel_init,
    );
    return SCShareableContent.fromPointer($ret, retain: false, release: true);
  }

  /// windows
  objc.NSArray get windows {
    objc.checkOsVersionInternal(
      'SCShareableContent.windows',
      macOS: (false, (12, 3, 0)),
    );
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_windows);
    return objc.NSArray.fromPointer($ret, retain: true, release: true);
  }
}

sealed class CMTimeFlags {
  static const kCMTimeFlags_Valid = 1;
  static const kCMTimeFlags_HasBeenRounded = 2;
  static const kCMTimeFlags_PositiveInfinity = 4;
  static const kCMTimeFlags_NegativeInfinity = 8;
  static const kCMTimeFlags_Indefinite = 16;
  static const kCMTimeFlags_ImpliedValueFlagsMask = 28;
}

@ffi.Packed(4)
final class CMTime extends ffi.Struct {
  @ffi.Int64()
  external int value;

  @ffi.Int32()
  external int timescale;

  @ffi.Uint32()
  external int flags;

  @ffi.Int64()
  external int epoch;
}

final class opaqueCMSampleBuffer extends ffi.Opaque {}

enum SCPresenterOverlayAlertSetting {
  SCPresenterOverlayAlertSettingSystem(0),
  SCPresenterOverlayAlertSettingNever(1),
  SCPresenterOverlayAlertSettingAlways(2);

  final int value;
  const SCPresenterOverlayAlertSetting(this.value);

  static SCPresenterOverlayAlertSetting fromValue(int value) => switch (value) {
    0 => SCPresenterOverlayAlertSettingSystem,
    1 => SCPresenterOverlayAlertSettingNever,
    2 => SCPresenterOverlayAlertSettingAlways,
    _ => throw ArgumentError(
      'Unknown value for SCPresenterOverlayAlertSetting: $value',
    ),
  };
}

enum SCCaptureResolutionType {
  SCCaptureResolutionAutomatic(0),
  SCCaptureResolutionBest(1),
  SCCaptureResolutionNominal(2);

  final int value;
  const SCCaptureResolutionType(this.value);

  static SCCaptureResolutionType fromValue(int value) => switch (value) {
    0 => SCCaptureResolutionAutomatic,
    1 => SCCaptureResolutionBest,
    2 => SCCaptureResolutionNominal,
    _ => throw ArgumentError(
      'Unknown value for SCCaptureResolutionType: $value',
    ),
  };
}

enum SCCaptureDynamicRange {
  SCCaptureDynamicRangeSDR(0),
  SCCaptureDynamicRangeHDRLocalDisplay(1),
  SCCaptureDynamicRangeHDRCanonicalDisplay(2);

  final int value;
  const SCCaptureDynamicRange(this.value);

  static SCCaptureDynamicRange fromValue(int value) => switch (value) {
    0 => SCCaptureDynamicRangeSDR,
    1 => SCCaptureDynamicRangeHDRLocalDisplay,
    2 => SCCaptureDynamicRangeHDRCanonicalDisplay,
    _ => throw ArgumentError('Unknown value for SCCaptureDynamicRange: $value'),
  };
}

late final _class_SCStreamConfiguration = objc.getClass(
  "SCStreamConfiguration",
);
final _objc_msgSend_h0gkbf = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Size Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
        )
      >
    >()
    .asFunction<
      int Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
      )
    >();
late final _sel_setWidth_ = objc.registerName("setWidth:");
final _objc_msgSend_6enxqz = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Size,
        )
      >
    >()
    .asFunction<
      void Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
        int,
      )
    >();
late final _sel_setHeight_ = objc.registerName("setHeight:");
late final _sel_minimumFrameInterval = objc.registerName(
  "minimumFrameInterval",
);
final _objc_msgSend_1f8hvjs = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        CMTime Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
        )
      >
    >()
    .asFunction<
      CMTime Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
      )
    >();
final _objc_msgSend_1f8hvjsStret = objc.msgSendStretPointer
    .cast<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<CMTime>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
        )
      >
    >()
    .asFunction<
      void Function(
        ffi.Pointer<CMTime>,
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
      )
    >();
late final _sel_setMinimumFrameInterval_ = objc.registerName(
  "setMinimumFrameInterval:",
);
final _objc_msgSend_1hznzoi = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
          CMTime,
        )
      >
    >()
    .asFunction<
      void Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
        CMTime,
      )
    >();
late final _sel_pixelFormat = objc.registerName("pixelFormat");
final _objc_msgSend_3pyzne = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.UnsignedInt Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
        )
      >
    >()
    .asFunction<
      int Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
      )
    >();
late final _sel_setPixelFormat_ = objc.registerName("setPixelFormat:");
final _objc_msgSend_hr7g6s = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.UnsignedInt,
        )
      >
    >()
    .asFunction<
      void Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
        int,
      )
    >();
late final _sel_scalesToFit = objc.registerName("scalesToFit");
late final _sel_setScalesToFit_ = objc.registerName("setScalesToFit:");
late final _sel_preservesAspectRatio = objc.registerName(
  "preservesAspectRatio",
);
late final _sel_setPreservesAspectRatio_ = objc.registerName(
  "setPreservesAspectRatio:",
);
late final _sel_streamName = objc.registerName("streamName");
late final _sel_setStreamName_ = objc.registerName("setStreamName:");
final _objc_msgSend_xtuoz7 = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Pointer<objc.ObjCObjectImpl>,
        )
      >
    >()
    .asFunction<
      void Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
        ffi.Pointer<objc.ObjCObjectImpl>,
      )
    >();
late final _sel_showsCursor = objc.registerName("showsCursor");
late final _sel_setShowsCursor_ = objc.registerName("setShowsCursor:");
late final _sel_showMouseClicks = objc.registerName("showMouseClicks");
late final _sel_setShowMouseClicks_ = objc.registerName("setShowMouseClicks:");
late final _sel_backgroundColor = objc.registerName("backgroundColor");
final _objc_msgSend_2u9jmz = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Pointer<CGColor> Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
        )
      >
    >()
    .asFunction<
      ffi.Pointer<CGColor> Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
      )
    >();
late final _sel_setBackgroundColor_ = objc.registerName("setBackgroundColor:");
final _objc_msgSend_1bz9pdz = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Pointer<CGColor>,
        )
      >
    >()
    .asFunction<
      void Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
        ffi.Pointer<CGColor>,
      )
    >();
late final _sel_sourceRect = objc.registerName("sourceRect");
late final _sel_setSourceRect_ = objc.registerName("setSourceRect:");
final _objc_msgSend_1okkq16 = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
          objc.CGRect,
        )
      >
    >()
    .asFunction<
      void Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
        objc.CGRect,
      )
    >();
late final _sel_destinationRect = objc.registerName("destinationRect");
late final _sel_setDestinationRect_ = objc.registerName("setDestinationRect:");
late final _sel_queueDepth = objc.registerName("queueDepth");
late final _sel_setQueueDepth_ = objc.registerName("setQueueDepth:");
final _objc_msgSend_4sp4xj = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Long,
        )
      >
    >()
    .asFunction<
      void Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
        int,
      )
    >();
late final _sel_colorMatrix = objc.registerName("colorMatrix");
final _objc_msgSend_8y9mw4 = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Pointer<objc.CFString> Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
        )
      >
    >()
    .asFunction<
      ffi.Pointer<objc.CFString> Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
      )
    >();
late final _sel_setColorMatrix_ = objc.registerName("setColorMatrix:");
final _objc_msgSend_1pty11y = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Pointer<objc.CFString>,
        )
      >
    >()
    .asFunction<
      void Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
        ffi.Pointer<objc.CFString>,
      )
    >();
late final _sel_colorSpaceName = objc.registerName("colorSpaceName");
late final _sel_setColorSpaceName_ = objc.registerName("setColorSpaceName:");
late final _sel_capturesAudio = objc.registerName("capturesAudio");
late final _sel_setCapturesAudio_ = objc.registerName("setCapturesAudio:");
late final _sel_sampleRate = objc.registerName("sampleRate");
late final _sel_setSampleRate_ = objc.registerName("setSampleRate:");
late final _sel_channelCount = objc.registerName("channelCount");
late final _sel_setChannelCount_ = objc.registerName("setChannelCount:");
late final _sel_excludesCurrentProcessAudio = objc.registerName(
  "excludesCurrentProcessAudio",
);
late final _sel_setExcludesCurrentProcessAudio_ = objc.registerName(
  "setExcludesCurrentProcessAudio:",
);
late final _sel_ignoreShadowsDisplay = objc.registerName(
  "ignoreShadowsDisplay",
);
late final _sel_setIgnoreShadowsDisplay_ = objc.registerName(
  "setIgnoreShadowsDisplay:",
);
late final _sel_ignoreShadowsSingleWindow = objc.registerName(
  "ignoreShadowsSingleWindow",
);
late final _sel_setIgnoreShadowsSingleWindow_ = objc.registerName(
  "setIgnoreShadowsSingleWindow:",
);
late final _sel_captureResolution = objc.registerName("captureResolution");
final _objc_msgSend_161z7fp = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Long Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
        )
      >
    >()
    .asFunction<
      int Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
      )
    >();
late final _sel_setCaptureResolution_ = objc.registerName(
  "setCaptureResolution:",
);
final _objc_msgSend_hcx7sl = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Long,
        )
      >
    >()
    .asFunction<
      void Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
        int,
      )
    >();
late final _sel_capturesShadowsOnly = objc.registerName("capturesShadowsOnly");
late final _sel_setCapturesShadowsOnly_ = objc.registerName(
  "setCapturesShadowsOnly:",
);
late final _sel_shouldBeOpaque = objc.registerName("shouldBeOpaque");
late final _sel_setShouldBeOpaque_ = objc.registerName("setShouldBeOpaque:");
late final _sel_ignoreGlobalClipDisplay = objc.registerName(
  "ignoreGlobalClipDisplay",
);
late final _sel_setIgnoreGlobalClipDisplay_ = objc.registerName(
  "setIgnoreGlobalClipDisplay:",
);
late final _sel_ignoreGlobalClipSingleWindow = objc.registerName(
  "ignoreGlobalClipSingleWindow",
);
late final _sel_setIgnoreGlobalClipSingleWindow_ = objc.registerName(
  "setIgnoreGlobalClipSingleWindow:",
);
late final _sel_presenterOverlayPrivacyAlertSetting = objc.registerName(
  "presenterOverlayPrivacyAlertSetting",
);
final _objc_msgSend_18wchwh = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Long Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
        )
      >
    >()
    .asFunction<
      int Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
      )
    >();
late final _sel_setPresenterOverlayPrivacyAlertSetting_ = objc.registerName(
  "setPresenterOverlayPrivacyAlertSetting:",
);
final _objc_msgSend_1jhpzcd = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Long,
        )
      >
    >()
    .asFunction<
      void Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
        int,
      )
    >();
late final _sel_includeChildWindows = objc.registerName("includeChildWindows");
late final _sel_setIncludeChildWindows_ = objc.registerName(
  "setIncludeChildWindows:",
);
late final _sel_captureMicrophone = objc.registerName("captureMicrophone");
late final _sel_setCaptureMicrophone_ = objc.registerName(
  "setCaptureMicrophone:",
);
late final _sel_microphoneCaptureDeviceID = objc.registerName(
  "microphoneCaptureDeviceID",
);
late final _sel_setMicrophoneCaptureDeviceID_ = objc.registerName(
  "setMicrophoneCaptureDeviceID:",
);
late final _sel_captureDynamicRange = objc.registerName("captureDynamicRange");
final _objc_msgSend_1bvr595 = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Long Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
        )
      >
    >()
    .asFunction<
      int Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
      )
    >();
late final _sel_setCaptureDynamicRange_ = objc.registerName(
  "setCaptureDynamicRange:",
);
final _objc_msgSend_19zlydd = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Long,
        )
      >
    >()
    .asFunction<
      void Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
        int,
      )
    >();

enum SCStreamConfigurationPreset {
  SCStreamConfigurationPresetCaptureHDRStreamLocalDisplay(0),
  SCStreamConfigurationPresetCaptureHDRStreamCanonicalDisplay(1),
  SCStreamConfigurationPresetCaptureHDRScreenshotLocalDisplay(2),
  SCStreamConfigurationPresetCaptureHDRScreenshotCanonicalDisplay(3),
  SCStreamConfigurationPresetCaptureHDRRecordingPreservedSDRHDR10(4);

  final int value;
  const SCStreamConfigurationPreset(this.value);

  static SCStreamConfigurationPreset fromValue(int value) => switch (value) {
    0 => SCStreamConfigurationPresetCaptureHDRStreamLocalDisplay,
    1 => SCStreamConfigurationPresetCaptureHDRStreamCanonicalDisplay,
    2 => SCStreamConfigurationPresetCaptureHDRScreenshotLocalDisplay,
    3 => SCStreamConfigurationPresetCaptureHDRScreenshotCanonicalDisplay,
    4 => SCStreamConfigurationPresetCaptureHDRRecordingPreservedSDRHDR10,
    _ => throw ArgumentError(
      'Unknown value for SCStreamConfigurationPreset: $value',
    ),
  };
}

late final _sel_streamConfigurationWithPreset_ = objc.registerName(
  "streamConfigurationWithPreset:",
);
final _objc_msgSend_go053q = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Pointer<objc.ObjCObjectImpl> Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Long,
        )
      >
    >()
    .asFunction<
      ffi.Pointer<objc.ObjCObjectImpl> Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
        int,
      )
    >();

/// SCStreamConfiguration
extension type SCStreamConfiguration._(objc.ObjCObject object$)
    implements objc.ObjCObject, objc.NSObject {
  /// Constructs a [SCStreamConfiguration] that points to the same underlying object as [other].
  SCStreamConfiguration.as(objc.ObjCObject other) : object$ = other {
    objc.checkOsVersionInternal(
      'SCStreamConfiguration',
      macOS: (false, (12, 3, 0)),
    );
    assert(isA(object$));
  }

  /// Constructs a [SCStreamConfiguration] that wraps the given raw object pointer.
  SCStreamConfiguration.fromPointer(
    ffi.Pointer<objc.ObjCObjectImpl> other, {
    bool retain = false,
    bool release = false,
  }) : object$ = objc.ObjCObject(other, retain: retain, release: release) {
    objc.checkOsVersionInternal(
      'SCStreamConfiguration',
      macOS: (false, (12, 3, 0)),
    );
    assert(isA(object$));
  }

  /// Returns whether [obj] is an instance of [SCStreamConfiguration].
  static bool isA(objc.ObjCObject obj) => _objc_msgSend_19nvye5(
    obj.ref.pointer,
    _sel_isKindOfClass_,
    _class_SCStreamConfiguration,
  );

  /// alloc
  static SCStreamConfiguration alloc() {
    final $ret = _objc_msgSend_151sglz(
      _class_SCStreamConfiguration,
      _sel_alloc,
    );
    return SCStreamConfiguration.fromPointer(
      $ret,
      retain: false,
      release: true,
    );
  }

  /// allocWithZone:
  static SCStreamConfiguration allocWithZone(ffi.Pointer<objc.NSZone> zone) {
    final $ret = _objc_msgSend_1cwp428(
      _class_SCStreamConfiguration,
      _sel_allocWithZone_,
      zone,
    );
    return SCStreamConfiguration.fromPointer(
      $ret,
      retain: false,
      release: true,
    );
  }

  /// new
  static SCStreamConfiguration new$() {
    final $ret = _objc_msgSend_151sglz(_class_SCStreamConfiguration, _sel_new);
    return SCStreamConfiguration.fromPointer(
      $ret,
      retain: false,
      release: true,
    );
  }

  /// streamConfigurationWithPreset:
  static SCStreamConfiguration streamConfigurationWithPreset(
    SCStreamConfigurationPreset preset,
  ) {
    objc.checkOsVersionInternal(
      'SCStreamConfiguration.streamConfigurationWithPreset:',
      macOS: (false, (15, 0, 0)),
    );
    final $ret = _objc_msgSend_go053q(
      _class_SCStreamConfiguration,
      _sel_streamConfigurationWithPreset_,
      preset.value,
    );
    return SCStreamConfiguration.fromPointer($ret, retain: true, release: true);
  }

  /// Returns a new instance of SCStreamConfiguration constructed with the default `new` method.
  SCStreamConfiguration() : this.as(new$().object$);
}

extension SCStreamConfiguration$Methods on SCStreamConfiguration {
  /// backgroundColor
  ffi.Pointer<CGColor> get backgroundColor {
    objc.checkOsVersionInternal(
      'SCStreamConfiguration.backgroundColor',
      macOS: (false, (12, 3, 0)),
    );
    return _objc_msgSend_2u9jmz(object$.ref.pointer, _sel_backgroundColor);
  }

  /// captureDynamicRange
  SCCaptureDynamicRange get captureDynamicRange {
    objc.checkOsVersionInternal(
      'SCStreamConfiguration.captureDynamicRange',
      macOS: (false, (15, 0, 0)),
    );
    final $ret = _objc_msgSend_1bvr595(
      object$.ref.pointer,
      _sel_captureDynamicRange,
    );
    return SCCaptureDynamicRange.fromValue($ret);
  }

  /// captureMicrophone
  bool get captureMicrophone {
    objc.checkOsVersionInternal(
      'SCStreamConfiguration.captureMicrophone',
      macOS: (false, (15, 0, 0)),
    );
    return _objc_msgSend_91o635(object$.ref.pointer, _sel_captureMicrophone);
  }

  /// captureResolution
  SCCaptureResolutionType get captureResolution {
    objc.checkOsVersionInternal(
      'SCStreamConfiguration.captureResolution',
      macOS: (false, (14, 0, 0)),
    );
    final $ret = _objc_msgSend_161z7fp(
      object$.ref.pointer,
      _sel_captureResolution,
    );
    return SCCaptureResolutionType.fromValue($ret);
  }

  /// capturesAudio
  bool get capturesAudio {
    objc.checkOsVersionInternal(
      'SCStreamConfiguration.capturesAudio',
      macOS: (false, (13, 0, 0)),
    );
    return _objc_msgSend_91o635(object$.ref.pointer, _sel_capturesAudio);
  }

  /// capturesShadowsOnly
  bool get capturesShadowsOnly {
    objc.checkOsVersionInternal(
      'SCStreamConfiguration.capturesShadowsOnly',
      macOS: (false, (14, 0, 0)),
    );
    return _objc_msgSend_91o635(object$.ref.pointer, _sel_capturesShadowsOnly);
  }

  /// channelCount
  int get channelCount {
    objc.checkOsVersionInternal(
      'SCStreamConfiguration.channelCount',
      macOS: (false, (13, 0, 0)),
    );
    return _objc_msgSend_1hz7y9r(object$.ref.pointer, _sel_channelCount);
  }

  /// colorMatrix
  ffi.Pointer<objc.CFString> get colorMatrix {
    objc.checkOsVersionInternal(
      'SCStreamConfiguration.colorMatrix',
      macOS: (false, (12, 3, 0)),
    );
    return _objc_msgSend_8y9mw4(object$.ref.pointer, _sel_colorMatrix);
  }

  /// colorSpaceName
  ffi.Pointer<objc.CFString> get colorSpaceName {
    objc.checkOsVersionInternal(
      'SCStreamConfiguration.colorSpaceName',
      macOS: (false, (12, 3, 0)),
    );
    return _objc_msgSend_8y9mw4(object$.ref.pointer, _sel_colorSpaceName);
  }

  /// destinationRect
  objc.CGRect get destinationRect {
    objc.checkOsVersionInternal(
      'SCStreamConfiguration.destinationRect',
      macOS: (false, (12, 3, 0)),
    );
    final $ptr = pkg_ffi.calloc<objc.CGRect>();
    objc.useMsgSendVariants
        ? _objc_msgSend_bu1hbwStret(
            $ptr,
            object$.ref.pointer,
            _sel_destinationRect,
          )
        : $ptr.ref = _objc_msgSend_bu1hbw(
            object$.ref.pointer,
            _sel_destinationRect,
          );
    final $finalizable = $ptr.cast<ffi.Uint8>().asTypedList(
      ffi.sizeOf<objc.CGRect>(),
      finalizer: pkg_ffi.calloc.nativeFree,
    );
    return ffi.Struct.create<objc.CGRect>($finalizable);
  }

  /// excludesCurrentProcessAudio
  bool get excludesCurrentProcessAudio {
    objc.checkOsVersionInternal(
      'SCStreamConfiguration.excludesCurrentProcessAudio',
      macOS: (false, (13, 0, 0)),
    );
    return _objc_msgSend_91o635(
      object$.ref.pointer,
      _sel_excludesCurrentProcessAudio,
    );
  }

  /// height
  int get height {
    objc.checkOsVersionInternal(
      'SCStreamConfiguration.height',
      macOS: (false, (12, 3, 0)),
    );
    return _objc_msgSend_h0gkbf(object$.ref.pointer, _sel_height);
  }

  /// ignoreGlobalClipDisplay
  bool get ignoreGlobalClipDisplay {
    objc.checkOsVersionInternal(
      'SCStreamConfiguration.ignoreGlobalClipDisplay',
      macOS: (false, (14, 0, 0)),
    );
    return _objc_msgSend_91o635(
      object$.ref.pointer,
      _sel_ignoreGlobalClipDisplay,
    );
  }

  /// ignoreGlobalClipSingleWindow
  bool get ignoreGlobalClipSingleWindow {
    objc.checkOsVersionInternal(
      'SCStreamConfiguration.ignoreGlobalClipSingleWindow',
      macOS: (false, (14, 0, 0)),
    );
    return _objc_msgSend_91o635(
      object$.ref.pointer,
      _sel_ignoreGlobalClipSingleWindow,
    );
  }

  /// ignoreShadowsDisplay
  bool get ignoreShadowsDisplay {
    objc.checkOsVersionInternal(
      'SCStreamConfiguration.ignoreShadowsDisplay',
      macOS: (false, (14, 0, 0)),
    );
    return _objc_msgSend_91o635(object$.ref.pointer, _sel_ignoreShadowsDisplay);
  }

  /// ignoreShadowsSingleWindow
  bool get ignoreShadowsSingleWindow {
    objc.checkOsVersionInternal(
      'SCStreamConfiguration.ignoreShadowsSingleWindow',
      macOS: (false, (14, 0, 0)),
    );
    return _objc_msgSend_91o635(
      object$.ref.pointer,
      _sel_ignoreShadowsSingleWindow,
    );
  }

  /// includeChildWindows
  bool get includeChildWindows {
    objc.checkOsVersionInternal(
      'SCStreamConfiguration.includeChildWindows',
      macOS: (false, (14, 2, 0)),
    );
    return _objc_msgSend_91o635(object$.ref.pointer, _sel_includeChildWindows);
  }

  /// init
  SCStreamConfiguration init() {
    objc.checkOsVersionInternal(
      'SCStreamConfiguration.init',
      iOS: (false, (2, 0, 0)),
      macOS: (false, (10, 0, 0)),
    );
    final $ret = _objc_msgSend_151sglz(
      object$.ref.retainAndReturnPointer(),
      _sel_init,
    );
    return SCStreamConfiguration.fromPointer(
      $ret,
      retain: false,
      release: true,
    );
  }

  /// microphoneCaptureDeviceID
  objc.NSString? get microphoneCaptureDeviceID {
    objc.checkOsVersionInternal(
      'SCStreamConfiguration.microphoneCaptureDeviceID',
      macOS: (false, (15, 0, 0)),
    );
    final $ret = _objc_msgSend_151sglz(
      object$.ref.pointer,
      _sel_microphoneCaptureDeviceID,
    );
    return $ret.address == 0
        ? null
        : objc.NSString.fromPointer($ret, retain: true, release: true);
  }

  /// minimumFrameInterval
  CMTime get minimumFrameInterval {
    objc.checkOsVersionInternal(
      'SCStreamConfiguration.minimumFrameInterval',
      macOS: (false, (12, 3, 0)),
    );
    final $ptr = pkg_ffi.calloc<CMTime>();
    objc.useMsgSendVariants
        ? _objc_msgSend_1f8hvjsStret(
            $ptr,
            object$.ref.pointer,
            _sel_minimumFrameInterval,
          )
        : $ptr.ref = _objc_msgSend_1f8hvjs(
            object$.ref.pointer,
            _sel_minimumFrameInterval,
          );
    final $finalizable = $ptr.cast<ffi.Uint8>().asTypedList(
      ffi.sizeOf<CMTime>(),
      finalizer: pkg_ffi.calloc.nativeFree,
    );
    return ffi.Struct.create<CMTime>($finalizable);
  }

  /// pixelFormat
  int get pixelFormat {
    objc.checkOsVersionInternal(
      'SCStreamConfiguration.pixelFormat',
      macOS: (false, (12, 3, 0)),
    );
    return _objc_msgSend_3pyzne(object$.ref.pointer, _sel_pixelFormat);
  }

  /// presenterOverlayPrivacyAlertSetting
  SCPresenterOverlayAlertSetting get presenterOverlayPrivacyAlertSetting {
    objc.checkOsVersionInternal(
      'SCStreamConfiguration.presenterOverlayPrivacyAlertSetting',
      macOS: (false, (14, 0, 0)),
    );
    final $ret = _objc_msgSend_18wchwh(
      object$.ref.pointer,
      _sel_presenterOverlayPrivacyAlertSetting,
    );
    return SCPresenterOverlayAlertSetting.fromValue($ret);
  }

  /// preservesAspectRatio
  bool get preservesAspectRatio {
    objc.checkOsVersionInternal(
      'SCStreamConfiguration.preservesAspectRatio',
      macOS: (false, (14, 0, 0)),
    );
    return _objc_msgSend_91o635(object$.ref.pointer, _sel_preservesAspectRatio);
  }

  /// queueDepth
  int get queueDepth {
    objc.checkOsVersionInternal(
      'SCStreamConfiguration.queueDepth',
      macOS: (false, (12, 3, 0)),
    );
    return _objc_msgSend_1hz7y9r(object$.ref.pointer, _sel_queueDepth);
  }

  /// sampleRate
  int get sampleRate {
    objc.checkOsVersionInternal(
      'SCStreamConfiguration.sampleRate',
      macOS: (false, (13, 0, 0)),
    );
    return _objc_msgSend_1hz7y9r(object$.ref.pointer, _sel_sampleRate);
  }

  /// scalesToFit
  bool get scalesToFit {
    objc.checkOsVersionInternal(
      'SCStreamConfiguration.scalesToFit',
      macOS: (false, (12, 3, 0)),
    );
    return _objc_msgSend_91o635(object$.ref.pointer, _sel_scalesToFit);
  }

  /// setBackgroundColor:
  set backgroundColor(ffi.Pointer<CGColor> value) {
    objc.checkOsVersionInternal(
      'SCStreamConfiguration.setBackgroundColor:',
      macOS: (false, (12, 3, 0)),
    );
    _objc_msgSend_1bz9pdz(object$.ref.pointer, _sel_setBackgroundColor_, value);
  }

  /// setCaptureDynamicRange:
  set captureDynamicRange(SCCaptureDynamicRange value) {
    objc.checkOsVersionInternal(
      'SCStreamConfiguration.setCaptureDynamicRange:',
      macOS: (false, (15, 0, 0)),
    );
    _objc_msgSend_19zlydd(
      object$.ref.pointer,
      _sel_setCaptureDynamicRange_,
      value.value,
    );
  }

  /// setCaptureMicrophone:
  set captureMicrophone(bool value) {
    objc.checkOsVersionInternal(
      'SCStreamConfiguration.setCaptureMicrophone:',
      macOS: (false, (15, 0, 0)),
    );
    _objc_msgSend_1s56lr9(
      object$.ref.pointer,
      _sel_setCaptureMicrophone_,
      value,
    );
  }

  /// setCaptureResolution:
  set captureResolution(SCCaptureResolutionType value) {
    objc.checkOsVersionInternal(
      'SCStreamConfiguration.setCaptureResolution:',
      macOS: (false, (14, 0, 0)),
    );
    _objc_msgSend_hcx7sl(
      object$.ref.pointer,
      _sel_setCaptureResolution_,
      value.value,
    );
  }

  /// setCapturesAudio:
  set capturesAudio(bool value) {
    objc.checkOsVersionInternal(
      'SCStreamConfiguration.setCapturesAudio:',
      macOS: (false, (13, 0, 0)),
    );
    _objc_msgSend_1s56lr9(object$.ref.pointer, _sel_setCapturesAudio_, value);
  }

  /// setCapturesShadowsOnly:
  set capturesShadowsOnly(bool value) {
    objc.checkOsVersionInternal(
      'SCStreamConfiguration.setCapturesShadowsOnly:',
      macOS: (false, (14, 0, 0)),
    );
    _objc_msgSend_1s56lr9(
      object$.ref.pointer,
      _sel_setCapturesShadowsOnly_,
      value,
    );
  }

  /// setChannelCount:
  set channelCount(int value) {
    objc.checkOsVersionInternal(
      'SCStreamConfiguration.setChannelCount:',
      macOS: (false, (13, 0, 0)),
    );
    _objc_msgSend_4sp4xj(object$.ref.pointer, _sel_setChannelCount_, value);
  }

  /// setColorMatrix:
  set colorMatrix(ffi.Pointer<objc.CFString> value) {
    objc.checkOsVersionInternal(
      'SCStreamConfiguration.setColorMatrix:',
      macOS: (false, (12, 3, 0)),
    );
    _objc_msgSend_1pty11y(object$.ref.pointer, _sel_setColorMatrix_, value);
  }

  /// setColorSpaceName:
  set colorSpaceName(ffi.Pointer<objc.CFString> value) {
    objc.checkOsVersionInternal(
      'SCStreamConfiguration.setColorSpaceName:',
      macOS: (false, (12, 3, 0)),
    );
    _objc_msgSend_1pty11y(object$.ref.pointer, _sel_setColorSpaceName_, value);
  }

  /// setDestinationRect:
  set destinationRect(objc.CGRect value) {
    objc.checkOsVersionInternal(
      'SCStreamConfiguration.setDestinationRect:',
      macOS: (false, (12, 3, 0)),
    );
    _objc_msgSend_1okkq16(object$.ref.pointer, _sel_setDestinationRect_, value);
  }

  /// setExcludesCurrentProcessAudio:
  set excludesCurrentProcessAudio(bool value) {
    objc.checkOsVersionInternal(
      'SCStreamConfiguration.setExcludesCurrentProcessAudio:',
      macOS: (false, (13, 0, 0)),
    );
    _objc_msgSend_1s56lr9(
      object$.ref.pointer,
      _sel_setExcludesCurrentProcessAudio_,
      value,
    );
  }

  /// setHeight:
  set height(int value) {
    objc.checkOsVersionInternal(
      'SCStreamConfiguration.setHeight:',
      macOS: (false, (12, 3, 0)),
    );
    _objc_msgSend_6enxqz(object$.ref.pointer, _sel_setHeight_, value);
  }

  /// setIgnoreGlobalClipDisplay:
  set ignoreGlobalClipDisplay(bool value) {
    objc.checkOsVersionInternal(
      'SCStreamConfiguration.setIgnoreGlobalClipDisplay:',
      macOS: (false, (14, 0, 0)),
    );
    _objc_msgSend_1s56lr9(
      object$.ref.pointer,
      _sel_setIgnoreGlobalClipDisplay_,
      value,
    );
  }

  /// setIgnoreGlobalClipSingleWindow:
  set ignoreGlobalClipSingleWindow(bool value) {
    objc.checkOsVersionInternal(
      'SCStreamConfiguration.setIgnoreGlobalClipSingleWindow:',
      macOS: (false, (14, 0, 0)),
    );
    _objc_msgSend_1s56lr9(
      object$.ref.pointer,
      _sel_setIgnoreGlobalClipSingleWindow_,
      value,
    );
  }

  /// setIgnoreShadowsDisplay:
  set ignoreShadowsDisplay(bool value) {
    objc.checkOsVersionInternal(
      'SCStreamConfiguration.setIgnoreShadowsDisplay:',
      macOS: (false, (14, 0, 0)),
    );
    _objc_msgSend_1s56lr9(
      object$.ref.pointer,
      _sel_setIgnoreShadowsDisplay_,
      value,
    );
  }

  /// setIgnoreShadowsSingleWindow:
  set ignoreShadowsSingleWindow(bool value) {
    objc.checkOsVersionInternal(
      'SCStreamConfiguration.setIgnoreShadowsSingleWindow:',
      macOS: (false, (14, 0, 0)),
    );
    _objc_msgSend_1s56lr9(
      object$.ref.pointer,
      _sel_setIgnoreShadowsSingleWindow_,
      value,
    );
  }

  /// setIncludeChildWindows:
  set includeChildWindows(bool value) {
    objc.checkOsVersionInternal(
      'SCStreamConfiguration.setIncludeChildWindows:',
      macOS: (false, (14, 2, 0)),
    );
    _objc_msgSend_1s56lr9(
      object$.ref.pointer,
      _sel_setIncludeChildWindows_,
      value,
    );
  }

  /// setMicrophoneCaptureDeviceID:
  set microphoneCaptureDeviceID(objc.NSString? value) {
    objc.checkOsVersionInternal(
      'SCStreamConfiguration.setMicrophoneCaptureDeviceID:',
      macOS: (false, (15, 0, 0)),
    );
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_setMicrophoneCaptureDeviceID_,
      value?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// setMinimumFrameInterval:
  set minimumFrameInterval(CMTime value) {
    objc.checkOsVersionInternal(
      'SCStreamConfiguration.setMinimumFrameInterval:',
      macOS: (false, (12, 3, 0)),
    );
    _objc_msgSend_1hznzoi(
      object$.ref.pointer,
      _sel_setMinimumFrameInterval_,
      value,
    );
  }

  /// setPixelFormat:
  set pixelFormat(int value) {
    objc.checkOsVersionInternal(
      'SCStreamConfiguration.setPixelFormat:',
      macOS: (false, (12, 3, 0)),
    );
    _objc_msgSend_hr7g6s(object$.ref.pointer, _sel_setPixelFormat_, value);
  }

  /// setPresenterOverlayPrivacyAlertSetting:
  set presenterOverlayPrivacyAlertSetting(
    SCPresenterOverlayAlertSetting value,
  ) {
    objc.checkOsVersionInternal(
      'SCStreamConfiguration.setPresenterOverlayPrivacyAlertSetting:',
      macOS: (false, (14, 0, 0)),
    );
    _objc_msgSend_1jhpzcd(
      object$.ref.pointer,
      _sel_setPresenterOverlayPrivacyAlertSetting_,
      value.value,
    );
  }

  /// setPreservesAspectRatio:
  set preservesAspectRatio(bool value) {
    objc.checkOsVersionInternal(
      'SCStreamConfiguration.setPreservesAspectRatio:',
      macOS: (false, (14, 0, 0)),
    );
    _objc_msgSend_1s56lr9(
      object$.ref.pointer,
      _sel_setPreservesAspectRatio_,
      value,
    );
  }

  /// setQueueDepth:
  set queueDepth(int value) {
    objc.checkOsVersionInternal(
      'SCStreamConfiguration.setQueueDepth:',
      macOS: (false, (12, 3, 0)),
    );
    _objc_msgSend_4sp4xj(object$.ref.pointer, _sel_setQueueDepth_, value);
  }

  /// setSampleRate:
  set sampleRate(int value) {
    objc.checkOsVersionInternal(
      'SCStreamConfiguration.setSampleRate:',
      macOS: (false, (13, 0, 0)),
    );
    _objc_msgSend_4sp4xj(object$.ref.pointer, _sel_setSampleRate_, value);
  }

  /// setScalesToFit:
  set scalesToFit(bool value) {
    objc.checkOsVersionInternal(
      'SCStreamConfiguration.setScalesToFit:',
      macOS: (false, (12, 3, 0)),
    );
    _objc_msgSend_1s56lr9(object$.ref.pointer, _sel_setScalesToFit_, value);
  }

  /// setShouldBeOpaque:
  set shouldBeOpaque(bool value) {
    objc.checkOsVersionInternal(
      'SCStreamConfiguration.setShouldBeOpaque:',
      macOS: (false, (14, 0, 0)),
    );
    _objc_msgSend_1s56lr9(object$.ref.pointer, _sel_setShouldBeOpaque_, value);
  }

  /// setShowMouseClicks:
  set showMouseClicks(bool value) {
    objc.checkOsVersionInternal(
      'SCStreamConfiguration.setShowMouseClicks:',
      macOS: (false, (15, 0, 0)),
    );
    _objc_msgSend_1s56lr9(object$.ref.pointer, _sel_setShowMouseClicks_, value);
  }

  /// setShowsCursor:
  set showsCursor(bool value) {
    objc.checkOsVersionInternal(
      'SCStreamConfiguration.setShowsCursor:',
      macOS: (false, (12, 3, 0)),
    );
    _objc_msgSend_1s56lr9(object$.ref.pointer, _sel_setShowsCursor_, value);
  }

  /// setSourceRect:
  set sourceRect(objc.CGRect value) {
    objc.checkOsVersionInternal(
      'SCStreamConfiguration.setSourceRect:',
      macOS: (false, (12, 3, 0)),
    );
    _objc_msgSend_1okkq16(object$.ref.pointer, _sel_setSourceRect_, value);
  }

  /// setStreamName:
  set streamName(objc.NSString? value) {
    objc.checkOsVersionInternal(
      'SCStreamConfiguration.setStreamName:',
      macOS: (false, (14, 0, 0)),
    );
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_setStreamName_,
      value?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// setWidth:
  set width(int value) {
    objc.checkOsVersionInternal(
      'SCStreamConfiguration.setWidth:',
      macOS: (false, (12, 3, 0)),
    );
    _objc_msgSend_6enxqz(object$.ref.pointer, _sel_setWidth_, value);
  }

  /// shouldBeOpaque
  bool get shouldBeOpaque {
    objc.checkOsVersionInternal(
      'SCStreamConfiguration.shouldBeOpaque',
      macOS: (false, (14, 0, 0)),
    );
    return _objc_msgSend_91o635(object$.ref.pointer, _sel_shouldBeOpaque);
  }

  /// showMouseClicks
  bool get showMouseClicks {
    objc.checkOsVersionInternal(
      'SCStreamConfiguration.showMouseClicks',
      macOS: (false, (15, 0, 0)),
    );
    return _objc_msgSend_91o635(object$.ref.pointer, _sel_showMouseClicks);
  }

  /// showsCursor
  bool get showsCursor {
    objc.checkOsVersionInternal(
      'SCStreamConfiguration.showsCursor',
      macOS: (false, (12, 3, 0)),
    );
    return _objc_msgSend_91o635(object$.ref.pointer, _sel_showsCursor);
  }

  /// sourceRect
  objc.CGRect get sourceRect {
    objc.checkOsVersionInternal(
      'SCStreamConfiguration.sourceRect',
      macOS: (false, (12, 3, 0)),
    );
    final $ptr = pkg_ffi.calloc<objc.CGRect>();
    objc.useMsgSendVariants
        ? _objc_msgSend_bu1hbwStret($ptr, object$.ref.pointer, _sel_sourceRect)
        : $ptr.ref = _objc_msgSend_bu1hbw(object$.ref.pointer, _sel_sourceRect);
    final $finalizable = $ptr.cast<ffi.Uint8>().asTypedList(
      ffi.sizeOf<objc.CGRect>(),
      finalizer: pkg_ffi.calloc.nativeFree,
    );
    return ffi.Struct.create<objc.CGRect>($finalizable);
  }

  /// streamName
  objc.NSString? get streamName {
    objc.checkOsVersionInternal(
      'SCStreamConfiguration.streamName',
      macOS: (false, (14, 0, 0)),
    );
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_streamName);
    return $ret.address == 0
        ? null
        : objc.NSString.fromPointer($ret, retain: true, release: true);
  }

  /// width
  int get width {
    objc.checkOsVersionInternal(
      'SCStreamConfiguration.width',
      macOS: (false, (12, 3, 0)),
    );
    return _objc_msgSend_h0gkbf(object$.ref.pointer, _sel_width);
  }
}

enum SCStreamErrorCode {
  SCStreamErrorUserDeclined(-3801),
  SCStreamErrorFailedToStart(-3802),
  SCStreamErrorMissingEntitlements(-3803),
  SCStreamErrorFailedApplicationConnectionInvalid(-3804),
  SCStreamErrorFailedApplicationConnectionInterrupted(-3805),
  SCStreamErrorFailedNoMatchingApplicationContext(-3806),
  SCStreamErrorAttemptToStartStreamState(-3807),
  SCStreamErrorAttemptToStopStreamState(-3808),
  SCStreamErrorAttemptToUpdateFilterState(-3809),
  SCStreamErrorAttemptToConfigState(-3810),
  SCStreamErrorInternalError(-3811),
  SCStreamErrorInvalidParameter(-3812),
  SCStreamErrorNoWindowList(-3813),
  SCStreamErrorNoDisplayList(-3814),
  SCStreamErrorNoCaptureSource(-3815),
  SCStreamErrorRemovingStream(-3816),
  SCStreamErrorUserStopped(-3817),
  SCStreamErrorFailedToStartAudioCapture(-3818),
  SCStreamErrorFailedToStopAudioCapture(-3819),
  SCStreamErrorFailedToStartMicrophoneCapture(-3820),
  SCStreamErrorSystemStoppedStream(-3821);

  final int value;
  const SCStreamErrorCode(this.value);

  static SCStreamErrorCode fromValue(int value) => switch (value) {
    -3801 => SCStreamErrorUserDeclined,
    -3802 => SCStreamErrorFailedToStart,
    -3803 => SCStreamErrorMissingEntitlements,
    -3804 => SCStreamErrorFailedApplicationConnectionInvalid,
    -3805 => SCStreamErrorFailedApplicationConnectionInterrupted,
    -3806 => SCStreamErrorFailedNoMatchingApplicationContext,
    -3807 => SCStreamErrorAttemptToStartStreamState,
    -3808 => SCStreamErrorAttemptToStopStreamState,
    -3809 => SCStreamErrorAttemptToUpdateFilterState,
    -3810 => SCStreamErrorAttemptToConfigState,
    -3811 => SCStreamErrorInternalError,
    -3812 => SCStreamErrorInvalidParameter,
    -3813 => SCStreamErrorNoWindowList,
    -3814 => SCStreamErrorNoDisplayList,
    -3815 => SCStreamErrorNoCaptureSource,
    -3816 => SCStreamErrorRemovingStream,
    -3817 => SCStreamErrorUserStopped,
    -3818 => SCStreamErrorFailedToStartAudioCapture,
    -3819 => SCStreamErrorFailedToStopAudioCapture,
    -3820 => SCStreamErrorFailedToStartMicrophoneCapture,
    -3821 => SCStreamErrorSystemStoppedStream,
    _ => throw ArgumentError('Unknown value for SCStreamErrorCode: $value'),
  };
}

enum SCScreenshotDisplayIntent {
  SCScreenshotDisplayIntentCanonical(0),
  SCScreenshotDisplayIntentLocal(1);

  final int value;
  const SCScreenshotDisplayIntent(this.value);

  static SCScreenshotDisplayIntent fromValue(int value) => switch (value) {
    0 => SCScreenshotDisplayIntentCanonical,
    1 => SCScreenshotDisplayIntentLocal,
    _ => throw ArgumentError(
      'Unknown value for SCScreenshotDisplayIntent: $value',
    ),
  };
}

enum SCScreenshotDynamicRange {
  SCScreenshotDynamicRangeSDR(0),
  SCScreenshotDynamicRangeHDR(1),
  SCScreenshotDynamicRangeSDRAndHDR(2);

  final int value;
  const SCScreenshotDynamicRange(this.value);

  static SCScreenshotDynamicRange fromValue(int value) => switch (value) {
    0 => SCScreenshotDynamicRangeSDR,
    1 => SCScreenshotDynamicRangeHDR,
    2 => SCScreenshotDynamicRangeSDRAndHDR,
    _ => throw ArgumentError(
      'Unknown value for SCScreenshotDynamicRange: $value',
    ),
  };
}

late final _class_SCScreenshotConfiguration = objc.getClass(
  "SCScreenshotConfiguration",
);
late final _sel_ignoreShadows = objc.registerName("ignoreShadows");
late final _sel_setIgnoreShadows_ = objc.registerName("setIgnoreShadows:");
late final _sel_ignoreClipping = objc.registerName("ignoreClipping");
late final _sel_setIgnoreClipping_ = objc.registerName("setIgnoreClipping:");
late final _sel_displayIntent = objc.registerName("displayIntent");
final _objc_msgSend_1hd3foh = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Long Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
        )
      >
    >()
    .asFunction<
      int Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
      )
    >();
late final _sel_setDisplayIntent_ = objc.registerName("setDisplayIntent:");
final _objc_msgSend_1aipfm1 = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Long,
        )
      >
    >()
    .asFunction<
      void Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
        int,
      )
    >();
late final _sel_dynamicRange = objc.registerName("dynamicRange");
final _objc_msgSend_ibmwpx = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Long Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
        )
      >
    >()
    .asFunction<
      int Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
      )
    >();
late final _sel_setDynamicRange_ = objc.registerName("setDynamicRange:");
final _objc_msgSend_1wrfi5l = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Long,
        )
      >
    >()
    .asFunction<
      void Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
        int,
      )
    >();
late final _class_UTType = objc.getClass("UTType");
late final _sel_typeWithIdentifier_ = objc.registerName("typeWithIdentifier:");
late final _sel_typeWithFilenameExtension_ = objc.registerName(
  "typeWithFilenameExtension:",
);
late final _sel_typeWithFilenameExtension_conformingToType_ = objc.registerName(
  "typeWithFilenameExtension:conformingToType:",
);
late final _sel_typeWithMIMEType_ = objc.registerName("typeWithMIMEType:");
late final _sel_typeWithMIMEType_conformingToType_ = objc.registerName(
  "typeWithMIMEType:conformingToType:",
);
late final _sel_identifier = objc.registerName("identifier");
late final _sel_preferredFilenameExtension = objc.registerName(
  "preferredFilenameExtension",
);
late final _sel_preferredMIMEType = objc.registerName("preferredMIMEType");
late final _sel_localizedDescription = objc.registerName(
  "localizedDescription",
);
late final _sel_version = objc.registerName("version");
late final _sel_referenceURL = objc.registerName("referenceURL");
late final _sel_isDynamic = objc.registerName("isDynamic");
late final _sel_isDeclared = objc.registerName("isDeclared");
late final _sel_isPublicType = objc.registerName("isPublicType");
late final _sel_supportsSecureCoding = objc.registerName(
  "supportsSecureCoding",
);

/// Construction methods for `objc.ObjCBlock<ffi.Bool Function(ffi.Pointer<ffi.Void>)>`.
abstract final class ObjCBlock_bool_ffiVoid {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<ffi.Bool Function(ffi.Pointer<ffi.Void>)> fromPointer(
    ffi.Pointer<objc.ObjCBlockImpl> pointer, {
    bool retain = false,
    bool release = false,
  }) => objc.ObjCBlock<ffi.Bool Function(ffi.Pointer<ffi.Void>)>(
    pointer,
    retain: retain,
    release: release,
  );

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<ffi.Bool Function(ffi.Pointer<ffi.Void>)>
  fromFunctionPointer(
    ffi.Pointer<
      ffi.NativeFunction<ffi.Bool Function(ffi.Pointer<ffi.Void> arg0)>
    >
    ptr,
  ) => objc.ObjCBlock<ffi.Bool Function(ffi.Pointer<ffi.Void>)>(
    objc.newPointerBlock(_fnPtrCallable, ptr.cast()),
    retain: false,
    release: true,
  );

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Bool Function(ffi.Pointer<ffi.Void>)> fromFunction(
    bool Function(ffi.Pointer<ffi.Void>) fn, {
    bool keepIsolateAlive = true,
  }) => objc.ObjCBlock<ffi.Bool Function(ffi.Pointer<ffi.Void>)>(
    objc.newClosureBlock(
      _closureCallable,
      (ffi.Pointer<ffi.Void> arg0) => fn(arg0),
      keepIsolateAlive,
    ),
    retain: false,
    release: true,
  );

  static bool _fnPtrTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
  ) => block.ref.target
      .cast<ffi.NativeFunction<ffi.Bool Function(ffi.Pointer<ffi.Void> arg0)>>()
      .asFunction<bool Function(ffi.Pointer<ffi.Void>)>()(arg0);
  static ffi.Pointer<ffi.Void> _fnPtrCallable =
      ffi.Pointer.fromFunction<
            ffi.Bool Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
            )
          >(_fnPtrTrampoline, false)
          .cast();
  static bool _closureTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
  ) => (objc.getBlockClosure(block) as bool Function(ffi.Pointer<ffi.Void>))(
    arg0,
  );
  static ffi.Pointer<ffi.Void> _closureCallable =
      ffi.Pointer.fromFunction<
            ffi.Bool Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
            )
          >(_closureTrampoline, false)
          .cast();
}

/// Call operator for `objc.ObjCBlock<ffi.Bool Function(ffi.Pointer<ffi.Void>)>`.
extension ObjCBlock_bool_ffiVoid$CallExtension
    on objc.ObjCBlock<ffi.Bool Function(ffi.Pointer<ffi.Void>)> {
  bool call(ffi.Pointer<ffi.Void> arg0) => ref.pointer.ref.invoke
      .cast<
        ffi.NativeFunction<
          ffi.Bool Function(
            ffi.Pointer<objc.ObjCBlockImpl> block,
            ffi.Pointer<ffi.Void> arg0,
          )
        >
      >()
      .asFunction<
        bool Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>)
      >()(ref.pointer, arg0);
}

late final _sel_encodeWithCoder_ = objc.registerName("encodeWithCoder:");

/// Construction methods for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, objc.NSCoder)>`.
abstract final class ObjCBlock_ffiVoid_ffiVoid_NSCoder {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, objc.NSCoder)>
  fromPointer(
    ffi.Pointer<objc.ObjCBlockImpl> pointer, {
    bool retain = false,
    bool release = false,
  }) => objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, objc.NSCoder)>(
    pointer,
    retain: retain,
    release: release,
  );

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, objc.NSCoder)>
  fromFunctionPointer(
    ffi.Pointer<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<ffi.Void> arg0,
          ffi.Pointer<objc.ObjCObjectImpl> arg1,
        )
      >
    >
    ptr,
  ) => objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, objc.NSCoder)>(
    objc.newPointerBlock(_fnPtrCallable, ptr.cast()),
    retain: false,
    release: true,
  );

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, objc.NSCoder)>
  fromFunction(
    void Function(ffi.Pointer<ffi.Void>, objc.NSCoder) fn, {
    bool keepIsolateAlive = true,
  }) => objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, objc.NSCoder)>(
    objc.newClosureBlock(
      _closureCallable,
      (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1) =>
          fn(arg0, objc.NSCoder.fromPointer(arg1, retain: true, release: true)),
      keepIsolateAlive,
    ),
    retain: false,
    release: true,
  );

  /// Creates a listener block from a Dart function.
  ///
  /// This is based on FFI's NativeCallable.listener, and has the same
  /// capabilities and limitations. This block can be invoked from any thread,
  /// but only supports void functions, and is not run synchronously. See
  /// NativeCallable.listener for more details.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, objc.NSCoder)>
  listener(
    void Function(ffi.Pointer<ffi.Void>, objc.NSCoder) fn, {
    bool keepIsolateAlive = true,
  }) {
    final raw = objc.newClosureBlock(
      _listenerCallable.nativeFunction.cast(),
      (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1) => fn(
        arg0,
        objc.NSCoder.fromPointer(arg1, retain: false, release: true),
      ),
      keepIsolateAlive,
    );
    final wrapper = _NativeLibrary_wrapListenerBlock_18v1jvf(raw);
    objc.objectRelease(raw.cast());
    return objc.ObjCBlock<
      ffi.Void Function(ffi.Pointer<ffi.Void>, objc.NSCoder)
    >(wrapper, retain: false, release: true);
  }

  /// Creates a blocking block from a Dart function.
  ///
  /// This callback can be invoked from any native thread, and will block the
  /// caller until the callback is handled by the Dart isolate that created
  /// the block. Async functions are not supported.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC. If the owner isolate
  /// has shut down, and the block is invoked by native code, it may block
  /// indefinitely, or have other undefined behavior.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, objc.NSCoder)>
  blocking(
    void Function(ffi.Pointer<ffi.Void>, objc.NSCoder) fn, {
    bool keepIsolateAlive = true,
  }) {
    final raw = objc.newClosureBlock(
      _blockingCallable.nativeFunction.cast(),
      (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1) => fn(
        arg0,
        objc.NSCoder.fromPointer(arg1, retain: false, release: true),
      ),
      keepIsolateAlive,
    );
    final rawListener = objc.newClosureBlock(
      _blockingListenerCallable.nativeFunction.cast(),
      (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1) => fn(
        arg0,
        objc.NSCoder.fromPointer(arg1, retain: false, release: true),
      ),
      keepIsolateAlive,
    );
    final wrapper = _NativeLibrary_wrapBlockingBlock_18v1jvf(
      raw,
      rawListener,
      objc.objCContext,
    );
    objc.objectRelease(raw.cast());
    objc.objectRelease(rawListener.cast());
    return objc.ObjCBlock<
      ffi.Void Function(ffi.Pointer<ffi.Void>, objc.NSCoder)
    >(wrapper, retain: false, release: true);
  }

  static void _listenerTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
  ) {
    (objc.getBlockClosure(block)
        as void Function(
          ffi.Pointer<ffi.Void>,
          ffi.Pointer<objc.ObjCObjectImpl>,
        ))(arg0, arg1);
    objc.objectRelease(block.cast());
  }

  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<objc.ObjCObjectImpl>,
    )
  >
  _listenerCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          )
        >.listener(_listenerTrampoline)
        ..keepIsolateAlive = false;
  static void _blockingTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> waiter,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
  ) {
    try {
      (objc.getBlockClosure(block)
          as void Function(
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          ))(arg0, arg1);
    } catch (e) {
    } finally {
      objc.signalWaiter(waiter);
      objc.objectRelease(block.cast());
    }
  }

  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<objc.ObjCObjectImpl>,
    )
  >
  _blockingCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          )
        >.isolateLocal(_blockingTrampoline)
        ..keepIsolateAlive = false;
  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<objc.ObjCObjectImpl>,
    )
  >
  _blockingListenerCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          )
        >.listener(_blockingTrampoline)
        ..keepIsolateAlive = false;
  static void _fnPtrTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
  ) => block.ref.target
      .cast<
        ffi.NativeFunction<
          ffi.Void Function(
            ffi.Pointer<ffi.Void> arg0,
            ffi.Pointer<objc.ObjCObjectImpl> arg1,
          )
        >
      >()
      .asFunction<
        void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObjectImpl>)
      >()(arg0, arg1);
  static ffi.Pointer<ffi.Void> _fnPtrCallable =
      ffi.Pointer.fromFunction<
            ffi.Void Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<objc.ObjCObjectImpl>,
            )
          >(_fnPtrTrampoline)
          .cast();
  static void _closureTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
  ) =>
      (objc.getBlockClosure(block)
          as void Function(
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          ))(arg0, arg1);
  static ffi.Pointer<ffi.Void> _closureCallable =
      ffi.Pointer.fromFunction<
            ffi.Void Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<objc.ObjCObjectImpl>,
            )
          >(_closureTrampoline)
          .cast();
}

/// Call operator for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, objc.NSCoder)>`.
extension ObjCBlock_ffiVoid_ffiVoid_NSCoder$CallExtension
    on objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, objc.NSCoder)> {
  void call(ffi.Pointer<ffi.Void> arg0, objc.NSCoder arg1) => ref
      .pointer
      .ref
      .invoke
      .cast<
        ffi.NativeFunction<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl> block,
            ffi.Pointer<ffi.Void> arg0,
            ffi.Pointer<objc.ObjCObjectImpl> arg1,
          )
        >
      >()
      .asFunction<
        void Function(
          ffi.Pointer<objc.ObjCBlockImpl>,
          ffi.Pointer<ffi.Void>,
          ffi.Pointer<objc.ObjCObjectImpl>,
        )
      >()(ref.pointer, arg0, arg1.ref.pointer);
}

late final _sel_initWithCoder_ = objc.registerName("initWithCoder:");

/// Construction methods for `objc.ObjCBlock<objc.Retained<ffi.Pointer<objc.ObjCObjectImpl>?> Function(ffi.Pointer<ffi.Void>, objc.NSCoder)>`.
abstract final class ObjCBlock_instancetype_ffiVoid_NSCoder {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<
    objc.Retained<ffi.Pointer<objc.ObjCObjectImpl>?> Function(
      ffi.Pointer<ffi.Void>,
      objc.NSCoder,
    )
  >
  fromPointer(
    ffi.Pointer<objc.ObjCBlockImpl> pointer, {
    bool retain = false,
    bool release = false,
  }) =>
      objc.ObjCBlock<
        objc.Retained<ffi.Pointer<objc.ObjCObjectImpl>?> Function(
          ffi.Pointer<ffi.Void>,
          objc.NSCoder,
        )
      >(pointer, retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<
    objc.Retained<ffi.Pointer<objc.ObjCObjectImpl>?> Function(
      ffi.Pointer<ffi.Void>,
      objc.NSCoder,
    )
  >
  fromFunctionPointer(
    ffi.Pointer<
      ffi.NativeFunction<
        instancetype Function(
          ffi.Pointer<ffi.Void> arg0,
          ffi.Pointer<objc.ObjCObjectImpl> arg1,
        )
      >
    >
    ptr,
  ) =>
      objc.ObjCBlock<
        objc.Retained<ffi.Pointer<objc.ObjCObjectImpl>?> Function(
          ffi.Pointer<ffi.Void>,
          objc.NSCoder,
        )
      >(
        objc.newPointerBlock(_fnPtrCallable, ptr.cast()),
        retain: false,
        release: true,
      );

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<
    objc.Retained<ffi.Pointer<objc.ObjCObjectImpl>?> Function(
      ffi.Pointer<ffi.Void>,
      objc.NSCoder,
    )
  >
  fromFunction(
    Dartinstancetype? Function(ffi.Pointer<ffi.Void>, objc.NSCoder) fn, {
    bool keepIsolateAlive = true,
  }) =>
      objc.ObjCBlock<
        objc.Retained<ffi.Pointer<objc.ObjCObjectImpl>?> Function(
          ffi.Pointer<ffi.Void>,
          objc.NSCoder,
        )
      >(
        objc.newClosureBlock(
          _closureCallable,
          (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1) =>
              fn(
                arg0,
                objc.NSCoder.fromPointer(arg1, retain: true, release: true),
              )?.ref.retainAndReturnPointer() ??
              ffi.nullptr,
          keepIsolateAlive,
        ),
        retain: false,
        release: true,
      );

  static instancetype _fnPtrTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
  ) => block.ref.target
      .cast<
        ffi.NativeFunction<
          instancetype Function(
            ffi.Pointer<ffi.Void> arg0,
            ffi.Pointer<objc.ObjCObjectImpl> arg1,
          )
        >
      >()
      .asFunction<
        instancetype Function(
          ffi.Pointer<ffi.Void>,
          ffi.Pointer<objc.ObjCObjectImpl>,
        )
      >()(arg0, arg1);
  static ffi.Pointer<ffi.Void> _fnPtrCallable =
      ffi.Pointer.fromFunction<
            instancetype Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<objc.ObjCObjectImpl>,
            )
          >(_fnPtrTrampoline)
          .cast();
  static instancetype _closureTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
  ) =>
      (objc.getBlockClosure(block)
          as instancetype Function(
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          ))(arg0, arg1);
  static ffi.Pointer<ffi.Void> _closureCallable =
      ffi.Pointer.fromFunction<
            instancetype Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<objc.ObjCObjectImpl>,
            )
          >(_closureTrampoline)
          .cast();
}

/// Call operator for `objc.ObjCBlock<objc.Retained<ffi.Pointer<objc.ObjCObjectImpl>?> Function(ffi.Pointer<ffi.Void>, objc.NSCoder)>`.
extension ObjCBlock_instancetype_ffiVoid_NSCoder$CallExtension
    on
        objc.ObjCBlock<
          objc.Retained<ffi.Pointer<objc.ObjCObjectImpl>?> Function(
            ffi.Pointer<ffi.Void>,
            objc.NSCoder,
          )
        > {
  Dartinstancetype? call(ffi.Pointer<ffi.Void> arg0, objc.NSCoder arg1) =>
      ref.pointer.ref.invoke
              .cast<
                ffi.NativeFunction<
                  instancetype Function(
                    ffi.Pointer<objc.ObjCBlockImpl> block,
                    ffi.Pointer<ffi.Void> arg0,
                    ffi.Pointer<objc.ObjCObjectImpl> arg1,
                  )
                >
              >()
              .asFunction<
                instancetype Function(
                  ffi.Pointer<objc.ObjCBlockImpl>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<objc.ObjCObjectImpl>,
                )
              >()(ref.pointer, arg0, arg1.ref.pointer)
              .address ==
          0
      ? null
      : objc.ObjCObject(
          ref.pointer.ref.invoke
              .cast<
                ffi.NativeFunction<
                  instancetype Function(
                    ffi.Pointer<objc.ObjCBlockImpl> block,
                    ffi.Pointer<ffi.Void> arg0,
                    ffi.Pointer<objc.ObjCObjectImpl> arg1,
                  )
                >
              >()
              .asFunction<
                instancetype Function(
                  ffi.Pointer<objc.ObjCBlockImpl>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<objc.ObjCObjectImpl>,
                )
              >()(ref.pointer, arg0, arg1.ref.pointer),
          retain: false,
          release: true,
        );
}

late final _sel_typeWithTag_tagClass_conformingToType_ = objc.registerName(
  "typeWithTag:tagClass:conformingToType:",
);
late final _sel_conformsToType_ = objc.registerName("conformsToType:");
late final _sel_isSupertypeOfType_ = objc.registerName("isSupertypeOfType:");
late final _sel_isSubtypeOfType_ = objc.registerName("isSubtypeOfType:");
late final _sel_supertypes = objc.registerName("supertypes");

/// Conformance
extension Conformance on UTType {
  /// conformsToType:
  bool conformsToType(UTType type) {
    objc.checkOsVersionInternal(
      'UTType.conformsToType:',
      iOS: (false, (14, 0, 0)),
      macOS: (false, (11, 0, 0)),
    );
    return _objc_msgSend_19nvye5(
      object$.ref.pointer,
      _sel_conformsToType_,
      type.ref.pointer,
    );
  }

  /// isSubtypeOfType:
  bool isSubtypeOfType(UTType type) {
    objc.checkOsVersionInternal(
      'UTType.isSubtypeOfType:',
      iOS: (false, (14, 0, 0)),
      macOS: (false, (11, 0, 0)),
    );
    return _objc_msgSend_19nvye5(
      object$.ref.pointer,
      _sel_isSubtypeOfType_,
      type.ref.pointer,
    );
  }

  /// isSupertypeOfType:
  bool isSupertypeOfType(UTType type) {
    objc.checkOsVersionInternal(
      'UTType.isSupertypeOfType:',
      iOS: (false, (14, 0, 0)),
      macOS: (false, (11, 0, 0)),
    );
    return _objc_msgSend_19nvye5(
      object$.ref.pointer,
      _sel_isSupertypeOfType_,
      type.ref.pointer,
    );
  }

  /// supertypes
  objc.NSSet get supertypes {
    objc.checkOsVersionInternal(
      'UTType.supertypes',
      iOS: (false, (14, 0, 0)),
      macOS: (false, (11, 0, 0)),
    );
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_supertypes);
    return objc.NSSet.fromPointer($ret, retain: true, release: true);
  }
}

late final _sel_typesWithTag_tagClass_conformingToType_ = objc.registerName(
  "typesWithTag:tagClass:conformingToType:",
);
late final _sel_tags = objc.registerName("tags");

/// UTTagSpecification
extension UTTagSpecification on UTType {
  /// tags
  objc.NSDictionary get tags {
    objc.checkOsVersionInternal(
      'UTType.tags',
      iOS: (false, (14, 0, 0)),
      macOS: (false, (11, 0, 0)),
    );
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_tags);
    return objc.NSDictionary.fromPointer($ret, retain: true, release: true);
  }

  /// typesWithTag:tagClass:conformingToType:
  static objc.NSArray typesWithTag(
    objc.NSString tag, {
    required objc.NSString tagClass,
    UTType? conformingToType,
  }) {
    objc.checkOsVersionInternal(
      'UTType.typesWithTag:tagClass:conformingToType:',
      iOS: (false, (14, 0, 0)),
      macOS: (false, (11, 0, 0)),
    );
    final $ret = _objc_msgSend_11spmsz(
      _class_UTType,
      _sel_typesWithTag_tagClass_conformingToType_,
      tag.ref.pointer,
      tagClass.ref.pointer,
      conformingToType?.ref.pointer ?? ffi.nullptr,
    );
    return objc.NSArray.fromPointer($ret, retain: true, release: true);
  }
}

late final _sel_exportedTypeWithIdentifier_ = objc.registerName(
  "exportedTypeWithIdentifier:",
);
late final _sel_exportedTypeWithIdentifier_conformingToType_ = objc
    .registerName("exportedTypeWithIdentifier:conformingToType:");
late final _sel_importedTypeWithIdentifier_ = objc.registerName(
  "importedTypeWithIdentifier:",
);
late final _sel_importedTypeWithIdentifier_conformingToType_ = objc
    .registerName("importedTypeWithIdentifier:conformingToType:");

/// LocalConstants
extension LocalConstants on UTType {
  /// exportedTypeWithIdentifier:
  static UTType exportedTypeWithIdentifier(objc.NSString identifier) {
    objc.checkOsVersionInternal(
      'UTType.exportedTypeWithIdentifier:',
      iOS: (false, (14, 0, 0)),
      macOS: (false, (11, 0, 0)),
    );
    final $ret = _objc_msgSend_1sotr3r(
      _class_UTType,
      _sel_exportedTypeWithIdentifier_,
      identifier.ref.pointer,
    );
    return UTType.fromPointer($ret, retain: true, release: true);
  }

  /// exportedTypeWithIdentifier:conformingToType:
  static UTType exportedTypeWithIdentifier$1(
    objc.NSString identifier, {
    required UTType conformingToType,
  }) {
    objc.checkOsVersionInternal(
      'UTType.exportedTypeWithIdentifier:conformingToType:',
      iOS: (false, (14, 0, 0)),
      macOS: (false, (11, 0, 0)),
    );
    final $ret = _objc_msgSend_15qeuct(
      _class_UTType,
      _sel_exportedTypeWithIdentifier_conformingToType_,
      identifier.ref.pointer,
      conformingToType.ref.pointer,
    );
    return UTType.fromPointer($ret, retain: true, release: true);
  }

  /// importedTypeWithIdentifier:
  static UTType importedTypeWithIdentifier(objc.NSString identifier) {
    objc.checkOsVersionInternal(
      'UTType.importedTypeWithIdentifier:',
      iOS: (false, (14, 0, 0)),
      macOS: (false, (11, 0, 0)),
    );
    final $ret = _objc_msgSend_1sotr3r(
      _class_UTType,
      _sel_importedTypeWithIdentifier_,
      identifier.ref.pointer,
    );
    return UTType.fromPointer($ret, retain: true, release: true);
  }

  /// importedTypeWithIdentifier:conformingToType:
  static UTType importedTypeWithIdentifier$1(
    objc.NSString identifier, {
    required UTType conformingToType,
  }) {
    objc.checkOsVersionInternal(
      'UTType.importedTypeWithIdentifier:conformingToType:',
      iOS: (false, (14, 0, 0)),
      macOS: (false, (11, 0, 0)),
    );
    final $ret = _objc_msgSend_15qeuct(
      _class_UTType,
      _sel_importedTypeWithIdentifier_conformingToType_,
      identifier.ref.pointer,
      conformingToType.ref.pointer,
    );
    return UTType.fromPointer($ret, retain: true, release: true);
  }
}

/// UTType
extension type UTType._(objc.ObjCObject object$)
    implements
        objc.ObjCObject,
        objc.NSObject,
        objc.NSCopying,
        objc.NSSecureCoding {
  /// Constructs a [UTType] that points to the same underlying object as [other].
  UTType.as(objc.ObjCObject other) : object$ = other {
    assert(isA(object$));
  }

  /// Constructs a [UTType] that wraps the given raw object pointer.
  UTType.fromPointer(
    ffi.Pointer<objc.ObjCObjectImpl> other, {
    bool retain = false,
    bool release = false,
  }) : object$ = objc.ObjCObject(other, retain: retain, release: release) {
    assert(isA(object$));
  }

  /// Returns whether [obj] is an instance of [UTType].
  static bool isA(objc.ObjCObject obj) => _objc_msgSend_19nvye5(
    obj.ref.pointer,
    _sel_isKindOfClass_,
    _class_UTType,
  );

  /// alloc
  static UTType alloc() {
    final $ret = _objc_msgSend_151sglz(_class_UTType, _sel_alloc);
    return UTType.fromPointer($ret, retain: false, release: true);
  }

  /// allocWithZone:
  static UTType allocWithZone(ffi.Pointer<objc.NSZone> zone) {
    final $ret = _objc_msgSend_1cwp428(
      _class_UTType,
      _sel_allocWithZone_,
      zone,
    );
    return UTType.fromPointer($ret, retain: false, release: true);
  }

  /// new
  static UTType new$() {
    final $ret = _objc_msgSend_151sglz(_class_UTType, _sel_new);
    return UTType.fromPointer($ret, retain: false, release: true);
  }

  /// supportsSecureCoding
  static bool getSupportsSecureCoding() {
    return _objc_msgSend_91o635(_class_UTType, _sel_supportsSecureCoding);
  }

  /// typeWithFilenameExtension:
  static UTType? typeWithFilenameExtension(objc.NSString filenameExtension) {
    objc.checkOsVersionInternal(
      'UTType.typeWithFilenameExtension:',
      iOS: (false, (14, 0, 0)),
      macOS: (false, (11, 0, 0)),
    );
    final $ret = _objc_msgSend_1sotr3r(
      _class_UTType,
      _sel_typeWithFilenameExtension_,
      filenameExtension.ref.pointer,
    );
    return $ret.address == 0
        ? null
        : UTType.fromPointer($ret, retain: true, release: true);
  }

  /// typeWithFilenameExtension:conformingToType:
  static UTType? typeWithFilenameExtension$1(
    objc.NSString filenameExtension, {
    required UTType conformingToType,
  }) {
    objc.checkOsVersionInternal(
      'UTType.typeWithFilenameExtension:conformingToType:',
      iOS: (false, (14, 0, 0)),
      macOS: (false, (11, 0, 0)),
    );
    final $ret = _objc_msgSend_15qeuct(
      _class_UTType,
      _sel_typeWithFilenameExtension_conformingToType_,
      filenameExtension.ref.pointer,
      conformingToType.ref.pointer,
    );
    return $ret.address == 0
        ? null
        : UTType.fromPointer($ret, retain: true, release: true);
  }

  /// typeWithIdentifier:
  static UTType? typeWithIdentifier(objc.NSString identifier) {
    objc.checkOsVersionInternal(
      'UTType.typeWithIdentifier:',
      iOS: (false, (14, 0, 0)),
      macOS: (false, (11, 0, 0)),
    );
    final $ret = _objc_msgSend_1sotr3r(
      _class_UTType,
      _sel_typeWithIdentifier_,
      identifier.ref.pointer,
    );
    return $ret.address == 0
        ? null
        : UTType.fromPointer($ret, retain: true, release: true);
  }

  /// typeWithMIMEType:
  static UTType? typeWithMIMEType(objc.NSString mimeType) {
    objc.checkOsVersionInternal(
      'UTType.typeWithMIMEType:',
      iOS: (false, (14, 0, 0)),
      macOS: (false, (11, 0, 0)),
    );
    final $ret = _objc_msgSend_1sotr3r(
      _class_UTType,
      _sel_typeWithMIMEType_,
      mimeType.ref.pointer,
    );
    return $ret.address == 0
        ? null
        : UTType.fromPointer($ret, retain: true, release: true);
  }

  /// typeWithMIMEType:conformingToType:
  static UTType? typeWithMIMEType$1(
    objc.NSString mimeType, {
    required UTType conformingToType,
  }) {
    objc.checkOsVersionInternal(
      'UTType.typeWithMIMEType:conformingToType:',
      iOS: (false, (14, 0, 0)),
      macOS: (false, (11, 0, 0)),
    );
    final $ret = _objc_msgSend_15qeuct(
      _class_UTType,
      _sel_typeWithMIMEType_conformingToType_,
      mimeType.ref.pointer,
      conformingToType.ref.pointer,
    );
    return $ret.address == 0
        ? null
        : UTType.fromPointer($ret, retain: true, release: true);
  }

  /// typeWithTag:tagClass:conformingToType:
  static UTType? typeWithTag(
    objc.NSString tag, {
    required objc.NSString tagClass,
    UTType? conformingToType,
  }) {
    objc.checkOsVersionInternal(
      'UTType.typeWithTag:tagClass:conformingToType:',
      iOS: (false, (14, 0, 0)),
      macOS: (false, (11, 0, 0)),
    );
    final $ret = _objc_msgSend_11spmsz(
      _class_UTType,
      _sel_typeWithTag_tagClass_conformingToType_,
      tag.ref.pointer,
      tagClass.ref.pointer,
      conformingToType?.ref.pointer ?? ffi.nullptr,
    );
    return $ret.address == 0
        ? null
        : UTType.fromPointer($ret, retain: true, release: true);
  }

  /// Returns a new instance of UTType constructed with the default `new` method.
  UTType() : this.as(new$().object$);
}

extension UTType$Methods on UTType {
  /// encodeWithCoder:
  void encodeWithCoder(objc.NSCoder coder) {
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_encodeWithCoder_,
      coder.ref.pointer,
    );
  }

  /// identifier
  objc.NSString get identifier {
    objc.checkOsVersionInternal(
      'UTType.identifier',
      iOS: (false, (14, 0, 0)),
      macOS: (false, (11, 0, 0)),
    );
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_identifier);
    return objc.NSString.fromPointer($ret, retain: true, release: true);
  }

  /// init
  UTType init() {
    objc.checkOsVersionInternal(
      'UTType.init',
      iOS: (false, (2, 0, 0)),
      macOS: (false, (10, 0, 0)),
    );
    final $ret = _objc_msgSend_151sglz(
      object$.ref.retainAndReturnPointer(),
      _sel_init,
    );
    return UTType.fromPointer($ret, retain: false, release: true);
  }

  /// initWithCoder:
  UTType? initWithCoder(objc.NSCoder coder) {
    final $ret = _objc_msgSend_1sotr3r(
      object$.ref.retainAndReturnPointer(),
      _sel_initWithCoder_,
      coder.ref.pointer,
    );
    return $ret.address == 0
        ? null
        : UTType.fromPointer($ret, retain: false, release: true);
  }

  /// isDeclared
  bool get isDeclared {
    objc.checkOsVersionInternal(
      'UTType.isDeclared',
      iOS: (false, (14, 0, 0)),
      macOS: (false, (11, 0, 0)),
    );
    return _objc_msgSend_91o635(object$.ref.pointer, _sel_isDeclared);
  }

  /// isDynamic
  bool get isDynamic {
    objc.checkOsVersionInternal(
      'UTType.isDynamic',
      iOS: (false, (14, 0, 0)),
      macOS: (false, (11, 0, 0)),
    );
    return _objc_msgSend_91o635(object$.ref.pointer, _sel_isDynamic);
  }

  /// isPublicType
  bool get isPublicType {
    objc.checkOsVersionInternal(
      'UTType.isPublicType',
      iOS: (false, (14, 0, 0)),
      macOS: (false, (11, 0, 0)),
    );
    return _objc_msgSend_91o635(object$.ref.pointer, _sel_isPublicType);
  }

  /// localizedDescription
  objc.NSString? get localizedDescription {
    objc.checkOsVersionInternal(
      'UTType.localizedDescription',
      iOS: (false, (14, 0, 0)),
      macOS: (false, (11, 0, 0)),
    );
    final $ret = _objc_msgSend_151sglz(
      object$.ref.pointer,
      _sel_localizedDescription,
    );
    return $ret.address == 0
        ? null
        : objc.NSString.fromPointer($ret, retain: true, release: true);
  }

  /// preferredFilenameExtension
  objc.NSString? get preferredFilenameExtension {
    objc.checkOsVersionInternal(
      'UTType.preferredFilenameExtension',
      iOS: (false, (14, 0, 0)),
      macOS: (false, (11, 0, 0)),
    );
    final $ret = _objc_msgSend_151sglz(
      object$.ref.pointer,
      _sel_preferredFilenameExtension,
    );
    return $ret.address == 0
        ? null
        : objc.NSString.fromPointer($ret, retain: true, release: true);
  }

  /// preferredMIMEType
  objc.NSString? get preferredMIMEType {
    objc.checkOsVersionInternal(
      'UTType.preferredMIMEType',
      iOS: (false, (14, 0, 0)),
      macOS: (false, (11, 0, 0)),
    );
    final $ret = _objc_msgSend_151sglz(
      object$.ref.pointer,
      _sel_preferredMIMEType,
    );
    return $ret.address == 0
        ? null
        : objc.NSString.fromPointer($ret, retain: true, release: true);
  }

  /// referenceURL
  objc.NSURL? get referenceURL {
    objc.checkOsVersionInternal(
      'UTType.referenceURL',
      iOS: (false, (14, 0, 0)),
      macOS: (false, (11, 0, 0)),
    );
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_referenceURL);
    return $ret.address == 0
        ? null
        : objc.NSURL.fromPointer($ret, retain: true, release: true);
  }

  /// version
  objc.NSNumber? get version {
    objc.checkOsVersionInternal(
      'UTType.version',
      iOS: (false, (14, 0, 0)),
      macOS: (false, (11, 0, 0)),
    );
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_version);
    return $ret.address == 0
        ? null
        : objc.NSNumber.fromPointer($ret, retain: true, release: true);
  }
}

late final _sel_contentType = objc.registerName("contentType");
late final _sel_setContentType_ = objc.registerName("setContentType:");
late final _sel_fileURL = objc.registerName("fileURL");
late final _sel_setFileURL_ = objc.registerName("setFileURL:");
late final _sel_supportedContentTypes = objc.registerName(
  "supportedContentTypes",
);

/// SCScreenshotConfiguration
extension type SCScreenshotConfiguration._(objc.ObjCObject object$)
    implements objc.ObjCObject, objc.NSObject {
  /// Constructs a [SCScreenshotConfiguration] that points to the same underlying object as [other].
  SCScreenshotConfiguration.as(objc.ObjCObject other) : object$ = other {
    assert(isA(object$));
  }

  /// Constructs a [SCScreenshotConfiguration] that wraps the given raw object pointer.
  SCScreenshotConfiguration.fromPointer(
    ffi.Pointer<objc.ObjCObjectImpl> other, {
    bool retain = false,
    bool release = false,
  }) : object$ = objc.ObjCObject(other, retain: retain, release: release) {
    assert(isA(object$));
  }

  /// Returns whether [obj] is an instance of [SCScreenshotConfiguration].
  static bool isA(objc.ObjCObject obj) => _objc_msgSend_19nvye5(
    obj.ref.pointer,
    _sel_isKindOfClass_,
    _class_SCScreenshotConfiguration,
  );

  /// alloc
  static SCScreenshotConfiguration alloc() {
    final $ret = _objc_msgSend_151sglz(
      _class_SCScreenshotConfiguration,
      _sel_alloc,
    );
    return SCScreenshotConfiguration.fromPointer(
      $ret,
      retain: false,
      release: true,
    );
  }

  /// allocWithZone:
  static SCScreenshotConfiguration allocWithZone(
    ffi.Pointer<objc.NSZone> zone,
  ) {
    final $ret = _objc_msgSend_1cwp428(
      _class_SCScreenshotConfiguration,
      _sel_allocWithZone_,
      zone,
    );
    return SCScreenshotConfiguration.fromPointer(
      $ret,
      retain: false,
      release: true,
    );
  }

  /// new
  static SCScreenshotConfiguration new$() {
    final $ret = _objc_msgSend_151sglz(
      _class_SCScreenshotConfiguration,
      _sel_new,
    );
    return SCScreenshotConfiguration.fromPointer(
      $ret,
      retain: false,
      release: true,
    );
  }

  /// supportedContentTypes
  static objc.NSArray getSupportedContentTypes() {
    final $ret = _objc_msgSend_151sglz(
      _class_SCScreenshotConfiguration,
      _sel_supportedContentTypes,
    );
    return objc.NSArray.fromPointer($ret, retain: true, release: true);
  }

  /// Returns a new instance of SCScreenshotConfiguration constructed with the default `new` method.
  SCScreenshotConfiguration() : this.as(new$().object$);
}

extension SCScreenshotConfiguration$Methods on SCScreenshotConfiguration {
  /// contentType
  UTType get contentType {
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_contentType);
    return UTType.fromPointer($ret, retain: true, release: true);
  }

  /// destinationRect
  objc.CGRect get destinationRect {
    final $ptr = pkg_ffi.calloc<objc.CGRect>();
    objc.useMsgSendVariants
        ? _objc_msgSend_bu1hbwStret(
            $ptr,
            object$.ref.pointer,
            _sel_destinationRect,
          )
        : $ptr.ref = _objc_msgSend_bu1hbw(
            object$.ref.pointer,
            _sel_destinationRect,
          );
    final $finalizable = $ptr.cast<ffi.Uint8>().asTypedList(
      ffi.sizeOf<objc.CGRect>(),
      finalizer: pkg_ffi.calloc.nativeFree,
    );
    return ffi.Struct.create<objc.CGRect>($finalizable);
  }

  /// displayIntent
  SCScreenshotDisplayIntent get displayIntent {
    final $ret = _objc_msgSend_1hd3foh(object$.ref.pointer, _sel_displayIntent);
    return SCScreenshotDisplayIntent.fromValue($ret);
  }

  /// dynamicRange
  SCScreenshotDynamicRange get dynamicRange {
    final $ret = _objc_msgSend_ibmwpx(object$.ref.pointer, _sel_dynamicRange);
    return SCScreenshotDynamicRange.fromValue($ret);
  }

  /// fileURL
  objc.NSURL? get fileURL {
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_fileURL);
    return $ret.address == 0
        ? null
        : objc.NSURL.fromPointer($ret, retain: true, release: true);
  }

  /// height
  int get height {
    return _objc_msgSend_1hz7y9r(object$.ref.pointer, _sel_height);
  }

  /// ignoreClipping
  bool get ignoreClipping {
    return _objc_msgSend_91o635(object$.ref.pointer, _sel_ignoreClipping);
  }

  /// ignoreShadows
  bool get ignoreShadows {
    return _objc_msgSend_91o635(object$.ref.pointer, _sel_ignoreShadows);
  }

  /// includeChildWindows
  bool get includeChildWindows {
    return _objc_msgSend_91o635(object$.ref.pointer, _sel_includeChildWindows);
  }

  /// init
  SCScreenshotConfiguration init() {
    objc.checkOsVersionInternal(
      'SCScreenshotConfiguration.init',
      iOS: (false, (2, 0, 0)),
      macOS: (false, (10, 0, 0)),
    );
    final $ret = _objc_msgSend_151sglz(
      object$.ref.retainAndReturnPointer(),
      _sel_init,
    );
    return SCScreenshotConfiguration.fromPointer(
      $ret,
      retain: false,
      release: true,
    );
  }

  /// setContentType:
  set contentType(UTType value) {
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_setContentType_,
      value.ref.pointer,
    );
  }

  /// setDestinationRect:
  set destinationRect(objc.CGRect value) {
    _objc_msgSend_1okkq16(object$.ref.pointer, _sel_setDestinationRect_, value);
  }

  /// setDisplayIntent:
  set displayIntent(SCScreenshotDisplayIntent value) {
    _objc_msgSend_1aipfm1(
      object$.ref.pointer,
      _sel_setDisplayIntent_,
      value.value,
    );
  }

  /// setDynamicRange:
  set dynamicRange(SCScreenshotDynamicRange value) {
    _objc_msgSend_1wrfi5l(
      object$.ref.pointer,
      _sel_setDynamicRange_,
      value.value,
    );
  }

  /// setFileURL:
  set fileURL(objc.NSURL? value) {
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_setFileURL_,
      value?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// setHeight:
  set height(int value) {
    _objc_msgSend_4sp4xj(object$.ref.pointer, _sel_setHeight_, value);
  }

  /// setIgnoreClipping:
  set ignoreClipping(bool value) {
    _objc_msgSend_1s56lr9(object$.ref.pointer, _sel_setIgnoreClipping_, value);
  }

  /// setIgnoreShadows:
  set ignoreShadows(bool value) {
    _objc_msgSend_1s56lr9(object$.ref.pointer, _sel_setIgnoreShadows_, value);
  }

  /// setIncludeChildWindows:
  set includeChildWindows(bool value) {
    _objc_msgSend_1s56lr9(
      object$.ref.pointer,
      _sel_setIncludeChildWindows_,
      value,
    );
  }

  /// setShowsCursor:
  set showsCursor(bool value) {
    _objc_msgSend_1s56lr9(object$.ref.pointer, _sel_setShowsCursor_, value);
  }

  /// setSourceRect:
  set sourceRect(objc.CGRect value) {
    _objc_msgSend_1okkq16(object$.ref.pointer, _sel_setSourceRect_, value);
  }

  /// setWidth:
  set width(int value) {
    _objc_msgSend_4sp4xj(object$.ref.pointer, _sel_setWidth_, value);
  }

  /// showsCursor
  bool get showsCursor {
    return _objc_msgSend_91o635(object$.ref.pointer, _sel_showsCursor);
  }

  /// sourceRect
  objc.CGRect get sourceRect {
    final $ptr = pkg_ffi.calloc<objc.CGRect>();
    objc.useMsgSendVariants
        ? _objc_msgSend_bu1hbwStret($ptr, object$.ref.pointer, _sel_sourceRect)
        : $ptr.ref = _objc_msgSend_bu1hbw(object$.ref.pointer, _sel_sourceRect);
    final $finalizable = $ptr.cast<ffi.Uint8>().asTypedList(
      ffi.sizeOf<objc.CGRect>(),
      finalizer: pkg_ffi.calloc.nativeFree,
    );
    return ffi.Struct.create<objc.CGRect>($finalizable);
  }

  /// width
  int get width {
    return _objc_msgSend_1hz7y9r(object$.ref.pointer, _sel_width);
  }
}

late final _class_SCScreenshotOutput = objc.getClass("SCScreenshotOutput");
late final _sel_sdrImage = objc.registerName("sdrImage");
final _objc_msgSend_y1izi1 = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Pointer<CGImage> Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
        )
      >
    >()
    .asFunction<
      ffi.Pointer<CGImage> Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
      )
    >();
late final _sel_setSdrImage_ = objc.registerName("setSdrImage:");
final _objc_msgSend_1gs4jd1 = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Pointer<CGImage>,
        )
      >
    >()
    .asFunction<
      void Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
        ffi.Pointer<CGImage>,
      )
    >();
late final _sel_hdrImage = objc.registerName("hdrImage");
late final _sel_setHdrImage_ = objc.registerName("setHdrImage:");

/// SCScreenshotOutput
extension type SCScreenshotOutput._(objc.ObjCObject object$)
    implements objc.ObjCObject, objc.NSObject {
  /// Constructs a [SCScreenshotOutput] that points to the same underlying object as [other].
  SCScreenshotOutput.as(objc.ObjCObject other) : object$ = other {
    assert(isA(object$));
  }

  /// Constructs a [SCScreenshotOutput] that wraps the given raw object pointer.
  SCScreenshotOutput.fromPointer(
    ffi.Pointer<objc.ObjCObjectImpl> other, {
    bool retain = false,
    bool release = false,
  }) : object$ = objc.ObjCObject(other, retain: retain, release: release) {
    assert(isA(object$));
  }

  /// Returns whether [obj] is an instance of [SCScreenshotOutput].
  static bool isA(objc.ObjCObject obj) => _objc_msgSend_19nvye5(
    obj.ref.pointer,
    _sel_isKindOfClass_,
    _class_SCScreenshotOutput,
  );

  /// alloc
  static SCScreenshotOutput alloc() {
    final $ret = _objc_msgSend_151sglz(_class_SCScreenshotOutput, _sel_alloc);
    return SCScreenshotOutput.fromPointer($ret, retain: false, release: true);
  }

  /// allocWithZone:
  static SCScreenshotOutput allocWithZone(ffi.Pointer<objc.NSZone> zone) {
    final $ret = _objc_msgSend_1cwp428(
      _class_SCScreenshotOutput,
      _sel_allocWithZone_,
      zone,
    );
    return SCScreenshotOutput.fromPointer($ret, retain: false, release: true);
  }

  /// new
  static SCScreenshotOutput new$() {
    final $ret = _objc_msgSend_151sglz(_class_SCScreenshotOutput, _sel_new);
    return SCScreenshotOutput.fromPointer($ret, retain: false, release: true);
  }

  /// Returns a new instance of SCScreenshotOutput constructed with the default `new` method.
  SCScreenshotOutput() : this.as(new$().object$);
}

extension SCScreenshotOutput$Methods on SCScreenshotOutput {
  /// fileURL
  objc.NSURL? get fileURL {
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_fileURL);
    return $ret.address == 0
        ? null
        : objc.NSURL.fromPointer($ret, retain: true, release: true);
  }

  /// hdrImage
  ffi.Pointer<CGImage> get hdrImage {
    return _objc_msgSend_y1izi1(object$.ref.pointer, _sel_hdrImage);
  }

  /// init
  SCScreenshotOutput init() {
    objc.checkOsVersionInternal(
      'SCScreenshotOutput.init',
      iOS: (false, (2, 0, 0)),
      macOS: (false, (10, 0, 0)),
    );
    final $ret = _objc_msgSend_151sglz(
      object$.ref.retainAndReturnPointer(),
      _sel_init,
    );
    return SCScreenshotOutput.fromPointer($ret, retain: false, release: true);
  }

  /// sdrImage
  ffi.Pointer<CGImage> get sdrImage {
    return _objc_msgSend_y1izi1(object$.ref.pointer, _sel_sdrImage);
  }

  /// setFileURL:
  set fileURL(objc.NSURL? value) {
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_setFileURL_,
      value?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// setHdrImage:
  set hdrImage(ffi.Pointer<CGImage> value) {
    _objc_msgSend_1gs4jd1(object$.ref.pointer, _sel_setHdrImage_, value);
  }

  /// setSdrImage:
  set sdrImage(ffi.Pointer<CGImage> value) {
    _objc_msgSend_1gs4jd1(object$.ref.pointer, _sel_setSdrImage_, value);
  }
}

late final _class_SCScreenshotManager = objc.getClass("SCScreenshotManager");

/// Construction methods for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<opaqueCMSampleBuffer>, objc.NSError?)>`.
abstract final class ObjCBlock_ffiVoid_CMSampleBufferRef_NSError {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<
    ffi.Void Function(ffi.Pointer<opaqueCMSampleBuffer>, objc.NSError?)
  >
  fromPointer(
    ffi.Pointer<objc.ObjCBlockImpl> pointer, {
    bool retain = false,
    bool release = false,
  }) =>
      objc.ObjCBlock<
        ffi.Void Function(ffi.Pointer<opaqueCMSampleBuffer>, objc.NSError?)
      >(pointer, retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<
    ffi.Void Function(ffi.Pointer<opaqueCMSampleBuffer>, objc.NSError?)
  >
  fromFunctionPointer(
    ffi.Pointer<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<opaqueCMSampleBuffer> arg0,
          ffi.Pointer<objc.ObjCObjectImpl> arg1,
        )
      >
    >
    ptr,
  ) =>
      objc.ObjCBlock<
        ffi.Void Function(ffi.Pointer<opaqueCMSampleBuffer>, objc.NSError?)
      >(
        objc.newPointerBlock(_fnPtrCallable, ptr.cast()),
        retain: false,
        release: true,
      );

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<
    ffi.Void Function(ffi.Pointer<opaqueCMSampleBuffer>, objc.NSError?)
  >
  fromFunction(
    void Function(ffi.Pointer<opaqueCMSampleBuffer>, objc.NSError?) fn, {
    bool keepIsolateAlive = true,
  }) =>
      objc.ObjCBlock<
        ffi.Void Function(ffi.Pointer<opaqueCMSampleBuffer>, objc.NSError?)
      >(
        objc.newClosureBlock(
          _closureCallable,
          (
            ffi.Pointer<opaqueCMSampleBuffer> arg0,
            ffi.Pointer<objc.ObjCObjectImpl> arg1,
          ) => fn(
            arg0,
            arg1.address == 0
                ? null
                : objc.NSError.fromPointer(arg1, retain: true, release: true),
          ),
          keepIsolateAlive,
        ),
        retain: false,
        release: true,
      );

  /// Creates a listener block from a Dart function.
  ///
  /// This is based on FFI's NativeCallable.listener, and has the same
  /// capabilities and limitations. This block can be invoked from any thread,
  /// but only supports void functions, and is not run synchronously. See
  /// NativeCallable.listener for more details.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<
    ffi.Void Function(ffi.Pointer<opaqueCMSampleBuffer>, objc.NSError?)
  >
  listener(
    void Function(ffi.Pointer<opaqueCMSampleBuffer>, objc.NSError?) fn, {
    bool keepIsolateAlive = true,
  }) {
    final raw = objc.newClosureBlock(
      _listenerCallable.nativeFunction.cast(),
      (
        ffi.Pointer<opaqueCMSampleBuffer> arg0,
        ffi.Pointer<objc.ObjCObjectImpl> arg1,
      ) => fn(
        arg0,
        arg1.address == 0
            ? null
            : objc.NSError.fromPointer(arg1, retain: false, release: true),
      ),
      keepIsolateAlive,
    );
    final wrapper = _NativeLibrary_wrapListenerBlock_ro4zln(raw);
    objc.objectRelease(raw.cast());
    return objc.ObjCBlock<
      ffi.Void Function(ffi.Pointer<opaqueCMSampleBuffer>, objc.NSError?)
    >(wrapper, retain: false, release: true);
  }

  /// Creates a blocking block from a Dart function.
  ///
  /// This callback can be invoked from any native thread, and will block the
  /// caller until the callback is handled by the Dart isolate that created
  /// the block. Async functions are not supported.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC. If the owner isolate
  /// has shut down, and the block is invoked by native code, it may block
  /// indefinitely, or have other undefined behavior.
  static objc.ObjCBlock<
    ffi.Void Function(ffi.Pointer<opaqueCMSampleBuffer>, objc.NSError?)
  >
  blocking(
    void Function(ffi.Pointer<opaqueCMSampleBuffer>, objc.NSError?) fn, {
    bool keepIsolateAlive = true,
  }) {
    final raw = objc.newClosureBlock(
      _blockingCallable.nativeFunction.cast(),
      (
        ffi.Pointer<opaqueCMSampleBuffer> arg0,
        ffi.Pointer<objc.ObjCObjectImpl> arg1,
      ) => fn(
        arg0,
        arg1.address == 0
            ? null
            : objc.NSError.fromPointer(arg1, retain: false, release: true),
      ),
      keepIsolateAlive,
    );
    final rawListener = objc.newClosureBlock(
      _blockingListenerCallable.nativeFunction.cast(),
      (
        ffi.Pointer<opaqueCMSampleBuffer> arg0,
        ffi.Pointer<objc.ObjCObjectImpl> arg1,
      ) => fn(
        arg0,
        arg1.address == 0
            ? null
            : objc.NSError.fromPointer(arg1, retain: false, release: true),
      ),
      keepIsolateAlive,
    );
    final wrapper = _NativeLibrary_wrapBlockingBlock_ro4zln(
      raw,
      rawListener,
      objc.objCContext,
    );
    objc.objectRelease(raw.cast());
    objc.objectRelease(rawListener.cast());
    return objc.ObjCBlock<
      ffi.Void Function(ffi.Pointer<opaqueCMSampleBuffer>, objc.NSError?)
    >(wrapper, retain: false, release: true);
  }

  static void _listenerTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<opaqueCMSampleBuffer> arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
  ) {
    (objc.getBlockClosure(block)
        as void Function(
          ffi.Pointer<opaqueCMSampleBuffer>,
          ffi.Pointer<objc.ObjCObjectImpl>,
        ))(arg0, arg1);
    objc.objectRelease(block.cast());
  }

  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<opaqueCMSampleBuffer>,
      ffi.Pointer<objc.ObjCObjectImpl>,
    )
  >
  _listenerCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<opaqueCMSampleBuffer>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          )
        >.listener(_listenerTrampoline)
        ..keepIsolateAlive = false;
  static void _blockingTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> waiter,
    ffi.Pointer<opaqueCMSampleBuffer> arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
  ) {
    try {
      (objc.getBlockClosure(block)
          as void Function(
            ffi.Pointer<opaqueCMSampleBuffer>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          ))(arg0, arg1);
    } catch (e) {
    } finally {
      objc.signalWaiter(waiter);
      objc.objectRelease(block.cast());
    }
  }

  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<opaqueCMSampleBuffer>,
      ffi.Pointer<objc.ObjCObjectImpl>,
    )
  >
  _blockingCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<opaqueCMSampleBuffer>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          )
        >.isolateLocal(_blockingTrampoline)
        ..keepIsolateAlive = false;
  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<opaqueCMSampleBuffer>,
      ffi.Pointer<objc.ObjCObjectImpl>,
    )
  >
  _blockingListenerCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<opaqueCMSampleBuffer>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          )
        >.listener(_blockingTrampoline)
        ..keepIsolateAlive = false;
  static void _fnPtrTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<opaqueCMSampleBuffer> arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
  ) => block.ref.target
      .cast<
        ffi.NativeFunction<
          ffi.Void Function(
            ffi.Pointer<opaqueCMSampleBuffer> arg0,
            ffi.Pointer<objc.ObjCObjectImpl> arg1,
          )
        >
      >()
      .asFunction<
        void Function(
          ffi.Pointer<opaqueCMSampleBuffer>,
          ffi.Pointer<objc.ObjCObjectImpl>,
        )
      >()(arg0, arg1);
  static ffi.Pointer<ffi.Void> _fnPtrCallable =
      ffi.Pointer.fromFunction<
            ffi.Void Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<opaqueCMSampleBuffer>,
              ffi.Pointer<objc.ObjCObjectImpl>,
            )
          >(_fnPtrTrampoline)
          .cast();
  static void _closureTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<opaqueCMSampleBuffer> arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
  ) =>
      (objc.getBlockClosure(block)
          as void Function(
            ffi.Pointer<opaqueCMSampleBuffer>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          ))(arg0, arg1);
  static ffi.Pointer<ffi.Void> _closureCallable =
      ffi.Pointer.fromFunction<
            ffi.Void Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<opaqueCMSampleBuffer>,
              ffi.Pointer<objc.ObjCObjectImpl>,
            )
          >(_closureTrampoline)
          .cast();
}

/// Call operator for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<opaqueCMSampleBuffer>, objc.NSError?)>`.
extension ObjCBlock_ffiVoid_CMSampleBufferRef_NSError$CallExtension
    on
        objc.ObjCBlock<
          ffi.Void Function(ffi.Pointer<opaqueCMSampleBuffer>, objc.NSError?)
        > {
  void call(ffi.Pointer<opaqueCMSampleBuffer> arg0, objc.NSError? arg1) => ref
      .pointer
      .ref
      .invoke
      .cast<
        ffi.NativeFunction<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl> block,
            ffi.Pointer<opaqueCMSampleBuffer> arg0,
            ffi.Pointer<objc.ObjCObjectImpl> arg1,
          )
        >
      >()
      .asFunction<
        void Function(
          ffi.Pointer<objc.ObjCBlockImpl>,
          ffi.Pointer<opaqueCMSampleBuffer>,
          ffi.Pointer<objc.ObjCObjectImpl>,
        )
      >()(ref.pointer, arg0, arg1?.ref.pointer ?? ffi.nullptr);
}

late final _sel_captureSampleBufferWithFilter_configuration_completionHandler_ =
    objc.registerName(
      "captureSampleBufferWithFilter:configuration:completionHandler:",
    );
final _objc_msgSend_18qun1e = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCBlockImpl>,
        )
      >
    >()
    .asFunction<
      void Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCBlockImpl>,
      )
    >();

/// Construction methods for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<CGImage>, objc.NSError?)>`.
abstract final class ObjCBlock_ffiVoid_CGImageRef_NSError {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<CGImage>, objc.NSError?)>
  fromPointer(
    ffi.Pointer<objc.ObjCBlockImpl> pointer, {
    bool retain = false,
    bool release = false,
  }) => objc.ObjCBlock<ffi.Void Function(ffi.Pointer<CGImage>, objc.NSError?)>(
    pointer,
    retain: retain,
    release: release,
  );

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<CGImage>, objc.NSError?)>
  fromFunctionPointer(
    ffi.Pointer<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<CGImage> arg0,
          ffi.Pointer<objc.ObjCObjectImpl> arg1,
        )
      >
    >
    ptr,
  ) => objc.ObjCBlock<ffi.Void Function(ffi.Pointer<CGImage>, objc.NSError?)>(
    objc.newPointerBlock(_fnPtrCallable, ptr.cast()),
    retain: false,
    release: true,
  );

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<CGImage>, objc.NSError?)>
  fromFunction(
    void Function(ffi.Pointer<CGImage>, objc.NSError?) fn, {
    bool keepIsolateAlive = true,
  }) => objc.ObjCBlock<ffi.Void Function(ffi.Pointer<CGImage>, objc.NSError?)>(
    objc.newClosureBlock(
      _closureCallable,
      (ffi.Pointer<CGImage> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1) => fn(
        arg0,
        arg1.address == 0
            ? null
            : objc.NSError.fromPointer(arg1, retain: true, release: true),
      ),
      keepIsolateAlive,
    ),
    retain: false,
    release: true,
  );

  /// Creates a listener block from a Dart function.
  ///
  /// This is based on FFI's NativeCallable.listener, and has the same
  /// capabilities and limitations. This block can be invoked from any thread,
  /// but only supports void functions, and is not run synchronously. See
  /// NativeCallable.listener for more details.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<CGImage>, objc.NSError?)>
  listener(
    void Function(ffi.Pointer<CGImage>, objc.NSError?) fn, {
    bool keepIsolateAlive = true,
  }) {
    final raw = objc.newClosureBlock(
      _listenerCallable.nativeFunction.cast(),
      (ffi.Pointer<CGImage> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1) => fn(
        arg0,
        arg1.address == 0
            ? null
            : objc.NSError.fromPointer(arg1, retain: false, release: true),
      ),
      keepIsolateAlive,
    );
    final wrapper = _NativeLibrary_wrapListenerBlock_19ugjh7(raw);
    objc.objectRelease(raw.cast());
    return objc.ObjCBlock<
      ffi.Void Function(ffi.Pointer<CGImage>, objc.NSError?)
    >(wrapper, retain: false, release: true);
  }

  /// Creates a blocking block from a Dart function.
  ///
  /// This callback can be invoked from any native thread, and will block the
  /// caller until the callback is handled by the Dart isolate that created
  /// the block. Async functions are not supported.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC. If the owner isolate
  /// has shut down, and the block is invoked by native code, it may block
  /// indefinitely, or have other undefined behavior.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<CGImage>, objc.NSError?)>
  blocking(
    void Function(ffi.Pointer<CGImage>, objc.NSError?) fn, {
    bool keepIsolateAlive = true,
  }) {
    final raw = objc.newClosureBlock(
      _blockingCallable.nativeFunction.cast(),
      (ffi.Pointer<CGImage> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1) => fn(
        arg0,
        arg1.address == 0
            ? null
            : objc.NSError.fromPointer(arg1, retain: false, release: true),
      ),
      keepIsolateAlive,
    );
    final rawListener = objc.newClosureBlock(
      _blockingListenerCallable.nativeFunction.cast(),
      (ffi.Pointer<CGImage> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1) => fn(
        arg0,
        arg1.address == 0
            ? null
            : objc.NSError.fromPointer(arg1, retain: false, release: true),
      ),
      keepIsolateAlive,
    );
    final wrapper = _NativeLibrary_wrapBlockingBlock_19ugjh7(
      raw,
      rawListener,
      objc.objCContext,
    );
    objc.objectRelease(raw.cast());
    objc.objectRelease(rawListener.cast());
    return objc.ObjCBlock<
      ffi.Void Function(ffi.Pointer<CGImage>, objc.NSError?)
    >(wrapper, retain: false, release: true);
  }

  static void _listenerTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<CGImage> arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
  ) {
    (objc.getBlockClosure(block)
        as void Function(
          ffi.Pointer<CGImage>,
          ffi.Pointer<objc.ObjCObjectImpl>,
        ))(arg0, arg1);
    objc.objectRelease(block.cast());
  }

  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<CGImage>,
      ffi.Pointer<objc.ObjCObjectImpl>,
    )
  >
  _listenerCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<CGImage>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          )
        >.listener(_listenerTrampoline)
        ..keepIsolateAlive = false;
  static void _blockingTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> waiter,
    ffi.Pointer<CGImage> arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
  ) {
    try {
      (objc.getBlockClosure(block)
          as void Function(
            ffi.Pointer<CGImage>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          ))(arg0, arg1);
    } catch (e) {
    } finally {
      objc.signalWaiter(waiter);
      objc.objectRelease(block.cast());
    }
  }

  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<CGImage>,
      ffi.Pointer<objc.ObjCObjectImpl>,
    )
  >
  _blockingCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<CGImage>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          )
        >.isolateLocal(_blockingTrampoline)
        ..keepIsolateAlive = false;
  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<CGImage>,
      ffi.Pointer<objc.ObjCObjectImpl>,
    )
  >
  _blockingListenerCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<CGImage>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          )
        >.listener(_blockingTrampoline)
        ..keepIsolateAlive = false;
  static void _fnPtrTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<CGImage> arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
  ) => block.ref.target
      .cast<
        ffi.NativeFunction<
          ffi.Void Function(
            ffi.Pointer<CGImage> arg0,
            ffi.Pointer<objc.ObjCObjectImpl> arg1,
          )
        >
      >()
      .asFunction<
        void Function(ffi.Pointer<CGImage>, ffi.Pointer<objc.ObjCObjectImpl>)
      >()(arg0, arg1);
  static ffi.Pointer<ffi.Void> _fnPtrCallable =
      ffi.Pointer.fromFunction<
            ffi.Void Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<CGImage>,
              ffi.Pointer<objc.ObjCObjectImpl>,
            )
          >(_fnPtrTrampoline)
          .cast();
  static void _closureTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<CGImage> arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
  ) =>
      (objc.getBlockClosure(block)
          as void Function(
            ffi.Pointer<CGImage>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          ))(arg0, arg1);
  static ffi.Pointer<ffi.Void> _closureCallable =
      ffi.Pointer.fromFunction<
            ffi.Void Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<CGImage>,
              ffi.Pointer<objc.ObjCObjectImpl>,
            )
          >(_closureTrampoline)
          .cast();
}

/// Call operator for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<CGImage>, objc.NSError?)>`.
extension ObjCBlock_ffiVoid_CGImageRef_NSError$CallExtension
    on objc.ObjCBlock<ffi.Void Function(ffi.Pointer<CGImage>, objc.NSError?)> {
  void call(ffi.Pointer<CGImage> arg0, objc.NSError? arg1) => ref
      .pointer
      .ref
      .invoke
      .cast<
        ffi.NativeFunction<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl> block,
            ffi.Pointer<CGImage> arg0,
            ffi.Pointer<objc.ObjCObjectImpl> arg1,
          )
        >
      >()
      .asFunction<
        void Function(
          ffi.Pointer<objc.ObjCBlockImpl>,
          ffi.Pointer<CGImage>,
          ffi.Pointer<objc.ObjCObjectImpl>,
        )
      >()(ref.pointer, arg0, arg1?.ref.pointer ?? ffi.nullptr);
}

late final _sel_captureImageWithFilter_configuration_completionHandler_ = objc
    .registerName("captureImageWithFilter:configuration:completionHandler:");
late final _sel_captureImageInRect_completionHandler_ = objc.registerName(
  "captureImageInRect:completionHandler:",
);
final _objc_msgSend_1ekrzmp = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
          objc.CGRect,
          ffi.Pointer<objc.ObjCBlockImpl>,
        )
      >
    >()
    .asFunction<
      void Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
        objc.CGRect,
        ffi.Pointer<objc.ObjCBlockImpl>,
      )
    >();

/// Construction methods for `objc.ObjCBlock<ffi.Void Function(SCScreenshotOutput?, objc.NSError?)>`.
abstract final class ObjCBlock_ffiVoid_SCScreenshotOutput_NSError {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<ffi.Void Function(SCScreenshotOutput?, objc.NSError?)>
  fromPointer(
    ffi.Pointer<objc.ObjCBlockImpl> pointer, {
    bool retain = false,
    bool release = false,
  }) => objc.ObjCBlock<ffi.Void Function(SCScreenshotOutput?, objc.NSError?)>(
    pointer,
    retain: retain,
    release: release,
  );

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<ffi.Void Function(SCScreenshotOutput?, objc.NSError?)>
  fromFunctionPointer(
    ffi.Pointer<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<objc.ObjCObjectImpl> arg0,
          ffi.Pointer<objc.ObjCObjectImpl> arg1,
        )
      >
    >
    ptr,
  ) => objc.ObjCBlock<ffi.Void Function(SCScreenshotOutput?, objc.NSError?)>(
    objc.newPointerBlock(_fnPtrCallable, ptr.cast()),
    retain: false,
    release: true,
  );

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Void Function(SCScreenshotOutput?, objc.NSError?)>
  fromFunction(
    void Function(SCScreenshotOutput?, objc.NSError?) fn, {
    bool keepIsolateAlive = true,
  }) => objc.ObjCBlock<ffi.Void Function(SCScreenshotOutput?, objc.NSError?)>(
    objc.newClosureBlock(
      _closureCallable,
      (
        ffi.Pointer<objc.ObjCObjectImpl> arg0,
        ffi.Pointer<objc.ObjCObjectImpl> arg1,
      ) => fn(
        arg0.address == 0
            ? null
            : SCScreenshotOutput.fromPointer(arg0, retain: true, release: true),
        arg1.address == 0
            ? null
            : objc.NSError.fromPointer(arg1, retain: true, release: true),
      ),
      keepIsolateAlive,
    ),
    retain: false,
    release: true,
  );

  /// Creates a listener block from a Dart function.
  ///
  /// This is based on FFI's NativeCallable.listener, and has the same
  /// capabilities and limitations. This block can be invoked from any thread,
  /// but only supports void functions, and is not run synchronously. See
  /// NativeCallable.listener for more details.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Void Function(SCScreenshotOutput?, objc.NSError?)>
  listener(
    void Function(SCScreenshotOutput?, objc.NSError?) fn, {
    bool keepIsolateAlive = true,
  }) {
    final raw = objc.newClosureBlock(
      _listenerCallable.nativeFunction.cast(),
      (
        ffi.Pointer<objc.ObjCObjectImpl> arg0,
        ffi.Pointer<objc.ObjCObjectImpl> arg1,
      ) => fn(
        arg0.address == 0
            ? null
            : SCScreenshotOutput.fromPointer(
                arg0,
                retain: false,
                release: true,
              ),
        arg1.address == 0
            ? null
            : objc.NSError.fromPointer(arg1, retain: false, release: true),
      ),
      keepIsolateAlive,
    );
    final wrapper = _NativeLibrary_wrapListenerBlock_pfv6jd(raw);
    objc.objectRelease(raw.cast());
    return objc.ObjCBlock<
      ffi.Void Function(SCScreenshotOutput?, objc.NSError?)
    >(wrapper, retain: false, release: true);
  }

  /// Creates a blocking block from a Dart function.
  ///
  /// This callback can be invoked from any native thread, and will block the
  /// caller until the callback is handled by the Dart isolate that created
  /// the block. Async functions are not supported.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC. If the owner isolate
  /// has shut down, and the block is invoked by native code, it may block
  /// indefinitely, or have other undefined behavior.
  static objc.ObjCBlock<ffi.Void Function(SCScreenshotOutput?, objc.NSError?)>
  blocking(
    void Function(SCScreenshotOutput?, objc.NSError?) fn, {
    bool keepIsolateAlive = true,
  }) {
    final raw = objc.newClosureBlock(
      _blockingCallable.nativeFunction.cast(),
      (
        ffi.Pointer<objc.ObjCObjectImpl> arg0,
        ffi.Pointer<objc.ObjCObjectImpl> arg1,
      ) => fn(
        arg0.address == 0
            ? null
            : SCScreenshotOutput.fromPointer(
                arg0,
                retain: false,
                release: true,
              ),
        arg1.address == 0
            ? null
            : objc.NSError.fromPointer(arg1, retain: false, release: true),
      ),
      keepIsolateAlive,
    );
    final rawListener = objc.newClosureBlock(
      _blockingListenerCallable.nativeFunction.cast(),
      (
        ffi.Pointer<objc.ObjCObjectImpl> arg0,
        ffi.Pointer<objc.ObjCObjectImpl> arg1,
      ) => fn(
        arg0.address == 0
            ? null
            : SCScreenshotOutput.fromPointer(
                arg0,
                retain: false,
                release: true,
              ),
        arg1.address == 0
            ? null
            : objc.NSError.fromPointer(arg1, retain: false, release: true),
      ),
      keepIsolateAlive,
    );
    final wrapper = _NativeLibrary_wrapBlockingBlock_pfv6jd(
      raw,
      rawListener,
      objc.objCContext,
    );
    objc.objectRelease(raw.cast());
    objc.objectRelease(rawListener.cast());
    return objc.ObjCBlock<
      ffi.Void Function(SCScreenshotOutput?, objc.NSError?)
    >(wrapper, retain: false, release: true);
  }

  static void _listenerTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<objc.ObjCObjectImpl> arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
  ) {
    (objc.getBlockClosure(block)
        as void Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCObjectImpl>,
        ))(arg0, arg1);
    objc.objectRelease(block.cast());
  }

  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<objc.ObjCObjectImpl>,
      ffi.Pointer<objc.ObjCObjectImpl>,
    )
  >
  _listenerCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          )
        >.listener(_listenerTrampoline)
        ..keepIsolateAlive = false;
  static void _blockingTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> waiter,
    ffi.Pointer<objc.ObjCObjectImpl> arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
  ) {
    try {
      (objc.getBlockClosure(block)
          as void Function(
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          ))(arg0, arg1);
    } catch (e) {
    } finally {
      objc.signalWaiter(waiter);
      objc.objectRelease(block.cast());
    }
  }

  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<objc.ObjCObjectImpl>,
      ffi.Pointer<objc.ObjCObjectImpl>,
    )
  >
  _blockingCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          )
        >.isolateLocal(_blockingTrampoline)
        ..keepIsolateAlive = false;
  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<objc.ObjCObjectImpl>,
      ffi.Pointer<objc.ObjCObjectImpl>,
    )
  >
  _blockingListenerCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          )
        >.listener(_blockingTrampoline)
        ..keepIsolateAlive = false;
  static void _fnPtrTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<objc.ObjCObjectImpl> arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
  ) => block.ref.target
      .cast<
        ffi.NativeFunction<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCObjectImpl> arg0,
            ffi.Pointer<objc.ObjCObjectImpl> arg1,
          )
        >
      >()
      .asFunction<
        void Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCObjectImpl>,
        )
      >()(arg0, arg1);
  static ffi.Pointer<ffi.Void> _fnPtrCallable =
      ffi.Pointer.fromFunction<
            ffi.Void Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<objc.ObjCObjectImpl>,
              ffi.Pointer<objc.ObjCObjectImpl>,
            )
          >(_fnPtrTrampoline)
          .cast();
  static void _closureTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<objc.ObjCObjectImpl> arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
  ) =>
      (objc.getBlockClosure(block)
          as void Function(
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          ))(arg0, arg1);
  static ffi.Pointer<ffi.Void> _closureCallable =
      ffi.Pointer.fromFunction<
            ffi.Void Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<objc.ObjCObjectImpl>,
              ffi.Pointer<objc.ObjCObjectImpl>,
            )
          >(_closureTrampoline)
          .cast();
}

/// Call operator for `objc.ObjCBlock<ffi.Void Function(SCScreenshotOutput?, objc.NSError?)>`.
extension ObjCBlock_ffiVoid_SCScreenshotOutput_NSError$CallExtension
    on objc.ObjCBlock<ffi.Void Function(SCScreenshotOutput?, objc.NSError?)> {
  void call(SCScreenshotOutput? arg0, objc.NSError? arg1) =>
      ref.pointer.ref.invoke
          .cast<
            ffi.NativeFunction<
              ffi.Void Function(
                ffi.Pointer<objc.ObjCBlockImpl> block,
                ffi.Pointer<objc.ObjCObjectImpl> arg0,
                ffi.Pointer<objc.ObjCObjectImpl> arg1,
              )
            >
          >()
          .asFunction<
            void Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<objc.ObjCObjectImpl>,
              ffi.Pointer<objc.ObjCObjectImpl>,
            )
          >()(
        ref.pointer,
        arg0?.ref.pointer ?? ffi.nullptr,
        arg1?.ref.pointer ?? ffi.nullptr,
      );
}

late final _sel_captureScreenshotWithFilter_configuration_completionHandler_ =
    objc.registerName(
      "captureScreenshotWithFilter:configuration:completionHandler:",
    );
late final _sel_captureScreenshotWithRect_configuration_completionHandler_ =
    objc.registerName(
      "captureScreenshotWithRect:configuration:completionHandler:",
    );
final _objc_msgSend_4u48uz = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
          objc.CGRect,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCBlockImpl>,
        )
      >
    >()
    .asFunction<
      void Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
        objc.CGRect,
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCBlockImpl>,
      )
    >();

/// SCScreenshotManager
extension type SCScreenshotManager._(objc.ObjCObject object$)
    implements objc.ObjCObject, objc.NSObject {
  /// Constructs a [SCScreenshotManager] that points to the same underlying object as [other].
  SCScreenshotManager.as(objc.ObjCObject other) : object$ = other {
    objc.checkOsVersionInternal(
      'SCScreenshotManager',
      macOS: (false, (14, 0, 0)),
    );
    assert(isA(object$));
  }

  /// Constructs a [SCScreenshotManager] that wraps the given raw object pointer.
  SCScreenshotManager.fromPointer(
    ffi.Pointer<objc.ObjCObjectImpl> other, {
    bool retain = false,
    bool release = false,
  }) : object$ = objc.ObjCObject(other, retain: retain, release: release) {
    objc.checkOsVersionInternal(
      'SCScreenshotManager',
      macOS: (false, (14, 0, 0)),
    );
    assert(isA(object$));
  }

  /// Returns whether [obj] is an instance of [SCScreenshotManager].
  static bool isA(objc.ObjCObject obj) => _objc_msgSend_19nvye5(
    obj.ref.pointer,
    _sel_isKindOfClass_,
    _class_SCScreenshotManager,
  );

  /// alloc
  static SCScreenshotManager alloc() {
    final $ret = _objc_msgSend_151sglz(_class_SCScreenshotManager, _sel_alloc);
    return SCScreenshotManager.fromPointer($ret, retain: false, release: true);
  }

  /// allocWithZone:
  static SCScreenshotManager allocWithZone(ffi.Pointer<objc.NSZone> zone) {
    final $ret = _objc_msgSend_1cwp428(
      _class_SCScreenshotManager,
      _sel_allocWithZone_,
      zone,
    );
    return SCScreenshotManager.fromPointer($ret, retain: false, release: true);
  }

  /// captureImageInRect:completionHandler:
  static void captureImageInRect(
    objc.CGRect rect, {
    objc.ObjCBlock<ffi.Void Function(ffi.Pointer<CGImage>, objc.NSError?)>?
    completionHandler,
  }) {
    objc.checkOsVersionInternal(
      'SCScreenshotManager.captureImageInRect:completionHandler:',
      macOS: (false, (15, 2, 0)),
    );
    _objc_msgSend_1ekrzmp(
      _class_SCScreenshotManager,
      _sel_captureImageInRect_completionHandler_,
      rect,
      completionHandler?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// captureImageWithFilter:configuration:completionHandler:
  static void captureImageWithFilter(
    SCContentFilter contentFilter, {
    required SCStreamConfiguration configuration,
    objc.ObjCBlock<ffi.Void Function(ffi.Pointer<CGImage>, objc.NSError?)>?
    completionHandler,
  }) {
    objc.checkOsVersionInternal(
      'SCScreenshotManager.captureImageWithFilter:configuration:completionHandler:',
      macOS: (false, (14, 0, 0)),
    );
    _objc_msgSend_18qun1e(
      _class_SCScreenshotManager,
      _sel_captureImageWithFilter_configuration_completionHandler_,
      contentFilter.ref.pointer,
      configuration.ref.pointer,
      completionHandler?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// captureSampleBufferWithFilter:configuration:completionHandler:
  static void captureSampleBufferWithFilter(
    SCContentFilter contentFilter, {
    required SCStreamConfiguration configuration,
    objc.ObjCBlock<
      ffi.Void Function(ffi.Pointer<opaqueCMSampleBuffer>, objc.NSError?)
    >?
    completionHandler,
  }) {
    objc.checkOsVersionInternal(
      'SCScreenshotManager.captureSampleBufferWithFilter:configuration:completionHandler:',
      macOS: (false, (14, 0, 0)),
    );
    _objc_msgSend_18qun1e(
      _class_SCScreenshotManager,
      _sel_captureSampleBufferWithFilter_configuration_completionHandler_,
      contentFilter.ref.pointer,
      configuration.ref.pointer,
      completionHandler?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// captureScreenshotWithFilter:configuration:completionHandler:
  static void captureScreenshotWithFilter(
    SCContentFilter contentFilter, {
    required SCScreenshotConfiguration configuration,
    objc.ObjCBlock<ffi.Void Function(SCScreenshotOutput?, objc.NSError?)>?
    completionHandler,
  }) {
    objc.checkOsVersionInternal(
      'SCScreenshotManager.captureScreenshotWithFilter:configuration:completionHandler:',
      macOS: (false, (26, 0, 0)),
    );
    _objc_msgSend_18qun1e(
      _class_SCScreenshotManager,
      _sel_captureScreenshotWithFilter_configuration_completionHandler_,
      contentFilter.ref.pointer,
      configuration.ref.pointer,
      completionHandler?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// captureScreenshotWithRect:configuration:completionHandler:
  static void captureScreenshotWithRect(
    objc.CGRect rect, {
    required SCScreenshotConfiguration configuration,
    objc.ObjCBlock<ffi.Void Function(SCScreenshotOutput?, objc.NSError?)>?
    completionHandler,
  }) {
    objc.checkOsVersionInternal(
      'SCScreenshotManager.captureScreenshotWithRect:configuration:completionHandler:',
      macOS: (false, (26, 0, 0)),
    );
    _objc_msgSend_4u48uz(
      _class_SCScreenshotManager,
      _sel_captureScreenshotWithRect_configuration_completionHandler_,
      rect,
      configuration.ref.pointer,
      completionHandler?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// new
  static SCScreenshotManager new$() {
    final $ret = _objc_msgSend_151sglz(_class_SCScreenshotManager, _sel_new);
    return SCScreenshotManager.fromPointer($ret, retain: false, release: true);
  }

  /// Returns a new instance of SCScreenshotManager constructed with the default `new` method.
  SCScreenshotManager() : this.as(new$().object$);
}

extension SCScreenshotManager$Methods on SCScreenshotManager {
  /// init
  SCScreenshotManager init() {
    objc.checkOsVersionInternal(
      'SCScreenshotManager.init',
      iOS: (false, (2, 0, 0)),
      macOS: (false, (10, 0, 0)),
    );
    final $ret = _objc_msgSend_151sglz(
      object$.ref.retainAndReturnPointer(),
      _sel_init,
    );
    return SCScreenshotManager.fromPointer($ret, retain: false, release: true);
  }
}
